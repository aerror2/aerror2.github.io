
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>回顾 WINDOWS98 NEST V8086模式和中断服务调用</title>
    <link rel="stylesheet" href="css/common/125a8466cc4b403bad0ef03b725d6f5d.css">
    <link rel="stylesheet" href="css/common/762f7595fdc29098c10bedc44fb08d79.css">
    <link rel="stylesheet" href="css/common/25978cf10b5368d50d66d027f7ac6995.css">
    <link rel="stylesheet" href="css/common/01256533b5796652379f01b9d5d2a4e1.css">
    <link rel="stylesheet" href="css/common/3456820cac63d19e4c744608c87562e9.css">
    <link rel="stylesheet" href="css/common/24f21657c5465ed6e144fb4401350e07.css">
    <link rel="stylesheet" href="css/common/1a98987dfda088c62bb1183b9ebd77b8.css">
    <link rel="stylesheet" href="css/common/01addd087fe9e3ace40b6be660c60689.css">
    <link rel="stylesheet" href="css/common/7fec870fdbedeaba28df5c37ac431c1d.css">
    <link rel="stylesheet" href="css/common/7ebfc34abf5dd1ce6de5f5865a58ff24.css">
    <link rel="stylesheet" href="css/common/40f864214c8f1419f9c655aaf1b6fa71.css">
    <link rel="stylesheet" href="css/common/inline_1b451fdea25e76a730a723374f416b11.css">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-okaidia.min.css">

    <style>
        /* 保留CSDN常用的文本颜色类 */
        .text-red, [class*="text-red"] { color: red !important; }
        .text-blue, [class*="text-blue"] { color: blue !important; }
        .text-green, [class*="text-green"] { color: green !important; }
        .text-yellow, [class*="text-yellow"] { color: #FFD700 !important; }
        .text-purple, [class*="text-purple"] { color: purple !important; }
        .text-orange, [class*="text-orange"] { color: orange !important; }
        
        /* 保留常见的CSDN文本样式类 */
        .bold, .strong, [class*="bold"], [class*="strong"] { font-weight: bold !important; }
        .italic, .em, [class*="italic"], [class*="em"] { font-style: italic !important; }
        .underline, [class*="underline"] { text-decoration: underline !important; }
        
        /* 确保内联样式不被覆盖 */
        .article-content * { color: initial; background-color: initial; font-weight: initial; font-style: initial; text-decoration: initial; }
        
        /* 保留font标签的color属性 */
        .article-content font[color="red"] { color: red !important; }
        .article-content font[color="blue"] { color: blue !important; }
        .article-content font[color="green"] { color: green !important; }
        .article-content font[color="yellow"] { color: yellow !important; }
        .article-content font[color="purple"] { color: purple !important; }
        .article-content font[color="orange"] { color: orange !important; }
        .article-content font[color="black"] { color: black !important; }
        .article-content font[color="white"] { color: white !important; }
        .article-content font[color="gray"] { color: gray !important; }
        .article-content font[color="#000000"] { color: #000000 !important; }
        .article-content font[color="#FF0000"] { color: #FF0000 !important; }
        .article-content font[color="#00FF00"] { color: #00FF00 !important; }
        .article-content font[color="#0000FF"] { color: #0000FF !important; }
        .article-content font[color="#FFFF00"] { color: #FFFF00 !important; }
        .article-content font[color="#00FFFF"] { color: #00FFFF !important; }
        .article-content font[color="#FF00FF"] { color: #FF00FF !important; }
    </style>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; padding: 20px; max-width: 1200px; margin: 0 auto; background-color: #f8f9fa; }
        img { max-width: 100%; height: auto; }
        pre { background-color: #2d2d2d; padding: 10px; border-radius: 5px; overflow-x: auto; margin: 1em 0; }
        code { font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; }
        pre[class*="language-"] { position: relative; }
        pre[class*="language-"] .copy-to-clipboard-button { position: absolute; top: 5px; right: 5px; background: rgba(0,0,0,0.3); color: white; border: none; border-radius: 3px; padding: 5px 10px; font-size: 0.8em; cursor: pointer; }
        pre[class*="language-"] .copy-to-clipboard-button:hover { background: rgba(0,0,0,0.5); }
        pre[class*="language-"] code { user-select: all; -webkit-user-select: all; -moz-user-select: all; -ms-user-select: all; }
        pre[class*="language-"]:hover .copy-to-clipboard-button { display: block; }
        pre[class*="language-"] .copy-to-clipboard-button { display: none; }
        .source-link { margin-bottom: 15px; color: #666; }
        h1 { font-size: 28px; margin-bottom: 15px; color: #333; }
        .article-content { margin-top: 25px; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        
        /* 文章元数据样式 */
        .article-meta { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 15px; 
            font-size: 14px; 
            color: #666; 
            margin-bottom: 15px; 
        }
        .meta-item { 
            display: flex; 
            align-items: center; 
        }
        .meta-item i { 
            margin-right: 5px; 
            color: #0066cc; 
        }
        
        /* 标签样式 */
        .article-tags { 
            margin-bottom: 15px; 
        }
        .tag { 
            display: inline-block; 
            background-color: #e6f2ff; 
            color: #0066cc; 
            padding: 3px 8px; 
            border-radius: 4px; 
            font-size: 12px; 
            margin-right: 5px; 
        }
        
        /* 描述样式 */
        .article-description { 
            background-color: #f5f5f5; 
            padding: 15px; 
            border-left: 4px solid #0066cc; 
            margin-bottom: 20px; 
            font-style: italic; 
            color: #555; 
        }
        .token.comment, .token.prolog, .token.doctype, .token.cdata { color: #8292a2; }
        .token.punctuation { color: #f8f8f2; }
        .token.namespace { opacity: .7; }
        .token.property, .token.tag, .token.constant, .token.symbol, .token.deleted { color: #f92672; }
        .token.boolean, .token.number { color: #ae81ff; }
        .token.selector, .token.attr-name, .token.string, .token.char, .token.builtin, .token.inserted { color: #a6e22e; }
        .token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string, .token.variable { color: #f8f8f2; }
        .token.atrule, .token.attr-value, .token.function, .token.class-name { color: #e6db74; }
        .token.keyword { color: #66d9ef; }
        .token.regex, .token.important { color: #fd971f; }
        .token.important, .token.bold { font-weight: bold; }
        .token.italic { font-style: italic; }
        .token.entity { cursor: help; }
        
        /* 添加header和footer样式 */
        .header { 
            padding: 10px 0; 
            margin-bottom: 20px; 
            border-bottom: 1px solid #eee; 
        }
        .header a { 
            text-decoration: none; 
            color: #007bff; 
            font-weight: bold; 
        }
        .header a:hover { 
            text-decoration: underline; 
        }
        .footer { 
            margin-top: 30px; 
            padding-top: 20px; 
            border-top: 1px solid #eee; 
            color: #666; 
            font-size: 0.9em; 
            text-align: center; 
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="index.html">← 返回目录</a>
    </div>
    
    <h1>回顾 WINDOWS98 NEST V8086模式和中断服务调用</h1>
    <div class="source-link">原文链接: <a href="https://blog.csdn.net/aerror/article/details/3659164" target="_blank">https://blog.csdn.net/aerror/article/details/3659164</a></div>
    
    <div class="article-meta">
        <div class="meta-item"><i class="far fa-calendar-alt"></i> 发布时间: 2008-12-31 00:30:00</div>
        <div class="meta-item"><i class="far fa-eye"></i> 浏览量: 9006</div>
        
        
        
    </div>
    
    <div class="article-tags">标签: <span class="tag">windows</span>, <span class="tag">buffer</span>, <span class="tag">struct</span>, <span class="tag">磁盘</span>, <span class="tag">ios</span>, <span class="tag">system</span></div>
    
    <div class="article-description">新的一年到了,不禁回头望了一下，写些老掉牙的东西以作纪念。早在2004年,我当时正在写个wdm的驱动程序，因为软件的版本允许在windows 98, windows NT 4.0 , windows 2000和windows XP上运行，我不想每个写了一个wdm后，再实现一个相同功能的Vxd，在当时我的想法里，这是不利行维护，是不明智的行为，于是我决定让我的WDM程序可以在上面所说的所有win</div>
    
    <div class="article-content">
        <div class="htmledit_views atom-one-dark" id="content_views">
<p style="TEXT-INDENT: 21pt"><span style="COLOR: #333333; FONT-SIZE: 9pt"><font face="宋体">新的一年到了<span lang="EN-US">,</span>不禁回头望了一下，写些老掉牙的东西以作纪念。<span lang="EN-US"></span></font></span></p>
<p style="TEXT-INDENT: 21pt"><span style="COLOR: #333333; FONT-SIZE: 9pt"><font face="宋体">早在<span lang="EN-US">2004</span>年<span lang="EN-US">,</span>我当时正在写个<span lang="EN-US">wdm</span>的驱动程序，因为软件的版本允许在<span lang="EN-US">windows 98, windows NT 4.0 , windows 2000</span>和<span lang="EN-US">windows XP</span>上运行，我不想每个写了一个<span lang="EN-US">wdm</span>后，再实现一个相同功能的<span lang="EN-US">Vxd</span>，在当时我的想法里，这是不利行维护，是不明智的行为，于是我决定让我的<span lang="EN-US">WDM</span>程序可以在上面所说的所有<span lang="EN-US">windows</span>版本上正确运行。想法是美好的，但实现的过程中吃不少苦头。<span lang="EN-US"></span></font></span></p>
<p><span lang="EN-US" style="COLOR: #333333; FONT-SIZE: 9pt"><font face="宋体"> </font></span></p>
<p style="TEXT-INDENT: 21pt"><span style="COLOR: #333333; FONT-SIZE: 9pt"><font face="宋体">其中有一项功能是涉及到对磁盘扇区的直接读写取的，有很多种方式的来解决这个问题，在<span lang="EN-US">NT</span>系统下，最简单莫过直接构造<span lang="EN-US">IRP</span>传递给磁盘驱动程序，或者最直接的<span lang="EN-US">IO PORT</span>操作，<span lang="EN-US">BIOS </span>中断<span lang="EN-US"> INT 13</span>等。 使用<span lang="EN-US">IO PORT,</span>这适用于<span lang="EN-US">NT </span>和<span lang="EN-US">windows 98</span>，看来完美解决方案，但问题的是兼容性比较差，实际的效果表明驱动使用这种方式也表现得很不稳定。而最偷懒最简单最稳定的方式却是直接构造<span lang="EN-US">IRP</span>传递给磁盘驱动程序，可惜只能用于<span lang="EN-US">NT</span>，原因是虽然<span lang="EN-US">windows 98 ntkern.vxd</span>这个系统模块中包括有大量<span lang="EN-US">NT</span>内核支持函数的<span lang="EN-US">windoes 98</span>实现，号称<span lang="EN-US">wdm</span>程序几乎区别不了这两个环境，但事实上却没有这样高度的统一，没有像<span lang="EN-US">NT</span>一样所有的内核模式都使用一个公用的数据结构<span lang="EN-US">(IRP)</span>，如串口的驱动程序要遵从<span lang="EN-US">VCOMM.vxd</span>规定的<span lang="EN-US">port</span>驱动程序函数调用规范，而磁盘驱动程序则遵从<span lang="EN-US">IOS.vxd</span>实现的包驱动层次结构，<span lang="EN-US">NTKERN.VXD</span>实事上遗留了不少未实现的函数。所以当时最开始的打算是在<span lang="EN-US">NT </span>系统下使用<span lang="EN-US">IRP</span>传递给磁盘驱动程序的方式，而<span lang="EN-US">windows 98</span>则采用类似的<span lang="EN-US">Ios_SendCommand</span>的方式向磁盘驱动投递请求。<span lang="EN-US"></span></font></span></p>
<p style="TEXT-INDENT: 21pt"><span style="COLOR: #333333; FONT-SIZE: 9pt"><font face="宋体">在<span lang="EN-US">windows98</span>下<span lang="EN-US">Ios_SendCommand</span>工作得像<span lang="EN-US">windows 2000</span>下的<span lang="EN-US">IoCallDriver</span>一样简单优雅，但是不幸的是，程序需要在驱动初始化的也要进行对磁盘的读取，在这个阶段<span lang="EN-US">Ios_SendCommand</span>完全不能工作，是因为<span lang="EN-US">NTKERN.VXD</span>把<span lang="EN-US">WDM</span>的驱动在<span lang="EN-US">IOS.SYS</span>初始化完成一份硬盘驱动器表之前就初始化了，同时<span lang="EN-US">WDM</span>的序动顺序也无法像在<span lang="EN-US">WINDOWS2000</span>下面那样多的级别可以指定，而我驱动程序要刚好在系统加载<span lang="EN-US">SYSTEM32</span>下面的<span lang="EN-US">RING3</span>层<span lang="EN-US">DLL</span>之前，这样初始化动作才有效（事实上我需要修改那</font></span></p>
<p style="TEXT-INDENT: 21pt"><span style="COLOR: #333333; FONT-SIZE: 9pt"><font face="宋体">些<span lang="EN-US">SYSTEM32</span>目录下的<span lang="EN-US">DLL,</span>如果它们一旦给初始化<span lang="EN-US">,</span>就无法进行写入的操作了）。而我不想使用直接<span lang="EN-US">IO</span>的方式，没有办法，我只能求助于<span lang="EN-US">BIOS</span>的<span lang="EN-US">INT 13H(</span>及<span lang="EN-US">INT 13H</span>的对于大硬盘的扩展功能<span lang="EN-US">)</span>。<span lang="EN-US"></span></font></span></p>
<p style="TEXT-INDENT: 21pt"><span style="COLOR: #333333; FONT-SIZE: 9pt"><font face="宋体">在这里我使用了<span lang="EN-US">nest_v86_execute</span>来进入<span lang="EN-US">16bit</span>的实模式环境来执行<span lang="EN-US">INT 13h</span>，使用了<span lang="EN-US">VMMGR </span>的服务接口来申请<span lang="EN-US">1MB</span>以下的内存，并在<span lang="EN-US">16 bit</span>实模式和<span lang="EN-US">32 bit </span>保护模式两种模式下交换数据。<span lang="EN-US"></span></font></span></p>
<p style="TEXT-INDENT: 21pt"><span style="COLOR: #333333; FONT-SIZE: 9pt"><font face="宋体">呵呵，当初有趣的尝试，带来了不少的乐趣和新知识。<span lang="EN-US"></span></font></span></p>
<p style="TEXT-INDENT: 21pt"><span style="COLOR: #333333; FONT-SIZE: 9pt"><font face="宋体">以下附录一些代码<span lang="EN-US">:</span></font></span></p><span style="COLOR: #333333; FONT-SIZE: 9pt"><font face="宋体"><span lang="EN-US">
<div class="highlighter">
<ol class="highlighter-c"><li></li><li class="alt"><span class="comment">//WINDOWS nt/2000使用IRP的IoCallDriver来访问硬盘 </span></li><li><span class="comment">// </span></li><li class="alt"> <span class="comment">// Initialize unicode string </span></li><li>    <span class="comment">// </span></li><li class="alt">    RtlInitUnicodeString(&amp;uszDeviceName, L<span class="string">"//DosDevices//PhysicalDrive0"</span>);</li><li>    ntStatus = STATUS_INSUFFICIENT_RESOURCES;</li><li class="alt"></li><li>    <span class="comment">// Get a pointer to PhysicalDrive0 </span></li><li class="alt">    <span class="comment">// </span></li><li>    ntStatus = IoGetDeviceObjectPointer(&amp;uszDeviceName,</li><li class="alt">                                        FILE_ANY_ACCESS,</li><li>                                        &amp;fileObject,</li><li class="alt">                                        &amp;pDriveDeviceObject);</li><li></li><li class="alt">    <span class="comment">// If the device object pointer is valid... </span></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="keyword">if</span>(NT_SUCCESS(ntStatus))</li><li>    {<!-- --></li><li class="alt">        IO_STATUS_BLOCK    ioStatus; </li><li>        KEVENT             <span class="keyword">event</span>; </li><li class="alt">        PIRP               pIrp;</li><li></li><li class="alt">                   </li><li>        KeInitializeEvent(<span class="keyword">event</span>, NotificationEvent, FALSE); </li><li class="alt">            </li><li></li><li class="alt">        pIrp = IoBuildSynchronousFsdRequest(bRead?IRP_MJ_READ:IRP_MJ_WRITE,</li><li>                                            pDriveDeviceObject,</li><li class="alt">                                            pBuffer,</li><li>                                            512,</li><li class="alt">                                            &amp;llSectorNum,</li><li>                                            <span class="keyword">event</span>,</li><li class="alt">                                            &amp;ioStatus);</li><li></li><li class="alt">        <span class="keyword">if</span>(!pIrp)</li><li>        {<!-- --></li><li class="alt">           ObDereferenceObject(fileObject);</li><li>           <span class="keyword">return</span> STATUS_BAD_STACK; </li><li class="alt">        }</li><li></li><li class="alt">        ntStatus = IoCallDriver(pDriveDeviceObject, pIrp);</li><li></li><li class="alt">        <span class="keyword">if</span>(ntStatus == STATUS_PENDING)</li><li>        {<!-- --></li><li class="alt">            KeWaitForSingleObject(<span class="keyword">event</span>, Suspended, KernelMode, FALSE, NULL);</li><li>            ntStatus = ioStatus.Status;</li><li class="alt">        } </li><li>            </li><li class="alt">        <span class="comment">// Ditch the fileObject pointer created earlier </span></li><li>        <span class="comment">// </span></li><li class="alt">        ObDereferenceObject(fileObject);</li><li>    }</li><li class="alt"></li><li><span class="comment">//WINDOWS98使用ios_sendCommand来访问硬盘 </span></li><li class="alt"><span class="comment">// </span><span class="preprocessor"></span></li><li><span class="preprocessor">#include "ior.h" </span></li><li class="alt"><span class="keyword">int</span> TestIos_SendCmd(<span class="keyword">void</span> * pbuffer)</li><li><span class="comment">/*++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></li><li class="alt"><span class="comment">    Routine Description:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">        Just a testing for Ios_SendCommand,I try to pass the</span></li><li><span class="comment">    request to ios.sys.</span></li><li class="alt"><span class="comment">    Arguments:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">        pbuffer -- a buffer.        </span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    Return Value:</span></li><li><span class="comment">        </span></li><li class="alt"><span class="comment">        if all thing ok return 1,else return 0.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">-------------------------------------------------------*/</span></li><li>{<!-- --></li><li class="alt">    IOR iorStru;</li><li>    UCHAR nDisk = 0x80;</li><li class="alt">    </li><li>readBein:</li><li class="alt">    memset(&amp;iorStru,0,<span class="keyword">sizeof</span>(iorStru));</li><li>    iorStru.IOR_func  =IOR_READ; </li><li class="alt">    iorStru.IOR_flags  =IORF_PHYS_CMD|IORF_VERSION_002|IORF_SYNC_COMMAND|IORF_HIGH_PRIORITY|IORF_WIN32;</li><li>    iorStru.IOR_start_addr[0]=0;    <span class="comment">//start position los </span></li><li class="alt">    iorStru.IOR_start_addr[1]=0;    <span class="comment">//start position high </span></li><li>    iorStru.IOR_xfer_count = 1;     <span class="comment">//num of sector to read. </span></li><li class="alt">    iorStru.IOR_buffer_ptr = (ULONG)pbuffer; <span class="comment">//Address of the buffer </span></li><li>    iorStru.IOR_vol_designtr = nDisk;   <span class="comment">//disknum. </span></li><li class="alt"></li><li>    _asm {<!-- --></li><li class="alt">        push esi;</li><li>        lea esi,iorStru</li><li class="alt">        _asm _emit 0xcd </li><li>        _asm _emit 0x20 </li><li class="alt">        _asm _emit (0x00100004 &amp; 0xff) </li><li>        _asm _emit (0x00100004) &gt;&gt; 8 &amp; 0xff </li><li class="alt">        _asm _emit (0x00100004) &gt;&gt; 16 &amp; 0xff </li><li>        _asm _emit (0x00100004) &gt;&gt; 24 &amp; 0xff    <span class="comment">//Ios_SendCommand </span></li><li class="alt">        pop esi;</li><li>    }</li><li class="alt">    <span class="keyword">if</span>(iorStru.IOR_status == 0x17)</li><li>    {<!-- --></li><li class="alt">        <span class="keyword">if</span>(nDisk == 0x80)</li><li>        {<!-- --></li><li class="alt">            nDisk = 0x81;</li><li>            <span class="keyword">goto</span> readBein;</li><li class="alt">        }</li><li>        <span class="keyword">else</span> <span class="keyword">if</span> (nDisk == 0x81)</li><li class="alt">        {<!-- --></li><li>            nDisk = 0x2;</li><li class="alt">            <span class="keyword">goto</span> readBein;</li><li>        }</li><li class="alt"></li><li>    }</li><li class="alt">    <span class="keyword">else</span></li><li>        <span class="keyword">return</span> 1;</li><li class="alt">}</li><li></li><li class="alt"><span class="comment">//使用BIOS INT 13扩展功能来访问硬盘 </span></li><li><span class="comment">// </span></li><li class="alt"><span class="comment">// </span></li><li><span class="comment">/**</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">        purpose:    define Some Useful defines and structure for using int 13h</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">      here's the v86mgr real data.</span></li><li class="alt"><span class="comment"> */</span></li><li>FFFFFFFF    V86MMGR</li><li class="alt">00060000    V86MMGR_Get_Version</li><li>00060001    V86MMGR_Allocate_V86_Pages</li><li class="alt">00060002    V86MMGR_Set_EMS_XMS_Limits</li><li>00060003    V86MMGR_Get_EMS_XMS_Limits</li><li class="alt">00060004    V86MMGR_Set_Mapping_Info</li><li>00060005    V86MMGR_Get_Mapping_Info</li><li class="alt">00060006    V86MMGR_Xlat_API</li><li>00060007    V86MMGR_Load_Client_Ptr</li><li class="alt">00060008    V86MMGR_Allocate_Buffer</li><li>00060009    V86MMGR_Free_Buffer</li><li class="alt">0006000A    V86MMGR_Get_Xlat_Buff_State</li><li>0006000B    V86MMGR_Set_Xlat_Buff_State</li><li class="alt">0006000C    V86MMGR_Get_VM_Flat_Sel</li><li>0006000D    V86MMGR_Map_Pages</li><li class="alt">0006000E    V86MMGR_Free_Page_Map_Region</li><li>0006000F    V86MMGR_LocalGlobalReg</li><li class="alt">00060010    V86MMGR_GetPgStatus</li><li>00060011    V86MMGR_SetLocalA20</li><li class="alt">00060012    V86MMGR_ResetBasePages</li><li>00060013    V86MMGR_SetAvailMapPgs</li><li class="alt">00060014    V86MMGR_NoUMBInitCalls</li><li>00060015    V86MMGR_Get_EMS_XMS_Avail</li><li class="alt">00060016    V86MMGR_Toggle_HMA</li><li>00060017    V86MMGR_Dev_Init</li><li class="alt">00060018    V86MMGR_Alloc_UM_Page</li><li> */ <span class="preprocessor"></span></li><li class="alt"><span class="preprocessor"></span></li><li><span class="preprocessor">#define  _VMMCALL_V86MMGR_Allocate_Buffer   _asm _emit 0xcd / </span></li><li class="alt">    _asm _emit 0x20 /</li><li>    _asm _emit (0x00060008 &amp; 0xff) /</li><li class="alt">    _asm _emit (0x00060008 &gt;&gt; 8) &amp; 0xff /</li><li>    _asm _emit (0x00060008 &gt;&gt; 16) &amp; 0xff /</li><li class="alt">    _asm _emit (0x00060008 &gt;&gt; 24) &amp; 0xff / <span class="preprocessor"></span></li><li><span class="preprocessor"></span></li><li class="alt"><span class="preprocessor">#define  _VMMCALL_V86MMGR_Free_Buffer  _asm _emit 0xcd / </span></li><li>    _asm _emit 0x20 /</li><li class="alt">    _asm _emit (0x00060009 &amp; 0xff) /</li><li>    _asm _emit (0x00060009  &gt;&gt; 8) &amp; 0xff /</li><li class="alt">    _asm _emit (0x00060009  &gt;&gt; 16) &amp; 0xff /</li><li>    _asm _emit (0x00060009  &gt;&gt; 24) &amp; 0xff / <span class="preprocessor"></span></li><li class="alt"><span class="preprocessor"></span></li><li><span class="preprocessor"></span></li><li class="alt"><span class="preprocessor"></span></li><li><span class="preprocessor">#define _MICRO_V86MMGR_ALLOCATE_BUFFER_COPIED(VMHANDLE,PCLIENTSTRU,LPBUFFER,CONST_NUM,NUMCOPIED,FPTR)   / </span></li><li class="alt">    _asm{mov ebx,VMHANDLE} /</li><li>    _asm{push   esi} /</li><li class="alt">    _asm{mov    esi,LPBUFFER} /</li><li>    _asm{mov    ecx,CONST_NUM} /</li><li class="alt">    _asm{push   ebp } /</li><li>    _asm{mov    ebp,PCLIENTSTRU} /</li><li class="alt">    _asm{STC    } /</li><li>    _asm{push   ds} /</li><li class="alt">    _asm{pop    fs} /</li><li>    {_VMMCALL_V86MMGR_Allocate_Buffer} /</li><li class="alt">    _asm{pop ebp} /</li><li>    _asm{pop esi} /</li><li class="alt">    _asm{mov NUMCOPIED,ECX} /</li><li>    _asm{mov FPTR,EDI} / <span class="preprocessor"></span></li><li class="alt"><span class="preprocessor"></span></li><li><span class="preprocessor"></span></li><li class="alt"><span class="preprocessor">#define _MICRO_V86MMGR_ALLOCATE_BUFFER_NOTCOPIED(VMHANDLE,PCLIENTSTRU,CONST_NUM,NUMALLOCATED,FPTR)  / </span></li><li>    _asm{mov    ebx,VMHANDLE} /</li><li class="alt">    _asm{mov    ecx,CONST_NUM} /</li><li>    _asm{push   ebp } /</li><li class="alt">    _asm{mov    ebp,PCLIENTSTRU} /</li><li>    _asm{CLC    } /</li><li class="alt">    {_VMMCALL_V86MMGR_Allocate_Buffer} /</li><li>    _asm{pop ebp} /</li><li class="alt">    _asm{mov NUMALLOCATED,ECX} /</li><li>    _asm{mov FPTR,EDI} / <span class="preprocessor"></span></li><li class="alt"><span class="preprocessor"></span></li><li><span class="preprocessor"></span></li><li class="alt"><span class="preprocessor">#define _MICRO_V86MMGR_FREE_BUFFER_COPIED(VMHANDLE,PCLIENTSTRU,LPBUFFER,NUMCOPIED)  / </span></li><li>    _asm{mov  ebx, VMHANDLE} /</li><li class="alt">    _asm{push   esi} /</li><li>    _asm{mov    esi, LPBUFFER} /</li><li class="alt">    _asm{mov    ecx, NUMCOPIED} /</li><li>    _asm{push   ebp} /</li><li class="alt">    _asm{mov    ebp, PCLIENTSTRU} /</li><li>    _asm{push   ds} /</li><li class="alt">    _asm{pop    fs} /</li><li>    _asm{stc    } /</li><li class="alt">    {_VMMCALL_V86MMGR_Free_Buffer} /</li><li>    _asm{pop    ebp} /</li><li class="alt">    _asm{pop    esi} / <span class="preprocessor"></span></li><li><span class="preprocessor"></span></li><li class="alt"><span class="preprocessor"></span></li><li><span class="preprocessor">#define _MICRO_V86MMGR_FREE_BUFFER_NOTCOPIED(VMHANDLE,PCLIENTSTRU,NUMCOPIED)    / </span></li><li class="alt">    _asm{mov    ebx, VMHANDLE} /</li><li>    _asm{mov    ecx, NUMCOPIED} /</li><li class="alt">    _asm{push   ebp} /</li><li>    _asm{mov    ebp, PCLIENTSTRU} /</li><li class="alt">    _asm{CLC    } /</li><li>    {_VMMCALL_V86MMGR_Free_Buffer} /</li><li class="alt">    _asm{pop    ebp} / <span class="preprocessor"></span></li><li><span class="preprocessor">    </span></li><li class="alt"><span class="preprocessor"></span></li><li><span class="preprocessor"></span></li><li class="alt"><span class="preprocessor">#define _SAVE_CLIENT_STATE(SAVEREGS)  / </span></li><li>    _asm{push edi}/</li><li class="alt">    _asm{lea edi,SAVEREGS} /</li><li>    VMMCall(Save_Client_State) /</li><li class="alt">    _asm{pop edi} <span class="preprocessor"></span></li><li><span class="preprocessor"></span></li><li class="alt"><span class="preprocessor">#define _RESTORE_CLIENT_STATE(SAVEREGS) / </span></li><li>    _asm push esi /</li><li class="alt">    _asm lea esi,SAVEREGS /</li><li>    VMMCall(Restore_Client_State) /</li><li class="alt">    _asm pop esi / <span class="preprocessor"></span></li><li><span class="preprocessor"></span></li><li class="alt"><span class="preprocessor"></span></li><li><span class="preprocessor"></span></li><li class="alt"><span class="preprocessor">#define _CALL_INT13_V86_(VMHANDLE,PCLIENTSTRU) / </span></li><li>    _asm{mov ebx,VMHANDLE}/</li><li class="alt">    _asm{push ebp}/</li><li>    _asm{mov ebp,PCLIENTSTRU} /</li><li class="alt">    VMMCall(Begin_Nest_V86_Exec) /</li><li>    _asm{mov eax,13h} /</li><li class="alt">    {VMMCall(Exec_Int)} /</li><li>    End_Nest_Exec();/</li><li class="alt">    _asm{pop ebp}/ <span class="preprocessor"></span></li><li><span class="preprocessor"></span></li><li class="alt"><span class="preprocessor"></span></li><li><span class="preprocessor">#define GETVM_HANDLE_CLIENTSTRU(VMHANDLE,PCLIENTSTRU) / </span></li><li class="alt">    VMHANDLE = (<span class="keyword">struct</span> cb_s *)Get_Cur_VM_Handle();/</li><li>    _asm{mov ebx,VMHANDLE} /</li><li class="alt">    PCLIENTSTRU = (CLIENT_STRUCT *)VMHANDLE-&gt;CB_Client_Pointer;/</li><li></li><li class="alt"></li><li><span class="comment">// </span></li><li class="alt"><span class="comment">//The next few lines, will map the values into </span></li><li><span class="comment">//the registers as need by INT13 </span></li><li class="alt"><span class="comment">// </span><span class="preprocessor"></span></li><li><span class="preprocessor"></span></li><li class="alt"><span class="preprocessor">#define  MAKE_INT13CHSD_IN_HS(CYL,HEA,SEC,DISK) / </span></li><li>    _asm{MOVZX EAX ,CYL}/</li><li class="alt">    _asm{MOVZX EDX ,HEA}/</li><li>    _asm{MOVZX ECX ,SEC}/</li><li class="alt">    _asm{MOV   CH,AL}/</li><li>    _asm{ROR   AH,1}/</li><li class="alt">    _asm{ROR   AH,1}/</li><li>    _asm{OR    CL,AH}/</li><li class="alt">    _asm{MOV   DH,DL}/</li><li>    _asm{MOV   DL,DISK} /</li><li class="alt">    _asm{MOV   HEA,CX}/</li><li>    _asm{MOV   SEC,DX} / <span class="preprocessor"></span></li><li class="alt"><span class="preprocessor"></span></li><li><span class="preprocessor"></span></li><li class="alt"><span class="preprocessor">#pragma pack(1) </span></li><li>typedef <span class="keyword">struct</span> _tagDiskAddressPacket </li><li class="alt">{ </li><li>    BYTE PacketSize;     <span class="comment">// Packet Length(16bytes)  </span></li><li class="alt">    BYTE Reserved;       <span class="comment">// ==0  </span></li><li>    WORD BlockCount;     <span class="comment">// Transfer block count(Sector)  </span></li><li class="alt">    DWORD BufferAddr;    <span class="comment">// Transfer buffer pointer(segment:offset)  </span></li><li>    QWORD BlockNum;      <span class="comment">// Position To Start. </span></li><li class="alt">}DISKADDRESSPACKETI13E; </li><li></li><li class="alt"></li><li>typedef <span class="keyword">struct</span> _tagDriveParametersPacket</li><li class="alt">{ </li><li>    WORD  InfoSize;         <span class="comment">// Packet Leggth (26 Bytes)  </span></li><li class="alt">    WORD  Flags;            <span class="comment">// flag </span></li><li>    DWORD Cylinders;        <span class="comment">//  </span></li><li class="alt">    DWORD Heads;            <span class="comment">//  </span></li><li>    DWORD SectorsPerTrack;  <span class="comment">// Sectors per Track </span></li><li class="alt">    QWORD Sectors;          <span class="comment">// Amout of sectors. </span></li><li>    WORD  SectorSize;       <span class="comment">// Bytes per sector. </span></li><li class="alt">}DRIVEPARAMETERSPACKETI13E;  <span class="preprocessor"></span></li><li><span class="preprocessor">#pragma pack() </span></li><li class="alt"><span class="keyword">int</span> LBAToCHS(ULONG LbaNum,</li><li>             USHORT Sectors,</li><li class="alt">             USHORT Heads,</li><li>             PUSHORT pSectorNum,</li><li class="alt">             PUSHORT pHeadNum,</li><li>             PUSHORT pCylinderNum)</li><li class="alt"><span class="comment">/*++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></li><li><span class="comment">    Routine Description:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">        convert the LBA address to CHS address.</span></li><li class="alt"><span class="comment">    Arguments:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">        LbaNum  -- The LBA address.</span></li><li><span class="comment">        Sectors -- Sectors per Track </span></li><li class="alt"><span class="comment">        Heads   -- Amount Heads,you should to use Get DiskParams</span></li><li><span class="comment">                   To Get the sectors and heads.</span></li><li class="alt"><span class="comment">        pSectorNum  -- pointer to sector's result</span></li><li><span class="comment">        pHeadNum    -- pointer to Head's result</span></li><li class="alt"><span class="comment">        pCylinderNum -- pointer to Cylinder's result</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    Return Value:</span></li><li><span class="comment">        </span></li><li class="alt"><span class="comment">        if all thing ok return 1,else return 0.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    **********************</span></li><li><span class="comment">    </span></li><li class="alt"><span class="comment">    </span></li><li><span class="comment">-------------------------------------------------------*/</span></li><li class="alt">{<!-- --></li><li>    USHORT uSectorNum,uHeadNum,uCylinderNum;</li><li class="alt">    _asm{<!-- --></li><li>        MOV     EAX,LbaNum</li><li class="alt">        MOVZX   EBX,Sectors     </li><li>        XOR     EDX,EDX</li><li class="alt">        DIV     EBX         <span class="comment">//LbaNum / sectors  </span></li><li>        INC     EDX         <span class="comment">//EDX is the remainder,EAX is the quotient  </span></li><li class="alt">        MOV     ECX,EDX     </li><li>        MOVZX   EBX,Heads   </li><li class="alt">        XOR     EDX,EDX</li><li>        DIV     EBX</li><li class="alt">        MOV uCylinderNum,AX</li><li>        MOV uHeadNum,DX</li><li class="alt">        MOV uSectorNum,CX </li><li>    }</li><li class="alt">    *pSectorNum =uSectorNum;</li><li>    *pHeadNum = uHeadNum;</li><li class="alt">    *pCylinderNum = uCylinderNum;</li><li>    <span class="keyword">return</span> 1;</li><li class="alt">}</li><li></li><li class="alt"></li><li></li><li class="alt"></li><li><span class="keyword">int</span> GetHardDiskParamsI13(UCHAR nDiskNumber,PUSHORT pCylinders,PUSHORT pHeads,PUSHORT pSectors)</li><li class="alt"><span class="comment">/*++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></li><li><span class="comment">    Routine Description:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">        Get the Disk's params which specified by nDiskNumber using bios int 13h.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    Arguments:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">        nDiskNumber --Disk ID,0-5 for   Fixed hardDisk.</span></li><li class="alt"><span class="comment">        pCylinders -- pointer for amount of the disk Cylinders.if </span></li><li><span class="comment">                     the disk bigger than 8GB(Should be greater the 1024), </span></li><li class="alt"><span class="comment">                     it return only 1024.</span></li><li><span class="comment">        pHeads     --  pointer for heads.</span></li><li class="alt"><span class="comment">        pSectors   --  pointer for Sectors.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    Return Value:</span></li><li><span class="comment">        </span></li><li class="alt"><span class="comment">        if all thing ok return 1,else return 0.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    **********************</span></li><li><span class="comment">    </span></li><li class="alt"><span class="comment">    </span></li><li><span class="comment">-------------------------------------------------------*/</span></li><li class="alt"></li><li>{<!-- --></li><li class="alt">    USHORT Cylinders,Heads,Sectors;</li><li>    UCHAR DiskIDs[6] = {0x80,0x81,0x82,0x83,0x84,0x85};</li><li class="alt">    UCHAR nDisk;</li><li>    CLIENT_STRUCT saveregs; </li><li class="alt">    CLIENT_STRUCT *pClStru;</li><li>    <span class="keyword">struct</span> cb_s * hvm;</li><li class="alt">    <span class="keyword">if</span>(nDiskNumber &gt; 5 )</li><li>    {<!-- --></li><li class="alt">        <span class="keyword">return</span> 0;</li><li>    }</li><li class="alt">    nDisk = DiskIDs[nDiskNumber];</li><li></li><li class="alt">    GETVM_HANDLE_CLIENTSTRU(hvm,pClStru);</li><li>    _SAVE_CLIENT_STATE(saveregs);</li><li class="alt">    </li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">//Fill the client struct. </span></li><li>    <span class="comment">// </span></li><li class="alt">    pClStru-&gt;CBRS.Client_AH  = 0x08;</li><li>    pClStru-&gt;CBRS.Client_DL  = nDisk;</li><li class="alt"></li><li>    _CALL_INT13_V86_(hvm,pClStru);</li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">//Save the interest value to AX,DX,CX. </span></li><li>    <span class="comment">// </span></li><li class="alt">    _asm mov ebx,pClStru</li><li>    _asm mov AX,[ebx.Client_Flags]</li><li class="alt">    _asm mov DX,[ebx.Client_DX]</li><li>    _asm mov CX,[ebx.Client_CX]</li><li class="alt"></li><li>    _RESTORE_CLIENT_STATE(saveregs);</li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">//Now Get the proper params from DX,CX </span></li><li class="alt">    <span class="comment">// </span></li><li>    _asm{<!-- --></li><li class="alt">        test    AX,1</li><li>        jnz    loc_error</li><li class="alt">        MOV     AL,DH           <span class="comment">// </span></li><li>        XOR     AH,AH</li><li class="alt">        INC     AX</li><li>        MOV     Heads,AX        <span class="comment">// save head count </span></li><li class="alt"></li><li>        MOV     AL,CL           <span class="comment">// put sector number in AL </span></li><li class="alt">        AND     AX,3FH          <span class="comment">// and mask off cylinder bits </span></li><li>        MOV     Sectors,AX      <span class="comment">// save sector count </span></li><li class="alt"></li><li>        MOV     AL,CH           <span class="comment">// AL = cylinder LO </span></li><li class="alt">        MOV     AH,CL           <span class="comment">// AH = cylinder HI... </span></li><li>        MOV     CL,6</li><li class="alt">        SHR     AH,CL           <span class="comment">// shift the HI bits down </span></li><li>        INC     AX</li><li class="alt">        MOV     Cylinders,AX    <span class="comment">// save cylinder count </span></li><li>        jmp loc_success</li><li class="alt">    }</li><li>loc_error:</li><li class="alt">    <span class="keyword">return</span> 0;</li><li>loc_success:</li><li class="alt">    *pCylinders = Cylinders;</li><li>    *pHeads = Heads;</li><li class="alt">    *pSectors = Sectors;</li><li>    <span class="keyword">return</span> 1;</li><li class="alt">}</li><li></li><li class="alt"></li><li><span class="keyword">int</span> absDiskReadI13(</li><li class="alt">UCHAR nDiskNumber,  <span class="comment">//0~5; </span></li><li>USHORT nCylinders,</li><li class="alt">USHORT nHeads,      <span class="comment">//  </span></li><li>USHORT nSectors,    <span class="comment">// sector position </span></li><li class="alt">USHORT wSectors,    <span class="comment">//How many To read </span></li><li><span class="keyword">void</span>* pBuffer)      <span class="comment">//pointer to the buffer. </span></li><li class="alt"><span class="comment">/*++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></li><li><span class="comment">    Routine Description:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">        Read the Disk which specified by nDiskNumber using bios int 13h.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    Arguments:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">        nDiskNumber -- Disk ID,0-5 for   Fixed hardDisk.</span></li><li class="alt"><span class="comment">        nCylinders --  Starting Position's Cylinders .it should not be greater than 1024.</span></li><li><span class="comment">        nHeads     --  Starting Position's heads.</span></li><li class="alt"><span class="comment">        nSectors   --  Starting Position's Sectors.</span></li><li><span class="comment">        wSector    --  How many sector to read.</span></li><li class="alt"><span class="comment">        pBuffer    --  Buffer for receive the result of reading.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    Return Value:</span></li><li><span class="comment">        </span></li><li class="alt"><span class="comment">        if all thing ok return 1,else return 0.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    **********************</span></li><li><span class="comment">    </span></li><li class="alt"><span class="comment">    </span></li><li><span class="comment">-------------------------------------------------------*/</span></li><li class="alt">{<!-- --></li><li></li><li class="alt">    UCHAR DiskIDs[6] = {0x80,0x81,0x82,0x83,0x84,0x85};</li><li>    UCHAR nDisk;</li><li class="alt">    CLIENT_STRUCT saveregs; </li><li>    CLIENT_STRUCT *pClStru;</li><li class="alt">    <span class="keyword">struct</span> cb_s * hvm;</li><li>    WORD  nsegsel,noffset;</li><li class="alt">    DWORD FarPtrBuffer = 0;</li><li>    DWORD dwBytesCopied = 0;</li><li class="alt">    DWORD dwAssumBuffLen = 0;</li><li>    DWORD vmpnum = 0x10;</li><li class="alt">    DWORD retu = 1;</li><li>    <span class="keyword">if</span>(nDiskNumber &gt; 5 || wSectors == 0  )</li><li class="alt">    {<!-- --></li><li>        <span class="keyword">return</span> 0;</li><li class="alt">    }</li><li>    </li><li class="alt">    dwAssumBuffLen = 512 *  wSectors;</li><li>    nDisk =  DiskIDs[nDiskNumber];</li><li class="alt">    hvm = (<span class="keyword">struct</span> cb_s *)Get_Cur_VM_Handle();</li><li>    pClStru = (CLIENT_STRUCT *)hvm-&gt;CB_Client_Pointer;</li><li class="alt">       </li><li>    _MICRO_V86MMGR_ALLOCATE_BUFFER_NOTCOPIED(hvm,pClStru,dwAssumBuffLen,</li><li class="alt">        dwBytesCopied,FarPtrBuffer);</li><li>    _asm jc Loc_ret_Failed ;</li><li class="alt"></li><li>    _SAVE_CLIENT_STATE(saveregs);</li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">//Fill Int13 entries.. </span></li><li>    <span class="comment">// </span></li><li class="alt">    nsegsel = HIWORD(FarPtrBuffer);</li><li>    noffset = LOWORD(FarPtrBuffer);</li><li class="alt">    MAKE_INT13CHSD_IN_HS(nCylinders,nHeads,nSectors,nDisk);</li><li>    pClStru-&gt;CWRS.Client_CX = nHeads;</li><li class="alt">    pClStru-&gt;CWRS.Client_DX  = nSectors;</li><li>    pClStru-&gt;CBRS.Client_AH  = 0x02; <span class="comment">//To Read  </span></li><li class="alt">    pClStru-&gt;CBRS.Client_AL = (UCHAR)wSectors;<span class="comment">//How many to read. </span></li><li>    pClStru-&gt;CRS.Client_ES  = nsegsel;</li><li class="alt">    pClStru-&gt;CWRS.Client_BX = noffset;</li><li>    </li><li class="alt">    _CALL_INT13_V86_(hvm,pClStru)</li><li>    </li><li class="alt">    _asm{<!-- --></li><li>        mov ebx,pClStru</li><li class="alt">        mov ax,[ebx.Client_Flags]</li><li>        _asm mov  retu ,eax</li><li class="alt">    }</li><li></li><li class="alt">    _RESTORE_CLIENT_STATE(saveregs)</li><li>    </li><li class="alt">    _MICRO_V86MMGR_FREE_BUFFER_COPIED(hvm,pClStru,pBuffer,dwBytesCopied);</li><li></li><li class="alt">    <span class="keyword">if</span>(!(retu&amp;1))</li><li>    {<!-- --></li><li class="alt">        <span class="keyword">return</span> 1;</li><li>    }</li><li class="alt"></li><li>Loc_ret_Failed:</li><li class="alt">    <span class="keyword">return</span> 0;</li><li>}</li><li class="alt"></li><li></li><li class="alt"><span class="keyword">int</span> absDiskWriteI13(</li><li>UCHAR nDiskNumber,           <span class="comment">//0~5; </span></li><li class="alt">USHORT nCylinders,</li><li>USHORT nHeads,      <span class="comment">//  </span></li><li class="alt">USHORT nSectors,    <span class="comment">//Where to start. </span></li><li>USHORT wSectors,    <span class="comment">//How many To read </span></li><li class="alt"><span class="keyword">void</span>* pBuffer)      <span class="comment">//  </span></li><li><span class="comment">/*++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></li><li class="alt"><span class="comment">    Routine Description:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">        Write the Disk which specified by nDiskNumber using bios int 13h.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    Arguments:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">        nDiskNumber -- Disk ID,0-5 for   Fixed hardDisk.</span></li><li><span class="comment">        nCylinders --  Starting Position's Cylinders .it should not be greater than 1024.</span></li><li class="alt"><span class="comment">        nHeads     --  Starting Position's heads.</span></li><li><span class="comment">        nSectors   --  Starting Position's Sectors.</span></li><li class="alt"><span class="comment">        wSector    --  How many sector to Write.</span></li><li><span class="comment">        pBuffer    --  Buffer for the content of writing.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    Return Value:</span></li><li class="alt"><span class="comment">        </span></li><li><span class="comment">        if all thing ok return 1,else return 0.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    **********************</span></li><li class="alt"><span class="comment">    </span></li><li><span class="comment">    </span></li><li class="alt"><span class="comment">-------------------------------------------------------*/</span></li><li>{<!-- --></li><li class="alt">    UCHAR DiskIDs[6] = {0x80,0x81,0x82,0x83,0x84,0x85};</li><li>    UCHAR nDisk;</li><li class="alt">    CLIENT_STRUCT saveregs; </li><li>    CLIENT_STRUCT *pClStru;</li><li class="alt">    <span class="keyword">struct</span> cb_s * hvm;</li><li>    WORD  nsegsel,noffset;</li><li class="alt">    DWORD FarPtrBuffer = 0;</li><li>    DWORD dwBytesCopied = 0;</li><li class="alt">    DWORD dwAssumBuffLen = 0;</li><li>    DWORD vmpnum = 0x10;</li><li class="alt">    DWORD retu = 1;</li><li>    <span class="keyword">if</span>(nDiskNumber &gt; 5 || wSectors == 0  )</li><li class="alt">    {<!-- --></li><li>        <span class="keyword">return</span> 0;</li><li class="alt">    }</li><li>    </li><li class="alt">    dwAssumBuffLen = 512 *  wSectors;</li><li>    nDisk =  DiskIDs[nDiskNumber];</li><li class="alt">    hvm = (<span class="keyword">struct</span> cb_s *)Get_Cur_VM_Handle();</li><li>    pClStru = (CLIENT_STRUCT *)hvm-&gt;CB_Client_Pointer;</li><li class="alt">       </li><li>    _MICRO_V86MMGR_ALLOCATE_BUFFER_COPIED(hvm,pClStru,pBuffer,dwAssumBuffLen,</li><li class="alt">        dwBytesCopied,FarPtrBuffer);</li><li>    _asm jc Loc_ret_Failed ;</li><li class="alt"></li><li>    _SAVE_CLIENT_STATE(saveregs);</li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">//Fill Int13 entries.. </span></li><li>    <span class="comment">// </span></li><li class="alt">    nsegsel = HIWORD(FarPtrBuffer);</li><li>    noffset = LOWORD(FarPtrBuffer);</li><li class="alt">    MAKE_INT13CHSD_IN_HS(nCylinders,nHeads,nSectors,nDisk);</li><li>    pClStru-&gt;CWRS.Client_CX = nHeads;</li><li class="alt">    pClStru-&gt;CWRS.Client_DX  = nSectors;</li><li>    pClStru-&gt;CBRS.Client_AH  = 0x03; <span class="comment">//To Write </span></li><li class="alt">    pClStru-&gt;CBRS.Client_AL = (UCHAR)wSectors;<span class="comment">//How many to read. </span></li><li>    pClStru-&gt;CRS.Client_ES  = nsegsel;</li><li class="alt">    pClStru-&gt;CWRS.Client_BX = noffset;</li><li>    </li><li class="alt">    _CALL_INT13_V86_(hvm,pClStru)</li><li>    </li><li class="alt">    _asm{<!-- --></li><li>        mov ebx,pClStru</li><li class="alt">        mov ax,[ebx.Client_Flags]</li><li>        _asm mov  retu ,eax</li><li class="alt">    }</li><li></li><li class="alt">    _RESTORE_CLIENT_STATE(saveregs)</li><li>    </li><li class="alt">    _MICRO_V86MMGR_FREE_BUFFER_NOTCOPIED(hvm,pClStru,dwBytesCopied);</li><li></li><li class="alt">    <span class="keyword">if</span>(!(retu&amp;1))</li><li>    {<!-- --></li><li class="alt">        <span class="keyword">return</span> 1;</li><li>    }</li><li class="alt"></li><li>Loc_ret_Failed:</li><li class="alt">    <span class="keyword">return</span> 0;</li><li>}</li><li class="alt"></li><li></li><li class="alt"><span class="keyword">int</span> IsInt13ExtentHere(</li><li>                      UCHAR nDiskNumber          <span class="comment">//0~5; </span></li><li class="alt">                      )</li><li><span class="comment">/*++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></li><li class="alt"><span class="comment">    Routine Description:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">        Check if the Disk which specified by nDiskNumber support int 13h extent,</span></li><li><span class="comment">        using bios int 13h.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    Arguments:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">        nDiskNumber -- 0~5.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    Return Value:</span></li><li class="alt"><span class="comment">        </span></li><li><span class="comment">        if Int 13h exsist return 1,else return 0.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    **********************</span></li><li class="alt"><span class="comment">    </span></li><li><span class="comment">    </span></li><li class="alt"><span class="comment">-------------------------------------------------------*/</span></li><li>{<!-- --></li><li class="alt">    UCHAR DiskIDs[6] = {0x80,0x81,0x82,0x83,0x84,0x85};</li><li>    UCHAR nDisk;</li><li class="alt">    CLIENT_STRUCT saveregs; </li><li>    CLIENT_STRUCT *pClStru;</li><li class="alt">    <span class="keyword">struct</span> cb_s * hvm;</li><li></li><li class="alt"></li><li>    <span class="keyword">if</span>(nDiskNumber &gt; 5 )</li><li class="alt">    {<!-- --></li><li>        <span class="keyword">return</span> 0;</li><li class="alt">    }</li><li>    nDisk = DiskIDs[nDiskNumber];</li><li class="alt"></li><li>    hvm = (<span class="keyword">struct</span> cb_s *)Get_Cur_VM_Handle();</li><li class="alt">    pClStru = (CLIENT_STRUCT *)hvm-&gt;CB_Client_Pointer;</li><li></li><li class="alt">    _SAVE_CLIENT_STATE(saveregs)    </li><li></li><li class="alt">    pClStru-&gt;CBRS.Client_AH =  0x41;</li><li>    pClStru-&gt;CWRS.Client_BX =  0x55AA;</li><li class="alt">    pClStru-&gt;CBRS.Client_DL = nDisk;</li><li></li><li class="alt">    _CALL_INT13_V86_(hvm,pClStru)</li><li></li><li class="alt">    _asm{<!-- --></li><li>        mov edx,pClStru;</li><li class="alt">        mov ax,[edx.Client_Flags]</li><li>        mov bx,[edx.Client_BX]</li><li class="alt">        mov cx,[edx.Client_CX]</li><li>    }</li><li class="alt"></li><li>    _RESTORE_CLIENT_STATE(saveregs)</li><li class="alt">    </li><li>    _asm</li><li class="alt">    {<!-- --></li><li>        test ax,1</li><li class="alt">        jnz loc_error</li><li>        xor BX,0xAA55</li><li class="alt">        JNZ loc_error</li><li>        test cx,1</li><li class="alt">        jnz loc_i13EHere</li><li>    }</li><li class="alt">loc_error:</li><li>    <span class="keyword">return</span> 0;</li><li class="alt">loc_i13EHere:</li><li>    <span class="keyword">return</span> 1;</li><li class="alt">}</li><li></li><li class="alt"></li><li><span class="keyword">int</span> absDiskReadI13Ex(</li><li class="alt">                      UCHAR nDiskNumber,          <span class="comment">//0~5; </span></li><li>                      DISKADDRESSPACKETI13E *pAddressPacket</li><li class="alt">                      )</li><li><span class="comment">/*++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></li><li class="alt"><span class="comment">    Routine Description:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">        Read the Disk which specified by nDiskNumber using </span></li><li><span class="comment">    bios int 13h extent function 42h.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    Arguments:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">        nDiskNumber -- Disk ID,0-5 for   Fixed hardDisk.</span></li><li class="alt"><span class="comment">        pAddressPacket -- pointer for DISKADDRESSPACKETI13E.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    Return Value:</span></li><li><span class="comment">        </span></li><li class="alt"><span class="comment">        if all thing ok return 1,else return 0.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    **********************</span></li><li><span class="comment">    </span></li><li class="alt"><span class="comment">    </span></li><li><span class="comment">-------------------------------------------------------*/</span></li><li class="alt">{<!-- --></li><li>    </li><li class="alt">    UCHAR DiskIDs[6] = {0x80,0x81,0x82,0x83,0x84,0x85};</li><li>    CLIENT_STRUCT saveregs; </li><li class="alt">    CLIENT_STRUCT *pClStru;</li><li>    <span class="keyword">struct</span> cb_s * hvm;</li><li class="alt">    DWORD PacketFarPtrBuffer = 0;</li><li>    DWORD SizeOfAddrPacket  = 0;</li><li class="alt">    DWORD PacketBuffAllocateNum = 0;</li><li>    DWORD DataFarPtrBuffer = 0;</li><li class="alt">    DWORD DataBuffAllocateNum = 0;</li><li>    DWORD dwAssumBuffLen = 0;</li><li class="alt">    DWORD pDataBuffer = 0;</li><li></li><li class="alt">    <span class="keyword">int</span> retcode = 1;</li><li>    <span class="keyword">if</span>(nDiskNumber &gt; 5 )</li><li class="alt">    {<!-- --></li><li>        <span class="keyword">return</span> 0;</li><li class="alt">    }</li><li>    UCHAR nDisk = DiskIDs[nDiskNumber];</li><li class="alt">    dwAssumBuffLen = 512 * (pAddressPacket-&gt;BlockCount);</li><li>    SizeOfAddrPacket =<span class="keyword">sizeof</span>(DISKADDRESSPACKETI13E);</li><li class="alt">    </li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">//Save the procted mode address. </span></li><li>    <span class="comment">// </span></li><li class="alt">    pDataBuffer = pAddressPacket-&gt;BufferAddr;</li><li></li><li class="alt">    hvm = (<span class="keyword">struct</span> cb_s *)Get_Cur_VM_Handle();</li><li>    pClStru = (CLIENT_STRUCT *)hvm-&gt;CB_Client_Pointer;</li><li class="alt"></li><li>    </li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">//Allocated the FarBuffer which below 1MB for data </span></li><li class="alt">    <span class="comment">// </span></li><li>    _MICRO_V86MMGR_ALLOCATE_BUFFER_NOTCOPIED(hvm,</li><li class="alt">        pClStru,</li><li>        dwAssumBuffLen, <span class="comment">//&lt;--number of bytes to allocate. </span></li><li class="alt">        DataBuffAllocateNum,<span class="comment">//&lt;--Allocate  </span></li><li>        DataFarPtrBuffer);</li><li class="alt">    _asm jc Loc_DataAddr_Failed;</li><li></li><li class="alt">    pAddressPacket-&gt;BufferAddr = DataFarPtrBuffer;</li><li></li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">//Allocated the FarBuffer which below 1MB for addressPacket, </span></li><li>    <span class="comment">//and Copy the data to it. </span></li><li class="alt">    <span class="comment">// </span></li><li>    _MICRO_V86MMGR_ALLOCATE_BUFFER_COPIED(hvm,</li><li class="alt">        pClStru,</li><li>        pAddressPacket,</li><li class="alt">        SizeOfAddrPacket,</li><li>        PacketBuffAllocateNum,</li><li class="alt">        PacketFarPtrBuffer);</li><li>    _asm jc Loc_PackAddr_Failed ;</li><li class="alt"></li><li>    </li><li class="alt">    _SAVE_CLIENT_STATE(saveregs)    </li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">//fill int ext entries. </span></li><li>    <span class="comment">// </span></li><li class="alt">    pClStru-&gt;CBRS.Client_AH = 0x42 ;</li><li>    pClStru-&gt;CBRS.Client_DL = nDisk;</li><li class="alt">    pClStru-&gt;CRS.Client_DS = HIWORD(PacketFarPtrBuffer);</li><li>    pClStru-&gt;CWRS.Client_SI = LOWORD(PacketFarPtrBuffer);</li><li class="alt"></li><li>    _CALL_INT13_V86_(hvm,pClStru)</li><li class="alt">    </li><li>    retcode = pClStru-&gt;CWRS.Client_Flags;</li><li class="alt">    </li><li>    _RESTORE_CLIENT_STATE(saveregs)</li><li class="alt"></li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">//Free  the Packet  FarBuffer; </span></li><li class="alt">    <span class="comment">//The buffers are maintained as a stack.  </span></li><li>    <span class="comment">//Therefore, the last buffer allocated must  </span></li><li class="alt">    <span class="comment">//be the first buffer freed. </span></li><li>    <span class="comment">// </span></li><li class="alt">    _MICRO_V86MMGR_FREE_BUFFER_NOTCOPIED(hvm,pClStru,PacketBuffAllocateNum);</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">//Restore the procted mode address. </span></li><li class="alt">    <span class="comment">// </span></li><li>    pAddressPacket-&gt;BufferAddr = pDataBuffer;</li><li class="alt">    </li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">//Free and copy back the data FarBuffer. </span></li><li>    <span class="comment">// </span></li><li class="alt">    _MICRO_V86MMGR_FREE_BUFFER_COPIED(hvm,pClStru,</li><li>        pDataBuffer,DataBuffAllocateNum);</li><li class="alt"></li><li>    <span class="keyword">return</span> !(retcode &amp;1);</li><li class="alt"></li><li>Loc_DataAddr_Failed:</li><li class="alt">    <span class="keyword">return</span> 0;</li><li></li><li class="alt">Loc_PackAddr_Failed:</li><li>    _MICRO_V86MMGR_FREE_BUFFER_NOTCOPIED(hvm,pClStru,DataFarPtrBuffer);</li><li class="alt">    <span class="keyword">return</span> 0;</li><li>    </li><li class="alt"></li><li>}</li><li class="alt"></li><li><span class="keyword">int</span> absDiskWriteI13Ex( </li><li class="alt">                      UCHAR nDiskNumber,          <span class="comment">//0~5; </span></li><li>                      DISKADDRESSPACKETI13E *pAddressPacket</li><li class="alt">                      )</li><li><span class="comment">/*++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></li><li class="alt"><span class="comment">    Routine Description:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">        Write the Disk which specified by nDiskNumber using </span></li><li><span class="comment">    bios int 13h extent function 43h.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    Arguments:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">        nDiskNumber -- Disk ID,0-5 for   Fixed hardDisk.</span></li><li class="alt"><span class="comment">        pAddressPacket -- pointer for DISKADDRESSPACKETI13E.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    Return Value:</span></li><li><span class="comment">        </span></li><li class="alt"><span class="comment">        if all thing ok return 1,else return 0.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    **********************</span></li><li><span class="comment">    </span></li><li class="alt"><span class="comment">    </span></li><li><span class="comment">-------------------------------------------------------*/</span></li><li class="alt">{<!-- --></li><li></li><li class="alt"></li><li>    UCHAR DiskIDs[6] = {0x80,0x81,0x82,0x83,0x84,0x85};</li><li class="alt">    CLIENT_STRUCT saveregs; </li><li>    CLIENT_STRUCT *pClStru;</li><li class="alt">    <span class="keyword">struct</span> cb_s * hvm;</li><li>    DWORD PacketFarPtrBuffer = 0;</li><li class="alt">    DWORD SizeOfAddrPacket  = 0;</li><li>    DWORD PacketBuffAllocateNum = 0;</li><li class="alt">    DWORD DataFarPtrBuffer = 0;</li><li>    DWORD DataBuffAllocateNum = 0;</li><li class="alt">    DWORD dwAssumBuffLen = 0;</li><li>    DWORD pDataBuffer = 0;</li><li class="alt"></li><li>    <span class="keyword">int</span> retcode = 1;</li><li class="alt">    <span class="keyword">if</span>(nDiskNumber &gt; 5 )</li><li>    {<!-- --></li><li class="alt">        <span class="keyword">return</span> 0;</li><li>    }</li><li class="alt">    UCHAR nDisk = DiskIDs[nDiskNumber];</li><li>    dwAssumBuffLen = 512 * (pAddressPacket-&gt;BlockCount);</li><li class="alt">    SizeOfAddrPacket =<span class="keyword">sizeof</span>(DISKADDRESSPACKETI13E);</li><li>    </li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">//Save the procted mode address. </span></li><li class="alt">    <span class="comment">// </span></li><li>    pDataBuffer = pAddressPacket-&gt;BufferAddr;</li><li class="alt"></li><li>    hvm = (<span class="keyword">struct</span> cb_s *)Get_Cur_VM_Handle();</li><li class="alt">    pClStru = (CLIENT_STRUCT *)hvm-&gt;CB_Client_Pointer;</li><li></li><li class="alt">    </li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">//Allocated the FarBuffer which below 1MB for data </span></li><li>    <span class="comment">// </span></li><li class="alt">    _MICRO_V86MMGR_ALLOCATE_BUFFER_COPIED(hvm,</li><li>        pClStru,</li><li class="alt">        pDataBuffer,</li><li>        dwAssumBuffLen, <span class="comment">//&lt;--number of bytes to allocate. </span></li><li class="alt">        DataBuffAllocateNum,<span class="comment">//&lt;--Allocate  </span></li><li>        DataFarPtrBuffer);</li><li class="alt">    _asm jc Loc_DataAddr_Failed;</li><li></li><li class="alt">    pAddressPacket-&gt;BufferAddr = DataFarPtrBuffer;</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">//Allocated the FarBuffer for addressPacket, </span></li><li class="alt">    <span class="comment">//and Copy the data to it. </span></li><li>    <span class="comment">// </span></li><li class="alt">    _MICRO_V86MMGR_ALLOCATE_BUFFER_COPIED(hvm,</li><li>        pClStru,</li><li class="alt">        pAddressPacket,</li><li>        SizeOfAddrPacket,</li><li class="alt">        PacketBuffAllocateNum,</li><li>        PacketFarPtrBuffer);</li><li class="alt">    _asm jc Loc_PackAddr_Failed ;</li><li></li><li class="alt">    </li><li>    _SAVE_CLIENT_STATE(saveregs)    </li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">//fill int ext entries. </span></li><li class="alt">    <span class="comment">// </span></li><li>    pClStru-&gt;CBRS.Client_AH = 0x43; <span class="comment">//Extent Write. </span></li><li class="alt">    pClStru-&gt;CBRS.Client_AL = 0 ;   <span class="comment">//don't verify write. </span></li><li>    pClStru-&gt;CBRS.Client_DL = nDisk;</li><li class="alt">    pClStru-&gt;CRS.Client_DS = HIWORD(PacketFarPtrBuffer);</li><li>    pClStru-&gt;CWRS.Client_SI = LOWORD(PacketFarPtrBuffer);</li><li class="alt"></li><li>    _CALL_INT13_V86_(hvm,pClStru)</li><li class="alt">    </li><li>    retcode = pClStru-&gt;CWRS.Client_Flags;</li><li class="alt">    </li><li>    _RESTORE_CLIENT_STATE(saveregs)</li><li class="alt"></li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">//Free  the Packet  FarBuffer; </span></li><li class="alt">    <span class="comment">//The buffers are maintained as a stack.  </span></li><li>    <span class="comment">//Therefore, the last buffer allocated must  </span></li><li class="alt">    <span class="comment">//be the first buffer freed. </span></li><li>    <span class="comment">// </span></li><li class="alt">    _MICRO_V86MMGR_FREE_BUFFER_NOTCOPIED(hvm,pClStru,PacketBuffAllocateNum);</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">//Restore the procted mode address. </span></li><li class="alt">    <span class="comment">// </span></li><li>    pAddressPacket-&gt;BufferAddr = pDataBuffer;</li><li class="alt">    </li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">//Free and copy back the data FarBuffer. </span></li><li>    <span class="comment">// </span></li><li class="alt">    _MICRO_V86MMGR_FREE_BUFFER_NOTCOPIED(hvm,pClStru,DataBuffAllocateNum);</li><li></li><li class="alt">    <span class="keyword">return</span> !(retcode &amp;1);</li><li></li><li class="alt">Loc_DataAddr_Failed:</li><li>    <span class="keyword">return</span> 0;</li><li class="alt"></li><li>Loc_PackAddr_Failed:</li><li class="alt">    _MICRO_V86MMGR_FREE_BUFFER_NOTCOPIED(hvm,pClStru,DataFarPtrBuffer);</li><li>    <span class="keyword">return</span> 0;</li><li class="alt">    </li><li>}</li><li class="alt"></li><li></li></ol></div></span></font></span>
<p style="TEXT-INDENT: 21pt"><span style="COLOR: #333333; FONT-SIZE: 9pt"><font face="宋体"><span lang="EN-US"></span></font></span> </p>
<p style="TEXT-INDENT: 21pt"><span style="COLOR: #333333; FONT-SIZE: 9pt"><font face="宋体"><span lang="EN-US"></span></font></span> </p><font face="宋体">
<div class="highlighter">
<ol class="highlighter-c"><li><span class="comment">//直接端口读写的方式来访问硬盘扇区 </span></li><li class="alt"><span class="comment">// </span></li><li><span class="comment">//       Commented codes Below that were use to Read write the harddisk with direct i/o, </span></li><li class="alt"><span class="comment">//Because It highly depend the hardware with the high risk of failure. </span></li><li><span class="comment">// </span></li><li class="alt">UCHAR inportb(USHORT ports)</li><li>{<!-- --></li><li class="alt">   <span class="keyword">return</span> READ_PORT_UCHAR((PUCHAR)ports);</li><li>}</li><li class="alt"></li><li>VOID outportb(USHORT ports,UCHAR cchar)</li><li class="alt">{<!-- --></li><li>    WRITE_PORT_UCHAR((PUCHAR)ports,cchar);</li><li class="alt">} <span class="preprocessor"></span></li><li><span class="preprocessor"></span></li><li class="alt"><span class="preprocessor"></span></li><li><span class="preprocessor">#define  WAIT_WHILE_BUSY / </span></li><li class="alt">    <span class="keyword">for</span>(i=0;i&lt;WAITING_TIMES;i++) {/</li><li>        rt = inportb((USHORT)(BasePort+7));/</li><li class="alt">        <span class="keyword">if</span>((rt&amp;cDriveBusy)==0)/</li><li>            <span class="keyword">break</span>; /</li><li class="alt">    }  /</li><li>    <span class="keyword">if</span>(i&gt;=WAITING_TIMES) <span class="keyword">return</span> FALSE/ <span class="preprocessor"></span></li><li class="alt"><span class="preprocessor"></span></li><li><span class="preprocessor">#define  WAIT_WHILE_BUSY_NOTREADY / </span></li><li class="alt">    <span class="keyword">for</span>(i=0;i&lt;WAITING_TIMES;i++) {/</li><li>        rt = inportb((USHORT)(BasePort+7));/</li><li class="alt">        <span class="keyword">if</span>(rt &amp; cDriveERR) <span class="keyword">return</span> FALSE;/</li><li>        <span class="keyword">if</span>((rt&amp;cDriveBusy)==0 &amp;&amp; (rt&amp;cDriveReady)) <span class="keyword">break</span>; /</li><li class="alt">    }  /</li><li>    <span class="keyword">if</span>(i&gt;=WAITING_TIMES) <span class="keyword">return</span> FALSE/</li><li class="alt"></li><li></li><li class="alt"></li><li>ULONG  IOReadHardDisk(PUSHORT <span class="keyword">params</span>,USHORT idePorts,PLBASECTORSTRU  psecNum)</li><li class="alt">{<!-- --></li><li>    </li><li class="alt">    <span class="keyword">int</span> i;</li><li>    USHORT BasePort = idePorts;</li><li class="alt">    UCHAR SectorCount = 1;</li><li>    UCHAR SectorNum   = psecNum-&gt;LBA0_7;</li><li class="alt">    UCHAR cylinderLow = psecNum-&gt;LBA8_15;</li><li>    UCHAR cylinderHi  = psecNum-&gt;LBA16_23;</li><li class="alt">    UCHAR hd_devSel = psecNum-&gt;LBA24_27;</li><li>    </li><li class="alt">    UCHAR rt = inportb((USHORT)(BasePort+7));</li><li>    <span class="keyword">if</span>(rt == 0xff || rt == 0x7f)</li><li class="alt">    {<!-- --></li><li>        <span class="keyword">return</span> FALSE;   <span class="comment">//when the ide port not exsist; </span></li><li class="alt">    }</li><li></li><li class="alt">    WAIT_WHILE_BUSY;</li><li>    outportb((USHORT)(BasePort+6), hd_devSel); <span class="comment">//master or slave hard disk </span></li><li class="alt">    WAIT_WHILE_BUSY;</li><li>    <span class="keyword">if</span>(rt&amp;cDriveERR)</li><li class="alt">    {<!-- --></li><li>        <span class="keyword">return</span> FALSE;</li><li class="alt">    }</li><li>    outportb((USHORT)(BasePort+6), hd_devSel); <span class="comment">//master or slave hard disk </span></li><li class="alt">    WAIT_WHILE_BUSY;</li><li>    </li><li class="alt">    <span class="keyword">if</span>(inportb((USHORT)(BasePort+7))!=0x50)</li><li>        <span class="keyword">return</span> FALSE;<span class="comment">//HDD ready: 0101 0000 </span></li><li class="alt">    </li><li>    outportb((USHORT)(BasePort+6), hd_devSel);          <span class="comment">//master or slave hard disk </span></li><li class="alt">    outportb((USHORT)(BasePort+2), SectorCount);            <span class="comment">//读一个扇区   </span></li><li>    outportb((USHORT)(BasePort+3), SectorNum);          <span class="comment">//扇区号为1 </span></li><li class="alt">    outportb((USHORT)(BasePort+4), cylinderLow);            <span class="comment">//要读写的柱面的低8位 </span></li><li>    outportb((USHORT)(BasePort+5), cylinderHi);         <span class="comment">//用来存放读写柱面的高2位字节(其高6位恒为0) </span></li><li class="alt">    outportb((USHORT)(BasePort+7), 0x20);                   <span class="comment">//读硬盘 </span></li><li>        </li><li class="alt">    <span class="keyword">for</span>(i=0;i&lt;WAITING_TIMES;i++) <span class="comment">//Get HDD Status, wait until HDD not busy </span></li><li>    {<!-- --></li><li class="alt">        <span class="keyword">if</span>(inportb((USHORT)(BasePort+7))==0x58) <span class="comment">//retrieved OK </span></li><li>            <span class="keyword">break</span>;</li><li class="alt">    }</li><li>    <span class="keyword">if</span>(i&gt;=WAITING_TIMES)</li><li class="alt">        <span class="keyword">return</span> FALSE;</li><li></li><li class="alt">    _asm cli;</li><li>    READ_PORT_BUFFER_USHORT((PUSHORT)BasePort,(PUSHORT)<span class="keyword">params</span>,256);</li><li class="alt">    _asm sti;</li><li>    <span class="keyword">return</span> TRUE;</li><li class="alt">}</li><li></li><li class="alt">ULONG IOWriteHardDisk(PUSHORT <span class="keyword">params</span>,USHORT idePorts,PLBASECTORSTRU  psecNum)</li><li>{<!-- --></li><li class="alt">    <span class="keyword">int</span> i;</li><li>    USHORT BasePort = idePorts;</li><li class="alt">    UCHAR SectorCount = 1;</li><li>    UCHAR SectorNum   = psecNum-&gt;LBA0_7;</li><li class="alt">    UCHAR cylinderLow = psecNum-&gt;LBA8_15;</li><li>    UCHAR cylinderHi  = psecNum-&gt;LBA16_23;</li><li class="alt">    UCHAR hd_devSel = psecNum-&gt;LBA24_27;</li><li>    </li><li class="alt">    UCHAR rt = inportb((USHORT)(BasePort+7));</li><li>    <span class="keyword">if</span>(rt == 0xff || rt == 0x7f)</li><li class="alt">    {<!-- --></li><li>        <span class="keyword">return</span> FALSE;   <span class="comment">//when the ide port not exsist; </span></li><li class="alt">    }</li><li>    WAIT_WHILE_BUSY;</li><li class="alt">    outportb((USHORT)(BasePort+6), hd_devSel); <span class="comment">//master or slave hard disk </span></li><li>    WAIT_WHILE_BUSY_NOTREADY;</li><li class="alt"></li><li>    <span class="keyword">if</span>(inportb((USHORT)(BasePort+7))!=0x50) <span class="keyword">return</span> FALSE;<span class="comment">//HDD ready: 0101 0000 </span></li><li class="alt"></li><li>    outportb((USHORT)(BasePort+6), hd_devSel);          <span class="comment">//master or slave hard disk </span></li><li class="alt">    outportb((USHORT)(BasePort+2), SectorCount);            <span class="comment">//读一个扇区   </span></li><li>    outportb((USHORT)(BasePort+3), SectorNum);          <span class="comment">//扇区号为1 </span></li><li class="alt">    outportb((USHORT)(BasePort+4), cylinderLow);            <span class="comment">//要读写的柱面的低8位 </span></li><li>    outportb((USHORT)(BasePort+5), cylinderHi);         <span class="comment">//用来存放读写柱面的高2位字节(其高6位恒为0) </span></li><li class="alt">    outportb((USHORT)(BasePort+7), 0x30);                   <span class="comment">//写硬盘 </span></li><li>    </li><li class="alt">    <span class="keyword">for</span>(i=0;i&lt;WAITING_TIMES;i++) <span class="comment">//Get HDD Status, wait until HDD not busy </span></li><li>    {<!-- --></li><li class="alt">        <span class="keyword">if</span>(inportb((USHORT)(BasePort+7))==0x58) <span class="comment">//retrieved OK </span></li><li>            <span class="keyword">break</span>;</li><li class="alt">    }</li><li>    <span class="keyword">if</span>(i&gt;=WAITING_TIMES)</li><li class="alt">        <span class="keyword">return</span> FALSE;</li><li></li><li class="alt">    _asm cli;</li><li>    WRITE_PORT_BUFFER_USHORT((PUSHORT)BasePort,(PUSHORT)<span class="keyword">params</span>,256);</li><li class="alt">    _asm sti;</li><li></li><li class="alt">    <span class="keyword">return</span> TRUE;</li><li>}</li><li class="alt"></li></ol></div></font>
</div>
    </div>
    
    <div class="footer">
        <p>版本所有 tdany.com  | 发表时间: 2008-12-31 00:30:00</p>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    <script>
        // 处理代码块，添加语言类和复制功能
        document.addEventListener('DOMContentLoaded', function() {            
            // 为没有指定语言的代码块添加默认语言
            document.querySelectorAll('pre code:not([class*="language-"])').forEach(function(block) {
                block.className = 'hljs language-javascript';
            });
            
            // 确保所有代码块都有hljs类
            document.querySelectorAll('pre code[class*="language-"]:not([class*="hljs"])').forEach(function(block) {
                block.className = 'hljs ' + block.className;
            });
            
            // 为所有代码块添加自定义复制按钮
            document.querySelectorAll('pre').forEach(function(pre) {
                // 创建复制按钮
                var copyButton = document.createElement('button');
                copyButton.className = 'copy-button';
                copyButton.textContent = '复制';
                copyButton.style.position = 'absolute';
                copyButton.style.top = '5px';
                copyButton.style.right = '5px';
                copyButton.style.background = 'rgba(0,0,0,0.3)';
                copyButton.style.color = 'white';
                copyButton.style.border = 'none';
                copyButton.style.borderRadius = '3px';
                copyButton.style.padding = '5px 10px';
                copyButton.style.fontSize = '0.8em';
                copyButton.style.cursor = 'pointer';
                copyButton.style.display = 'none';
                
                // 鼠标悬停时显示按钮
                pre.addEventListener('mouseenter', function() {
                    copyButton.style.display = 'block';
                });
                
                pre.addEventListener('mouseleave', function() {
                    copyButton.style.display = 'none';
                });
                
                // 点击复制按钮时复制代码
                copyButton.addEventListener('click', function() {
                    var code = pre.querySelector('code');
                    var text = code.textContent || code.innerText;
                    
                    // 使用现代的 Clipboard API
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(text)
                            .then(function() {
                                copyButton.textContent = '已复制!';
                                setTimeout(function() {
                                    copyButton.textContent = '复制';
                                }, 2000);
                            })
                            .catch(function(err) {
                                console.error('Clipboard API 复制失败:', err);
                                // 如果 Clipboard API 失败，尝试使用传统方法
                                fallbackCopyToClipboard();
                            });
                    } else {
                        // 对于不支持 Clipboard API 的浏览器，使用传统方法
                        fallbackCopyToClipboard();
                    }
                    
                    // 传统复制方法作为后备
                    function fallbackCopyToClipboard() {
                        // 创建临时文本区域
                        var textArea = document.createElement('textarea');
                        textArea.value = text;
                        textArea.style.position = 'fixed';
                        textArea.style.left = '-9999px';
                        textArea.style.top = '0';
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();
                        
                        try {
                            var successful = document.execCommand('copy');
                            if (successful) {
                                copyButton.textContent = '已复制!';
                                setTimeout(function() {
                                    copyButton.textContent = '复制';
                                }, 2000);
                            } else {
                                copyButton.textContent = '复制失败';
                            }
                        } catch (err) {
                            copyButton.textContent = '复制失败';
                            console.error('传统复制方法失败:', err);
                        }
                        
                        document.body.removeChild(textArea);
                    }
                });
                
                // 添加按钮到代码块
                pre.style.position = 'relative';
                pre.appendChild(copyButton);
            });
            
            // 确保Prism重新高亮所有代码块
            if (typeof Prism !== 'undefined') {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>
