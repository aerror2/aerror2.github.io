
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Windows串口调试通信协议KDCOM.DLL的反向分析及Asm和C源代码</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-okaidia.min.css">

    <style>
        /* 保留CSDN常用的文本颜色类 */
        .text-red, [class*="text-red"] { color: red !important; }
        .text-blue, [class*="text-blue"] { color: blue !important; }
        .text-green, [class*="text-green"] { color: green !important; }
        .text-yellow, [class*="text-yellow"] { color: #FFD700 !important; }
        .text-purple, [class*="text-purple"] { color: purple !important; }
        .text-orange, [class*="text-orange"] { color: orange !important; }
        
        /* 保留常见的CSDN文本样式类 */
        .bold, .strong, [class*="bold"], [class*="strong"] { font-weight: bold !important; }
        .italic, .em, [class*="italic"], [class*="em"] { font-style: italic !important; }
        .underline, [class*="underline"] { text-decoration: underline !important; }
        
        /* 确保内联样式不被覆盖 */
        .article-content * { color: initial; background-color: initial; font-weight: initial; font-style: initial; text-decoration: initial; }
        
        /* 保留font标签的color属性 */
        .article-content font[color="red"] { color: red !important; }
        .article-content font[color="blue"] { color: blue !important; }
        .article-content font[color="green"] { color: green !important; }
        .article-content font[color="yellow"] { color: yellow !important; }
        .article-content font[color="purple"] { color: purple !important; }
        .article-content font[color="orange"] { color: orange !important; }
        .article-content font[color="black"] { color: black !important; }
        .article-content font[color="white"] { color: white !important; }
        .article-content font[color="gray"] { color: gray !important; }
        .article-content font[color="#000000"] { color: #000000 !important; }
        .article-content font[color="#FF0000"] { color: #FF0000 !important; }
        .article-content font[color="#00FF00"] { color: #00FF00 !important; }
        .article-content font[color="#0000FF"] { color: #0000FF !important; }
        .article-content font[color="#FFFF00"] { color: #FFFF00 !important; }
        .article-content font[color="#00FFFF"] { color: #00FFFF !important; }
        .article-content font[color="#FF00FF"] { color: #FF00FF !important; }
    </style>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; padding: 20px; max-width: 1200px; margin: 0 auto; background-color: #f8f9fa; }
        img { max-width: 100%; height: auto; }
        pre { background-color: #2d2d2d; padding: 10px; border-radius: 5px; overflow-x: auto; margin: 1em 0; }
        code { font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; }
        pre[class*="language-"] { position: relative; }
        pre[class*="language-"] .copy-to-clipboard-button { position: absolute; top: 5px; right: 5px; background: rgba(0,0,0,0.3); color: white; border: none; border-radius: 3px; padding: 5px 10px; font-size: 0.8em; cursor: pointer; }
        pre[class*="language-"] .copy-to-clipboard-button:hover { background: rgba(0,0,0,0.5); }
        pre[class*="language-"] code { user-select: all; -webkit-user-select: all; -moz-user-select: all; -ms-user-select: all; }
        pre[class*="language-"]:hover .copy-to-clipboard-button { display: block; }
        pre[class*="language-"] .copy-to-clipboard-button { display: none; }
        .source-link { margin-bottom: 15px; color: #666; }
        h1 { font-size: 28px; margin-bottom: 15px; color: #333; }
        .article-content { margin-top: 25px; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        
        /* 文章元数据样式 */
        .article-meta { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 15px; 
            font-size: 14px; 
            color: #666; 
            margin-bottom: 15px; 
        }
        .meta-item { 
            display: flex; 
            align-items: center; 
        }
        .meta-item i { 
            margin-right: 5px; 
            color: #0066cc; 
        }
        
        /* 标签样式 */
        .article-tags { 
            margin-bottom: 15px; 
        }
        .tag { 
            display: inline-block; 
            background-color: #e6f2ff; 
            color: #0066cc; 
            padding: 3px 8px; 
            border-radius: 4px; 
            font-size: 12px; 
            margin-right: 5px; 
        }
        
        /* 描述样式 */
        .article-description { 
            background-color: #f5f5f5; 
            padding: 15px; 
            border-left: 4px solid #0066cc; 
            margin-bottom: 20px; 
            font-style: italic; 
            color: #555; 
        }
        .token.comment, .token.prolog, .token.doctype, .token.cdata { color: #8292a2; }
        .token.punctuation { color: #f8f8f2; }
        .token.namespace { opacity: .7; }
        .token.property, .token.tag, .token.constant, .token.symbol, .token.deleted { color: #f92672; }
        .token.boolean, .token.number { color: #ae81ff; }
        .token.selector, .token.attr-name, .token.string, .token.char, .token.builtin, .token.inserted { color: #a6e22e; }
        .token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string, .token.variable { color: #f8f8f2; }
        .token.atrule, .token.attr-value, .token.function, .token.class-name { color: #e6db74; }
        .token.keyword { color: #66d9ef; }
        .token.regex, .token.important { color: #fd971f; }
        .token.important, .token.bold { font-weight: bold; }
        .token.italic { font-style: italic; }
        .token.entity { cursor: help; }
        
        /* 添加header和footer样式 */
        .header { 
            padding: 10px 0; 
            margin-bottom: 20px; 
            border-bottom: 1px solid #eee; 
        }
        .header a { 
            text-decoration: none; 
            color: #007bff; 
            font-weight: bold; 
        }
        .header a:hover { 
            text-decoration: underline; 
        }
        .footer { 
            margin-top: 30px; 
            padding-top: 20px; 
            border-top: 1px solid #eee; 
            color: #666; 
            font-size: 0.9em; 
            text-align: center; 
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="index.html">← 返回目录</a>
    </div>
    
    <h1>Windows串口调试通信协议KDCOM.DLL的反向分析及Asm和C源代码</h1>
    <div class="source-link">原文链接: <a href="https://blog.csdn.net/aerror/article/details/2958588" target="_blank">https://blog.csdn.net/aerror/article/details/2958588</a></div>
    
    <div class="article-meta">
        <div class="meta-item"><i class="far fa-calendar-alt"></i> 发布时间: 2008-09-21 21:08:00</div>
        <div class="meta-item"><i class="far fa-eye"></i> 浏览量: 7514</div>
        <div class="meta-item"><i class="far fa-comment"></i> 评论数: 2</div>
        <div class="meta-item"><i class="far fa-star"></i> 收藏数: 1</div>
        
    </div>
    
    <div class="article-tags">标签: <span class="tag">c</span>, <span class="tag">windows</span>, <span class="tag">exception</span>, <span class="tag">file</span>, <span class="tag">byte</span>, <span class="tag">transition</span></div>
    
    <div class="article-description">前段时间突然兴趣大发,把KDCOM.DLL用IDA进行了分析和阅读,并导出成asm文件，作了修改和编译使之可以编译后替换原先的kdcom.dll正常工作, 这之间最难的莫过于kdcom.dll无法进行调试和跟踪的问题了, 手段非常有限, 我暂时只知道使用一下Vmware的后门I/O port进行一些检测性的LOG,以致使由反向代码编译出的kdom.dll最终能正常工作花费了我极多的时间.事实上</div>
    
    <div class="article-content">
        <div class="htmledit_views atom-one-dark" id="content_views">
<p>前段时间突然兴趣大发,把KDCOM.DLL用IDA进行了分析和阅读,并导出成asm文件，作了修改和编译使之可以编译后替换原先的kdcom.dll正常工作, 这之间最难的莫过于kdcom.dll无法进行调试和跟踪的问题了, 手段非常有限, 我暂时只知道使用一下Vmware的后门I/O port进行一些检测性的LOG,以致使由反向代码编译出的kdom.dll最终能正常工作花费了我极多的时间.</p>
<p>事实上, 由IDA导出的代码要修改的问题并不多,只涉及到以下方面:</p>
<p>1.API函数导入和导出的问题,包括命名和正确链接;</p>
<p>2.代码的区段问题和一些全局绝对址的引用问题,如_KUSER_SHARED_DATA的引用,IDA反编出是这样的 <br/>and byte ptr ds:0FFDF02D4h, 0FDh<br/>事实上必须写成 and byte ptr ds:[0FFDF02D4h], 0FDh<br/>否则Masm32编译生成出问题,VMWARE直接就崩溃.</p>
<p>3.导入变量的地址使用问题,这里是搞了我最多时间的地方,因为,发生这种异常VMWARE直接就出错,结束,郁闷呀.<br/> 类似第2点的问题,<br/> 例如,IDA反编出来的，关于使用KdDebuggerNotPresent这个由ntosknrl.exe导出的符时,语句是这样的<br/><br/></p>
<div class="highlighter">
<ol class="highlighter-delphi"><li> mov     eax, ds:_KdDebuggerNotPresent</li><li class="alt"> <span class="keyword">and</span>     <span class="keyword">byte</span> ptr [eax], <span class="number">0</span></li></ol></div>
<p><br/> 把_KdDebuggerNotPresent改成KdDebuggerNotPresent编译和链接都没有问题,都一运行VMWARE就直接崩溃.<br/> 事实上应该写成这样的(这个可是花了我无数的时间才发现的,--#)<em>:</em><br/><br/></p>
<div class="highlighter">
<ol class="highlighter-c"><li> mov     eax, dword ptr ds:[KdDebuggerNotPresent]</li><li class="alt">  and     <span class="keyword">byte</span> ptr [eax], 0</li></ol></div>
<p><br/>下面给出可以编译生成正常运行的反向汇编源代码,有三个文件kdcom.Inc,kdcom.def和kdcom.Asm,需要安装RadASM这个IDE来编译.</p>
<p>kdcom.Inc:<br/></p>
<p> </p>
<div class="highlighter">
<ol class="highlighter-c"><li></li><li class="alt">;kdcom.Inc</li><li>;</li><li class="alt">include w2k/ntstatus.inc</li><li>include w2k/ntddk.inc</li><li class="alt">include w2k/ntoskrnl.inc</li><li>include w2k/hal.inc</li><li class="alt">includelib hal.lib</li><li>includelib ntoskrnl.lib</li></ol></div>
<p> </p>
<p><font color="#000000">kdcom.def</font></p>
<div class="highlighter">
<ol class="highlighter-c"><li>EXPORTS</li><li class="alt"> KdD0Transition          </li><li> KdD3Transition=KdD0Transition </li><li class="alt"> KdDebuggerInitialize0      </li><li> KdDebuggerInitialize1      </li><li class="alt"> KdReceivePacket            </li><li> KdRestore                  </li><li class="alt"> KdSave                     </li><li> KdSendPacket               </li><li class="alt"></li></ol></div>
<p>kdcom.Asm:</p>
<p> </p>
<p> </p>
<p> </p>
<div class="highlighter">
<ol class="highlighter-c"><li>;</li><li class="alt">; BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</li><li>; ?This file <span class="keyword">is</span> generated by The Interactive Disassembler (IDA)     ?</li><li class="alt"></li><li>.686p</li><li class="alt">.model flat,stdcall</li><li></li><li class="alt">include kdcom.inc</li><li></li><li class="alt">;</li><li>;import variable </li><li class="alt">;            extrn KdComPortInUse:dword</li><li>;                extrn KdDebuggerNotPresent:dword</li><li class="alt">;                extrn HalPrivateDispatchTable:dword</li><li></li><li class="alt"></li><li></li><li class="alt">; Section 2. (<span class="keyword">virtual</span> address 00000D00)</li><li>; Virtual size          : 0000009C (    156.)</li><li class="alt">; Section size <span class="keyword">in</span> file      : 00000100 (    256.)</li><li>; Offset to raw data <span class="keyword">for</span> section: 00000D00</li><li class="alt">; Flags C8000040: Data Not pageable Readable Writable</li><li>; Alignment : <span class="keyword">default</span></li><li class="alt">; BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</li><li></li><li class="alt">; Segment type: Pure data</li><li>; Segment permissions: Read/Write</li><li class="alt">_data       segment para <span class="keyword">public</span> <span class="string">'DATA'</span> use32</li><li>        </li><li class="alt">aKdReceivePacket        db <span class="string">'KdReceivePacket'</span>,0Ah,0Dh,0</li><li>aKdSendPacket           db <span class="string">'KdSendPacket'</span>,0</li><li class="alt"></li><li></li><li class="alt">aSwitchingDebug         db <span class="string">'Switching debugger to 9600 baud'</span>,0Ah,0 ; DATA XREF: CpReadLsr(x,x)+194o</li><li></li><li class="alt">aDebugport          db <span class="string">'DEBUGPORT'</span>,0        ; DATA XREF: KdDebuggerInitialize0(x)+18o</li><li></li><li class="alt">aBaudrate           db <span class="string">'BAUDRATE'</span>,0         ; DATA XREF: KdDebuggerInitialize0(x)+25o</li><li></li><li class="alt">aCom                db <span class="string">'COM'</span>,0              ; DATA XREF: KdDebuggerInitialize0(x)+3Bo</li><li></li><li class="alt">_KdCompNumberRetries        dd  5       ; DATA XREF: KdReceivePacket(x,x,x,x,x)+51w</li><li>                        ; KdSendPacket(x,x,x,x)+54w ...</li><li class="alt">_KdCompRetryCount       dd  5           ; DATA XREF: KdReceivePacket(x,x,x,x,x)+4Br</li><li>                        ; KdSendPacket(x,x,x,x)+3Br ...</li><li class="alt">_KdCompDbgPortsPresent      db  1       ; DATA XREF: KdRestore(x)+7w</li><li>                        ; CpReadLsr(x,x)+34w ...</li><li class="alt">aPrtOvlFrm          db  20h         ; DATA XREF: CpReadLsr(x,x)+1ACo</li><li>                db  50h ; P</li><li class="alt">                db  52h ; R</li><li>                db  54h ; T</li><li class="alt">                db  20h</li><li>                db  4Fh ; O</li><li class="alt">                db  56h ; V</li><li>                db  4Ch ; L</li><li class="alt">                db  20h</li><li>                db  46h ; F</li><li class="alt">                db  52h ; R</li><li>                db  4Dh ; M</li><li class="alt">aAt             db 0Ah          ; DATA XREF: CpReadLsr(x,x)+D5o</li><li>                db 0Dh,<span class="string">'AT'</span>,0Ah</li><li class="alt">                db 0Dh,0</li><li></li><li class="alt">_Port               dd    0         ; DATA XREF: KdCompGetByte(x)+6o</li><li>                    ; KdCompPollByte(x)+6o ...</li><li class="alt">_com_status_flag        db    1         ; DATA XREF: KdCompRestore()w</li><li>                    ; KdCompSave()w ...</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li></li><li class="alt">_PortInformation        dd 0            ; DATA XREF: KdCompInitialize(x,x)+88w</li><li>                    ; KdCompInitialize(x,x):loc_GetSavedPortInfow ...</li><li class="alt">_ComBaudratePara        dd 0            ; DATA XREF: KdCompInitialize(x,x)+B5w</li><li>                    ; KdCompInitialize(x,x)+CBw ...</li><li class="alt">                db    1</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt">                db    0</li><li>                db    0</li><li class="alt"></li><li>_KdComAddressID         db 1            ; DATA XREF: KdCompInitialize1()r</li><li class="alt">                                ; KdCompInitialize(x,x)+4Aw ...</li><li>_KdWriteUchar           dd offset CpWritePortUchar ;    DATA XREF: CpSetBaud(x,x)+2Dr</li><li class="alt">                                ; CpSetBaud(x,x)+3Er ...</li><li>                                ; CpWritePortUchar(x,x)</li><li class="alt">_KdReadUchar            dd offset CpReadPortUchar ; DATA XREF: CpSetBaud(x,x)+1Er</li><li>                                ; CpSendModemString(x,x)+A4r ...</li><li class="alt">                                ; CpReadPortUchar(x)</li><li>_KdCompDbgParams        dd 0            ; DATA XREF: KdDebuggerInitialize0(x)+56w</li><li class="alt">                                ; KdDebuggerInitialize0(x)+7Fo</li><li>_ArgKdcomBaudrate       dd 0            ; DATA XREF: KdDebuggerInitialize0(x)+78w</li><li class="alt">_KdCompPacketIdExpected     dd 0        ; DATA XREF: KdDebuggerInitialize0(x)+98w</li><li>                                ; KdReceivePacket(x,x,x,x,x)+13Dr ...</li><li class="alt">_KdCompNextPacketIdToSend   dd 0        ; DATA XREF: KdDebuggerInitialize0(x)+8Ew</li><li>                                ; KdReceivePacket(x,x,x,x,x)+F8r ...</li><li class="alt">byte_MsrLastValue       db 0            ; DATA XREF: CpReadLsr(x,x)+149r</li><li>                                ; CpReadLsr(x,x)+1E0w</li><li class="alt">byte_LsrExpectedError       db 0            ; DATA XREF: CpReadLsr(x,x)+74w</li><li>                                ; CpReadLsr(x,x)+13Er ...</li><li class="alt">dword_80010D7C          dd 0            ; DATA XREF: CpSendModemString(x,x)+1Er</li><li>                    ; CpSendModemString(x,x)+4Bw ...</li><li class="alt">byte_LsrParityError     db 0            ; DATA XREF: CpReadLsr(x,x)+4Cw</li><li>                    ; CpReadLsr(x,x)+1A7o</li><li class="alt">byte_LsrOverrunError        db 0            ; DATA XREF: CpReadLsr(x,x)+58w</li><li>byte_LsrFramingError        db 0            ; DATA XREF: CpReadLsr(x,x)+64w</li><li class="alt">_KdCompDbgErrorCount        db  0       ; DATA XREF: CpReadLsr(x,x)+21w</li><li>                    ; CpReadLsr(x,x)+27r ...</li><li class="alt">byte_MsrRingIndicator       db 0            ; DATA XREF: CpReadLsr(x,x)+BDw</li><li>                    ; CpReadLsr(x,x)+15Ew ...</li><li class="alt">_ComPort            dd 0            ; DATA XREF: KdCompInitialize(x,x)+22Cw</li><li>_HalpGetInfoFromACPI        db  0       ; DATA XREF: KdCompInitialize(x,x)+A1w</li><li class="alt">                    ; KdCompInitialize(x,x)+E9r</li><li>                    </li><li class="alt">_DbgpKdComPhysicalAddress0      dd 0 ; DATA XREF: KdCompInitialize1()+13r</li><li>_DbgpKdComPhysicalAddress4      dd 0 ; DATA XREF: KdCompInitialize1()+13r</li><li class="alt">                    ; KdCompInitialize(x,x)+60w ...</li><li>_HalpDebugPortTable         dd 0        ; DATA XREF: KdCompInitialize(x,x)+2Ew</li><li class="alt">                    ; KdCompInitialize(x,x):loc_80010A63r ...</li><li>_HintsCount         dd  0CAFEBEBEh      </li><li class="alt">_data       ends</li><li></li><li class="alt"></li><li>.CODE _text     </li><li class="alt"></li><li></li><li class="alt">HintOsNotFound  proc near               ; CODE XREF: KdVmCommunicationsBackChannelNotify+1Ap</li><li>                    pushad</li><li class="alt">                mov     eax, 564D5868h</li><li>                mov ebx,_HintsCount</li><li class="alt">                inc ebx</li><li>                mov _HintsCount,ebx</li><li class="alt">                cmp         ebx,0CAFEBEC0h</li><li>                                ja  loc_return</li><li class="alt">                mov     cx, 12h</li><li>                mov     dx, 5658h</li><li class="alt">                <span class="keyword">in</span>      eax, dx         </li><li>loc_return:</li><li class="alt">                popad</li><li>                retn</li><li class="alt">HintOsNotFound  endp</li><li></li><li class="alt"></li><li></li><li class="alt">; BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</li><li></li><li class="alt">; Segment type: Pure code</li><li>; Segment permissions: Read/Execute</li><li class="alt">;_text      segment para <span class="keyword">public</span> <span class="string">'CODE'</span> use32</li><li>;       assume cs:_text</li><li class="alt">        ;org 80010344h</li><li>;       assume es:nothing, ss:nothing, _data, fs:nothing, gs:nothing</li><li class="alt"></li><li>;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</li><li class="alt">; Exported entry   1. KdD0Transition</li><li>; Exported entry   2. KdD3Transition</li><li class="alt">; _stdcall KdD0Transition()</li><li>        <span class="keyword">public</span> KdD0Transition</li><li class="alt">KdD0Transition proc near</li><li>        xor eax, eax    ; KdD0Transition</li><li class="alt">        retn</li><li>KdD0Transition endp</li><li class="alt"></li><li>; CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</li><li class="alt">; Exported entry   3. KdDebuggerInitialize0</li><li>; _stdcall KdDebuggerInitialize0(pctx)</li><li class="alt">        <span class="keyword">public</span> KdDebuggerInitialize0</li><li>KdDebuggerInitialize0 proc near</li><li class="alt"></li><li>var_C       = dword ptr -0Ch</li><li class="alt">arg_0       = dword ptr  8</li><li></li><li class="alt">        push    ebx</li><li>        mov ebx, [esp+arg_0]</li><li class="alt">        test    ebx, ebx</li><li>        jz  <span class="keyword">short</span> loc_reinit</li><li class="alt">        </li><li>        push    esi</li><li class="alt">        mov esi, [ebx+44h]</li><li>        test    esi, esi</li><li class="alt">        jz  <span class="keyword">short</span> loc_80010423</li><li>        push    edi</li><li class="alt">        push    esi     ; <span class="keyword">char</span> *</li><li>        call    _strupr</li><li class="alt">        </li><li>        mov [esp+0Ch+var_C], offset aDebugport ; <span class="string">"DEBUGPORT"</span></li><li class="alt">        push    esi     ; <span class="keyword">char</span> *</li><li>        call     strstr</li><li class="alt">        push    offset aBaudrate ; <span class="string">"BAUDRATE"</span></li><li>        push    esi     ; <span class="keyword">char</span> *</li><li class="alt">        mov edi, eax</li><li>        call     strstr</li><li class="alt">        add esp, 10h</li><li>        test    edi, edi</li><li class="alt">        mov esi, eax</li><li>        jz  <span class="keyword">short</span> loc_80010401</li><li class="alt">        push    offset aCom ; <span class="string">"COM"</span></li><li>        push    edi     ; <span class="keyword">char</span> *</li><li class="alt">        call     strstr</li><li>        test    eax, eax</li><li class="alt">        pop ecx</li><li>        pop ecx</li><li class="alt">        jz  <span class="keyword">short</span> loc_80010401</li><li>        add eax, 3</li><li class="alt">        push    eax</li><li>        call     atol</li><li class="alt">        pop ecx</li><li>        mov _KdCompDbgParams, eax</li><li class="alt"></li><li>loc_80010401:               ; CODE XREF: KdDebuggerInitialize0(x)+39j</li><li class="alt">                    ; KdDebuggerInitialize0(x)+4Aj</li><li>        test    esi, esi</li><li class="alt">        pop edi</li><li>        jz  <span class="keyword">short</span> loc_80010423</li><li class="alt">        add esi, 8</li><li>        jmp <span class="keyword">short</span> loc_8001040C</li><li class="alt">; CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</li><li></li><li class="alt">loc_8001040B:               ; CODE XREF: KdDebuggerInitialize0(x)+69j</li><li>        inc esi</li><li class="alt"></li><li>loc_8001040C:               ; CODE XREF: KdDebuggerInitialize0(x)+63j</li><li class="alt">        cmp <span class="keyword">byte</span> ptr [esi], 20h ; Data Ready?</li><li>        jz  <span class="keyword">short</span> loc_8001040B</li><li class="alt">        cmp <span class="keyword">byte</span> ptr [esi], 0</li><li>        jz  <span class="keyword">short</span> loc_80010423</li><li class="alt">        inc esi</li><li>        push    esi</li><li class="alt">        call     atol</li><li>        pop ecx</li><li class="alt">        mov _ArgKdcomBaudrate,  eax</li><li></li><li class="alt">loc_80010423:               ; CODE XREF: KdDebuggerInitialize0(x)+Fj</li><li>                    ; KdDebuggerInitialize0(x)+5Ej ...</li><li class="alt">        pop esi</li><li></li><li class="alt">loc_reinit:             ; CODE XREF: KdDebuggerInitialize0(x)+7j</li><li>        push    ebx</li><li class="alt">        push    offset _KdCompDbgParams</li><li>        call    KdCompInitialize ; KdCompInitialize(_KdCompDbgParams,pctx)</li><li class="alt">        </li><li>        test    eax, eax</li><li class="alt">        pop ebx</li><li>        jl  <span class="keyword">short</span> locret_80010448</li><li class="alt">        mov _KdCompNextPacketIdToSend, 80800800h</li><li>        mov _KdCompPacketIdExpected, 80800000h</li><li class="alt"></li><li>locret_80010448:            ; CODE XREF: KdDebuggerInitialize0(x)+8Cj</li><li class="alt">        retn    4</li><li>KdDebuggerInitialize0 endp</li><li class="alt"></li><li>;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt">; Exported entry   4. KdDebuggerInitialize1</li><li>;------------------------------------------------------------------------ </li><li class="alt"></li><li>; _stdcall KdDebuggerInitialize1(x)</li><li class="alt">        <span class="keyword">public</span> KdDebuggerInitialize1</li><li>KdDebuggerInitialize1 proc near</li><li class="alt">        call    KdCompInitialize1 ; KdCompInitialize1()</li><li>        xor eax, eax</li><li class="alt">        retn    4</li><li>KdDebuggerInitialize1 endp</li><li class="alt"></li><li>; Exported entry   7. KdSave</li><li class="alt"></li><li>;------------------------------------------------------------------------ </li><li class="alt"></li><li>; _stdcall KdSave(x)</li><li class="alt">        <span class="keyword">public</span> KdSave</li><li>KdSave  proc near</li><li class="alt">        call    KdCompSave  ; KdCompSave()</li><li>        xor eax, eax</li><li class="alt">        retn    4</li><li>KdSave  endp</li><li class="alt"></li><li>; Exported entry   6. KdRestore</li><li class="alt"></li><li>;------------------------------------------------------------------------ </li><li class="alt"></li><li>; _stdcall KdRestore(x)</li><li class="alt">        <span class="keyword">public</span> KdRestore</li><li>KdRestore   proc near</li><li class="alt"></li><li>arg_0       = <span class="keyword">byte</span> ptr  4</li><li class="alt">        cmp [esp+arg_0], 0</li><li>        jz  <span class="keyword">short</span> loc_80010470</li><li class="alt">        and _KdCompDbgPortsPresent, 0</li><li>        jmp <span class="keyword">short</span> loc_80010475</li><li class="alt">; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li></li><li class="alt">loc_80010470:               ; CODE XREF: KdRestore(x)+5j</li><li>        call    KdCompRestore ; KdCompRestore()</li><li class="alt"></li><li>loc_80010475:               ; CODE XREF: KdRestore(x)+Ej</li><li class="alt">        xor eax, eax</li><li>        retn    4</li><li class="alt">KdRestore   endp</li><li></li><li class="alt"></li><li>;------------------------------------------------------------------------ </li><li class="alt">; Attributes: bp-based frame</li><li></li><li class="alt">; _stdcall CpSetBaud(x, x)</li><li>CpSetBaud   proc near       ; CODE XREF: CpReadLsr(x,x)+1A0p</li><li class="alt">                    ; CpGetByte(x,x,x)+3Ap ...</li><li></li><li class="alt">arg_0       = dword ptr  8</li><li>arg_4       = dword ptr  0Ch</li><li class="alt"></li><li>        </li><li class="alt">        push    ebp</li><li>        mov ebp, esp</li><li class="alt">        push    ebx</li><li>        mov ebx, [ebp+arg_4]</li><li class="alt">        xor edx, edx</li><li>        mov eax, 1C200h</li><li class="alt">        div ebx</li><li>        push    esi</li><li class="alt">        push    edi</li><li>        mov edi, [ebp+arg_0]</li><li class="alt">        mov esi, [edi]</li><li>        add esi, 3</li><li class="alt">        push    esi</li><li>        mov [ebp+arg_4], eax</li><li class="alt">        call    _KdReadUchar    ; CpReadPortUchar(x)</li><li>        </li><li class="alt">        or  al, 80h</li><li>        mov <span class="keyword">byte</span> ptr [ebp+arg_0], al</li><li class="alt">        push    [ebp+arg_0]</li><li>        push    esi</li><li class="alt">        call    _KdWriteUchar   ; CpWritePortUchar(x,x)</li><li>        mov eax, [ebp+arg_4]</li><li class="alt">        mov esi, [edi]</li><li>        shr eax, 8</li><li class="alt">        push    eax</li><li>        inc esi</li><li class="alt">        push    esi</li><li>        call    _KdWriteUchar   ; CpWritePortUchar(x,x)</li><li class="alt">        push    [ebp+arg_4]</li><li>        dec esi</li><li class="alt">        push    esi</li><li>        call    _KdWriteUchar   ; CpWritePortUchar(x,x)</li><li class="alt">        mov eax, [edi]</li><li>        push    3</li><li class="alt">        add eax, 3</li><li>        push    eax</li><li class="alt">        call    _KdWriteUchar   ; CpWritePortUchar(x,x)</li><li>        mov [edi+4], ebx</li><li class="alt">        pop edi</li><li>        pop esi</li><li class="alt">        pop ebx</li><li>        pop ebp</li><li class="alt">        retn    8</li><li>CpSetBaud   endp</li><li class="alt"></li><li>; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt">;------------------------------------------------------------------------ </li><li>; Attributes: bp-based frame</li><li class="alt"></li><li>; _stdcall CpSendModemString(x, x)</li><li class="alt">CpSendModemString proc near     ; CODE XREF: CpReadLsr(x,x)+ECp</li><li>                    ; CpReadLsr(x,x)+120p</li><li class="alt"></li><li>var_10      = dword ptr -10h</li><li class="alt">var_6       = word ptr -6</li><li>arg_0       = dword ptr  8</li><li class="alt">arg_4       = dword ptr  0Ch</li><li></li><li class="alt">        push    ebp</li><li>        mov ebp, esp</li><li class="alt">        sub esp, 10h</li><li>        push    esi</li><li class="alt">        mov esi, [ebp+arg_0]</li><li>        mov ax, [esi+8]</li><li class="alt">        test    al, 40h</li><li>        jnz loc_80010597</li><li class="alt">        </li><li>        or  ax, 40h</li><li class="alt">        mov [esi+8], ax</li><li>        mov eax, dword_80010D7C</li><li class="alt">        test    eax, eax</li><li>        push    ebx</li><li class="alt">        push    edi</li><li>        jnz <span class="keyword">short</span> loc_80010548</li><li class="alt">        </li><li>        lea eax, [ebp+var_10]</li><li class="alt">        push    eax</li><li>        call     HalQueryRealTimeClock ; HalQueryRealTimeClock(x)</li><li class="alt">        movsx   edi, [ebp+var_6]</li><li></li><li class="alt">loc_80010518:               ; CODE XREF: CpSendModemString(x,x)+53j</li><li>        push    0</li><li class="alt">        push    esi</li><li>        call    CpReadLsr   ; CpReadLsr(x,x)</li><li class="alt">        lea eax, [ebp+var_10]</li><li>        push    eax</li><li class="alt">        call     HalQueryRealTimeClock ; HalQueryRealTimeClock(x)</li><li>        movsx   eax, [ebp+var_6]</li><li class="alt">        inc dword_80010D7C</li><li>        cmp edi, eax</li><li class="alt">        jz  <span class="keyword">short</span> loc_80010518</li><li>        </li><li class="alt">        mov eax, dword_80010D7C</li><li>        push    3</li><li class="alt">        xor edx, edx</li><li>        pop ecx</li><li class="alt">        div ecx</li><li>        mov dword_80010D7C, eax</li><li class="alt"></li><li>loc_80010548:               ; CODE XREF: CpSendModemString(x,x)+27j</li><li class="alt">        mov edi, [ebp+arg_4]</li><li>        mov ebx, eax</li><li class="alt">        jmp <span class="keyword">short</span> loc_8001058C</li><li>; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt"></li><li>loc_8001054F:               ; CODE XREF: CpSendModemString(x,x)+ADj</li><li class="alt">        lea eax, [ebp+var_10]</li><li>        push    eax</li><li class="alt">        call     HalQueryRealTimeClock ; HalQueryRealTimeClock(x)</li><li>        push    0</li><li class="alt">        push    esi</li><li>        call    CpReadLsr   ; CpReadLsr(x,x)</li><li class="alt">        test    al, 20h</li><li>        mov <span class="keyword">byte</span> ptr [ebp+arg_0+3], al</li><li class="alt">        jz  <span class="keyword">short</span> loc_8001057E</li><li>        dec ebx</li><li class="alt">        jnz <span class="keyword">short</span> loc_8001057E</li><li>        xor eax, eax</li><li class="alt">        mov al, [edi]</li><li>        push    eax</li><li class="alt">        push    dword ptr [esi]</li><li>        call    _KdWriteUchar   ; CpWritePortUchar(x,x)</li><li class="alt">        mov ebx, dword_80010D7C</li><li>        inc edi</li><li class="alt"></li><li>loc_8001057E:               ; CODE XREF: CpSendModemString(x,x)+83j</li><li class="alt">                    ; CpSendModemString(x,x)+86j</li><li>        test    <span class="keyword">byte</span> ptr [ebp+arg_0+3], 1</li><li class="alt">        jz  <span class="keyword">short</span> loc_8001058C</li><li>        push    dword ptr [esi]</li><li class="alt">        call    _KdReadUchar    ; CpReadPortUchar(x)</li><li></li><li class="alt">loc_8001058C:               ; CODE XREF: CpSendModemString(x,x)+6Bj</li><li>                    ; CpSendModemString(x,x)+A0j</li><li class="alt">        cmp <span class="keyword">byte</span> ptr [edi], 0</li><li>        jnz <span class="keyword">short</span> loc_8001054F</li><li class="alt">        and <span class="keyword">byte</span> ptr [esi+8], 0BFh</li><li>        pop edi</li><li class="alt">        pop ebx</li><li></li><li class="alt">loc_80010597:               ; CODE XREF: CpSendModemString(x,x)+10j</li><li>        pop esi</li><li class="alt">        leave</li><li>        retn    8</li><li class="alt">CpSendModemString endp</li><li></li><li class="alt">; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li>;------------------------------------------------------------------------ </li><li class="alt">; Attributes: bp-based frame</li><li></li><li class="alt">; _stdcall CpReadLsr(x, x)</li><li>CpReadLsr   proc near       ; CODE XREF: CpSendModemString(x,x)+39p</li><li class="alt">                    ; CpSendModemString(x,x)+79p ...</li><li></li><li class="alt">var_18      = dword ptr -18h</li><li>var_10      = dword ptr -10h</li><li class="alt">var_8       = word ptr -8</li><li>var_6       = word ptr -6</li><li class="alt">port        = dword ptr  8</li><li>vLsr        = dword ptr  0Bh</li><li class="alt">CheckStatus = <span class="keyword">byte</span> ptr  0Ch</li><li>vMsr        = <span class="keyword">byte</span> ptr  0Fh</li><li class="alt"></li><li>        push    ebp</li><li class="alt">        mov ebp, esp</li><li>        sub esp, 40h</li><li class="alt">        push    esi</li><li>        mov esi, [ebp+port]</li><li class="alt">        mov eax, [esi]</li><li>        add eax, 5</li><li class="alt">        push    eax</li><li>        call    _KdReadUchar    ; CpReadPortUchar(x)</li><li class="alt">        mov cl, al</li><li>        mov al, 0FFh</li><li class="alt">        cmp cl, al</li><li>        mov <span class="keyword">byte</span> ptr [ebp+vLsr],    cl ;Lsr</li><li class="alt">        jnz <span class="keyword">short</span> loc_80010604</li><li>        inc _KdCompDbgErrorCount</li><li class="alt">        cmp _KdCompDbgErrorCount, 19h</li><li>        jb  loc_800107A4</li><li class="alt">        and _KdCompDbgPortsPresent, 0</li><li>        and _KdCompDbgErrorCount, 0</li><li class="alt">        jmp loc_800107A4</li><li>; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt"></li><li>loc_80010604:               ; CODE XREF: CpReadLsr(x,x)+1Fj</li><li class="alt">        test    cl, 4       ; Parity Error?</li><li>        jz  <span class="keyword">short</span> loc_80010610</li><li class="alt">        mov byte_LsrParityError, 8</li><li></li><li class="alt">loc_80010610:               ; CODE XREF: CpReadLsr(x,x)+4Aj</li><li>        test    cl, 2       ; Overrun Error?</li><li class="alt">        jz  <span class="keyword">short</span> loc_8001061C</li><li>        mov byte_LsrOverrunError, 8</li><li class="alt"></li><li>loc_8001061C:               ; CODE XREF: CpReadLsr(x,x)+56j</li><li class="alt">        test    cl, 8       ; Framing Error?</li><li>        jz  <span class="keyword">short</span> loc_80010628</li><li class="alt">        mov byte_LsrFramingError, 8</li><li></li><li class="alt">loc_80010628:               ; CODE XREF: CpReadLsr(x,x)+62j</li><li>        test    [ebp+CheckStatus], cl   ; ?Expectecd</li><li class="alt">        jz  <span class="keyword">short</span> loc_notCheckStatus</li><li>        mov al, cl</li><li class="alt">        or  al, 0FEh</li><li>        mov byte_LsrExpectedError, al</li><li class="alt">        mov al, cl</li><li>        jmp loc_800107A4</li><li class="alt">; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li></li><li class="alt">loc_notCheckStatus:             ; CODE XREF: CpReadLsr(x,x)+6Ej</li><li>        mov eax, [esi]</li><li class="alt">        push    edi</li><li>        add eax, 6</li><li class="alt">        push    eax</li><li>        call    _KdReadUchar    ; CpReadPortUchar(x)</li><li class="alt">        mov [ebp+vMsr], al</li><li>        mov ax, [esi+8]</li><li class="alt">        test    al, 2</li><li>        jz  loc_800106E2</li><li class="alt">        test    [ebp+vMsr], 80h</li><li>        jz  <span class="keyword">short</span> loc_80010669</li><li class="alt">        or  ax, 90h</li><li>        mov [esi+8], ax</li><li class="alt">        jmp <span class="keyword">short</span> loc_800106E2</li><li>; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt"></li><li>loc_80010669:               ; CODE XREF: CpReadLsr(x,x)+A0j</li><li class="alt">        test    al, 10h</li><li>        jz  <span class="keyword">short</span> loc_80010681</li><li class="alt">        lea eax, [esi+0Ah]</li><li>        push    eax</li><li class="alt">        call     HalQueryRealTimeClock ; HalQueryRealTimeClock(x)</li><li>        and <span class="keyword">byte</span> ptr [esi+8], 0EFh</li><li class="alt">        and byte_MsrRingIndicator, 0</li><li></li><li class="alt">loc_80010681:               ; CODE XREF: CpReadLsr(x,x)+AEj</li><li>        lea eax, [ebp+var_10]</li><li class="alt">        push    eax</li><li>        call     HalQueryRealTimeClock ; HalQueryRealTimeClock(x)</li><li class="alt">        mov ax, [ebp+var_8]</li><li>        cmp ax, [esi+12h]</li><li class="alt">        mov edi, offset aAt ; <span class="string">"/n/rAT/n/r"</span></li><li>        jz  <span class="keyword">short</span> loc_800106AE</li><li class="alt">        mov ax, [ebp+var_6]</li><li>        cmp ax, [esi+14h]</li><li class="alt">        jl  <span class="keyword">short</span> loc_800106AE</li><li>        and <span class="keyword">byte</span> ptr [esi+8], 0FDh</li><li class="alt">        push    edi</li><li>        push    esi</li><li class="alt">        call    CpSendModemString ; CpSendModemString(x,x)</li><li></li><li class="alt">loc_800106AE:               ; CODE XREF: CpReadLsr(x,x)+DAj</li><li>                    ; CpReadLsr(x,x)+E4j</li><li class="alt">        mov ax, [esi+8]</li><li>        test    al, al</li><li class="alt">        jns <span class="keyword">short</span> loc_800106E2</li><li>        mov cx, [esi+14h]</li><li class="alt">        cmp [ebp+var_6], cx</li><li>        jge <span class="keyword">short</span> loc_800106C5</li><li class="alt">        add [ebp+var_6], 3Ch</li><li></li><li class="alt">loc_800106C5:               ; CODE XREF: CpReadLsr(x,x)+101j</li><li>        movsx   edx, [ebp+var_6]</li><li class="alt">        movsx   ecx, cx</li><li>        add ecx, 0Ah</li><li class="alt">        cmp edx, ecx</li><li>        jle <span class="keyword">short</span> loc_800106E2</li><li class="alt">        push    edi</li><li>        and ax, 0FF7Fh</li><li class="alt">        push    esi</li><li>        mov [esi+8], ax</li><li class="alt">        call    CpSendModemString ; CpSendModemString(x,x)</li><li></li><li class="alt">loc_800106E2:               ; CODE XREF: CpReadLsr(x,x)+96j</li><li>                    ; CpReadLsr(x,x)+AAj ...</li><li class="alt">        test    <span class="keyword">byte</span> ptr [esi+8], 4</li><li>        jnz <span class="keyword">short</span> loc_800106F0</li><li class="alt">        mov al, <span class="keyword">byte</span> ptr [ebp+vLsr]</li><li>        jmp loc_800107A3</li><li class="alt">; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li></li><li class="alt">loc_800106F0:               ; CODE XREF: CpReadLsr(x,x)+129j</li><li>        mov eax, dword ptr ds:[HalPrivateDispatchTable]</li><li class="alt">        call    dword ptr [eax+3Ch]</li><li>        mov al, <span class="keyword">byte</span> ptr [ebp+vLsr]</li><li class="alt">        cmp al, byte_LsrExpectedError</li><li>        jnz <span class="keyword">short</span> loc_80010712</li><li class="alt">        mov cl, [ebp+vMsr]</li><li>        cmp cl, byte_MsrLastValue</li><li class="alt">        jz  loc_800107A3</li><li></li><li class="alt">loc_80010712:               ; CODE XREF: CpReadLsr(x,x)+144j</li><li>        test    [ebp+vMsr], 40h ; Ring Indicator ?</li><li class="alt">        setz    al</li><li>        inc al</li><li class="alt">        or  byte_MsrRingIndicator, al</li><li>        cmp byte_MsrRingIndicator, 3</li><li class="alt">        jnz <span class="keyword">short</span> loc_80010762</li><li>        and byte_MsrRingIndicator, 0</li><li class="alt">        xor eax, eax</li><li>        mov ax, [esi+8]</li><li class="alt">        and eax, 0FF7Fh</li><li>        or  eax, 12h</li><li class="alt">        test    al, 1</li><li>        mov [esi+8], ax</li><li class="alt">        jz  <span class="keyword">short</span> loc_80010762</li><li>        mov edi, 2580h</li><li class="alt">        cmp [esi+4], edi</li><li>        jz  <span class="keyword">short</span> loc_80010762</li><li class="alt">        push    offset aSwitchingDebug ; <span class="string">"Switching debugger to 9600 baud/n"</span></li><li>        call    ds:InbvDisplayString ; InbvDisplayString(x)</li><li class="alt">        push    edi</li><li>        push    esi</li><li class="alt">        call    CpSetBaud   ; CpSetBaud(x,x)</li><li></li><li class="alt">loc_80010762:               ; CODE XREF: CpReadLsr(x,x)+16Bj</li><li>                    ; CpReadLsr(x,x)+188j ...</li><li class="alt">        push    3</li><li>        mov edx, offset byte_LsrParityError</li><li class="alt">        mov esi, offset aPrtOvlFrm</li><li>        lea ecx, [ebp+var_18]</li><li class="alt">        pop edi</li><li></li><li class="alt">loc_80010772:               ; CODE XREF: CpReadLsr(x,x)+1D3j</li><li>        mov al, [edx]</li><li class="alt">        test    al, al</li><li>        jz  <span class="keyword">short</span> loc_80010782</li><li class="alt">        dec al</li><li>        mov [edx], al</li><li class="alt">        mov eax, [esi]</li><li>        mov [ecx], eax</li><li class="alt">        jmp <span class="keyword">short</span> loc_80010788</li><li>; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt"></li><li>loc_80010782:               ; CODE XREF: CpReadLsr(x,x)+1B9j</li><li class="alt">        mov dword ptr [ecx], 20202020h</li><li></li><li class="alt">loc_80010788:               ; CODE XREF: CpReadLsr(x,x)+1C3j</li><li>        inc edx</li><li class="alt">        add esi, 4</li><li>        sub ecx, 4</li><li class="alt">        dec edi</li><li>        jnz <span class="keyword">short</span> loc_80010772</li><li class="alt">        mov al, <span class="keyword">byte</span> ptr [ebp+vLsr]</li><li>        mov cl, [ebp+vMsr]</li><li class="alt">        mov byte_LsrExpectedError, al</li><li>        mov byte_MsrLastValue, cl</li><li class="alt"></li><li>loc_800107A3:               ; CODE XREF: CpReadLsr(x,x)+12Ej</li><li class="alt">                    ; CpReadLsr(x,x)+14Fj</li><li>        pop edi</li><li class="alt"></li><li>loc_800107A4:               ; CODE XREF: CpReadLsr(x,x)+2Ej</li><li class="alt">                    ; CpReadLsr(x,x)+42j ...</li><li>        pop esi</li><li class="alt">        leave</li><li>        retn    8</li><li class="alt">CpReadLsr   endp</li><li></li><li class="alt">; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li>;------------------------------------------------------------------------ </li><li class="alt">; _stdcall CpPutByte(x, x)</li><li>CpPutByte   proc near       ; CODE XREF: KdCompPutByte(x)+9p</li><li class="alt"></li><li>arg_0       = dword ptr  4</li><li class="alt"></li><li>        cmp _KdCompDbgPortsPresent, 0</li><li class="alt">        jz  <span class="keyword">short</span> locret_8001080D</li><li>        push    esi</li><li class="alt">        mov esi, [esp+4+arg_0]</li><li>        test    <span class="keyword">byte</span> ptr [esi+8], 2</li><li class="alt">        jz  <span class="keyword">short</span> loc_800107F4</li><li>        push    ebx</li><li class="alt"></li><li>loc_800107BF:               ; CODE XREF: CpPutByte(x,x)+47j</li><li class="alt">        mov eax, [esi]</li><li>        add eax, 6</li><li class="alt">        push    eax</li><li>        call    _KdReadUchar    ; CpReadPortUchar(x)</li><li class="alt">        mov bl, al</li><li>        and bl, 0B0h</li><li class="alt">        cmp bl, 0B0h</li><li>        jz  <span class="keyword">short</span> loc_800107F3</li><li class="alt">        push    0</li><li>        push    esi</li><li class="alt">        call    CpReadLsr   ; CpReadLsr(x,x)</li><li>        test    bl, bl</li><li class="alt">        js  <span class="keyword">short</span> loc_800107ED</li><li>        test    al, 1</li><li class="alt">        jz  <span class="keyword">short</span> loc_800107ED</li><li>        push    dword ptr [esi]</li><li class="alt">        call    _KdReadUchar    ; CpReadPortUchar(x)</li><li></li><li class="alt">loc_800107ED:               ; CODE XREF: CpPutByte(x,x)+35j</li><li>                    ; CpPutByte(x,x)+39j</li><li class="alt">        test    <span class="keyword">byte</span> ptr [esi+8], 2</li><li>        jnz <span class="keyword">short</span> loc_800107BF</li><li class="alt"></li><li>loc_800107F3:               ; CODE XREF: CpPutByte(x,x)+29j</li><li class="alt">        pop ebx</li><li></li><li class="alt">loc_800107F4:               ; CODE XREF: CpPutByte(x,x)+12j</li><li>                    ; CpPutByte(x,x)+54j</li><li class="alt">        push    20h</li><li>        push    esi</li><li class="alt">        call    CpReadLsr   ; CpReadLsr(x,x)</li><li>        test    al, 20h</li><li class="alt">        jz  <span class="keyword">short</span> loc_800107F4</li><li>        push    dword ptr [esp+0Ch]</li><li class="alt">        push    dword ptr [esi]</li><li>        call    _KdWriteUchar   ; CpWritePortUchar(x,x)</li><li class="alt">        pop esi</li><li></li><li class="alt">locret_8001080D:            ; CODE XREF: CpPutByte(x,x)+7j</li><li>        retn    8</li><li class="alt">CpPutByte   endp</li><li></li><li class="alt"></li><li>;------------------------------------------------------------------------ </li><li class="alt">; Attributes: bp-based frame</li><li>; _stdcall CpGetByte(x, x, x)</li><li class="alt">CpGetByte   proc near       ; CODE XREF: KdCompGetByte(x)+Bp</li><li>                    ; KdCompPollByte(x)+Bp</li><li class="alt"></li><li>arg_0       = dword ptr  8</li><li class="alt">arg_4       = dword ptr  0Ch</li><li>arg_8       = <span class="keyword">byte</span> ptr  10h</li><li class="alt">arg_B       = <span class="keyword">byte</span> ptr  13h</li><li></li><li class="alt">        push    ebp</li><li>        mov ebp, esp</li><li class="alt">        push    esi</li><li>        mov esi, [ebp+arg_0]</li><li class="alt">        cmp dword ptr [esi], 0</li><li>        jnz <span class="keyword">short</span> loc_portIsOk</li><li class="alt">        </li><li>        mov eax, dword ptr ds:[HalPrivateDispatchTable]</li><li class="alt">        call    dword ptr [eax+3Ch]</li><li>        mov ax, 1</li><li class="alt">        jmp loc_return</li><li>; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt"></li><li>loc_portIsOk:               ; CODE XREF: CpGetByte(x,x,x)+Aj</li><li class="alt">        push    ebx</li><li>        xor ebx, ebx</li><li class="alt">        inc ebx</li><li>        cmp _KdCompDbgPortsPresent, 0</li><li class="alt">        push    edi</li><li>        jnz <span class="keyword">short</span> loc_80010855</li><li class="alt">        </li><li>        push    ebx</li><li class="alt">        push    esi</li><li>        call    CpReadLsr   ; CpReadLsr(x,x)</li><li class="alt">        cmp al, 0FFh</li><li>        jz  <span class="keyword">short</span> loc_800108AE</li><li class="alt">        </li><li>        push    dword ptr [esi+4]</li><li class="alt">        push    esi</li><li>        call    CpSetBaud   ; CpSetBaud(x,x)</li><li class="alt">        mov _KdCompDbgPortsPresent, bl</li><li></li><li class="alt">loc_80010855:               ; CODE XREF: CpGetByte(x,x,x)+29j</li><li>        mov al, [ebp+arg_8]</li><li class="alt">        neg al</li><li>        sbb eax, eax</li><li class="alt">        and eax, 31FFFh</li><li>        inc eax</li><li class="alt">        mov edi, eax</li><li>        jz  <span class="keyword">short</span> loc_8001089F</li><li class="alt"></li><li>loc_80010866:               ; CODE XREF: CpGetByte(x,x,x)+8Dj</li><li class="alt">        push    ebx</li><li>        push    esi</li><li class="alt">        dec edi</li><li>        call    CpReadLsr   ; CpReadLsr(x,x)</li><li class="alt">        cmp al, 0FFh</li><li>        jz  <span class="keyword">short</span> loc_800108AE</li><li class="alt">        test    al, bl</li><li>        jz  <span class="keyword">short</span> loc_8001089B</li><li class="alt">        test    al, 0Eh</li><li>        jnz <span class="keyword">short</span> loc_800108B8</li><li class="alt">        push    dword ptr [esi]</li><li>        call    _KdReadUchar    ; CpReadPortUchar(x)</li><li class="alt">        test    <span class="keyword">byte</span> ptr [esi+8], 2</li><li>        mov [ebp+arg_B], al</li><li class="alt">        jz  <span class="keyword">short</span> loc_800108C4</li><li>        mov eax, [esi]</li><li class="alt">        add eax, 6</li><li>        push    eax</li><li class="alt">        call    _KdReadUchar    ; CpReadPortUchar(x)</li><li>        test    al, al</li><li class="alt">        js  <span class="keyword">short</span> loc_800108C4</li><li></li><li class="alt">loc_8001089B:               ; CODE XREF: CpGetByte(x,x,x)+64j</li><li>        test    edi, edi</li><li class="alt">        jnz <span class="keyword">short</span> loc_80010866</li><li></li><li class="alt">loc_8001089F:               ; CODE XREF: CpGetByte(x,x,x)+54j</li><li>        and byte_LsrExpectedError, 0</li><li class="alt">        push    0</li><li>        push    esi</li><li class="alt">        call    CpReadLsr   ; CpReadLsr(x,x)</li><li></li><li class="alt">loc_800108AE:               ; CODE XREF: CpGetByte(x,x,x)+34j</li><li>                    ; CpGetByte(x,x,x)+60j</li><li class="alt">        mov ax, bx</li><li></li><li class="alt">loc_800108B1:               ; CODE XREF: CpGetByte(x,x,x)+B2j</li><li>                    ; CpGetByte(x,x,x)+BFj</li><li class="alt">        pop edi</li><li>        pop ebx</li><li class="alt"></li><li>loc_return:             ; CODE XREF: CpGetByte(x,x,x)+18j</li><li class="alt">        pop esi</li><li>        pop ebp</li><li class="alt">        retn    0Ch</li><li>; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt"></li><li>loc_800108B8:               ; CODE XREF: CpGetByte(x,x,x)+68j</li><li class="alt">        mov eax, [ebp+arg_4]</li><li>        and <span class="keyword">byte</span> ptr [eax], 0</li><li class="alt">        mov ax, 2</li><li>        jmp <span class="keyword">short</span> loc_800108B1</li><li class="alt">; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li></li><li class="alt">loc_800108C4:               ; CODE XREF: CpGetByte(x,x,x)+79j</li><li>                    ; CpGetByte(x,x,x)+89j</li><li class="alt">        mov eax, [ebp+arg_4]</li><li>        mov cl, [ebp+arg_B]</li><li class="alt">        mov [eax], cl</li><li>        xor ax, ax</li><li class="alt">        jmp <span class="keyword">short</span> loc_800108B1</li><li>CpGetByte   endp</li><li class="alt"></li><li>; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt">        align 2</li><li></li><li class="alt">;------------------------------------------------------------------------ </li><li>; Attributes: bp-based frame</li><li class="alt"></li><li>; _stdcall CpDoesPortExist(x)</li><li class="alt">CpDoesPortExist proc    near        ; CODE XREF: KdCompInitialize(x,x)+19Cp</li><li>                    ; KdCompInitialize(x,x)+1B3p</li><li class="alt"></li><li>arg_0       = dword ptr  8</li><li class="alt">        push    ebp</li><li>        mov ebp, esp</li><li class="alt">        push    ebx</li><li>        push    esi</li><li class="alt">        push    edi</li><li>        mov edi, [ebp+arg_0]</li><li class="alt">        lea esi, [edi+4]</li><li>        push    esi</li><li class="alt">        mov bl, 1</li><li>        call    _KdReadUchar    ; CpReadPortUchar(x)</li><li class="alt">        push    10h</li><li>        push    esi</li><li class="alt">        mov <span class="keyword">byte</span> ptr [ebp+arg_0], al</li><li>        call    _KdWriteUchar   ; CpWritePortUchar(x,x)</li><li class="alt">        push    10h</li><li>        push    esi</li><li class="alt">        call    _KdWriteUchar   ; CpWritePortUchar(x,x)</li><li>        add edi, 6</li><li class="alt">        push    edi</li><li>        call    _KdReadUchar    ; CpReadPortUchar(x)</li><li class="alt">        test    al, 0F0h</li><li>        jnz <span class="keyword">short</span> loc_8001091E</li><li class="alt">        push    14h</li><li>        push    esi</li><li class="alt">        call    _KdWriteUchar   ; CpWritePortUchar(x,x)</li><li>        push    edi</li><li class="alt">        call    _KdReadUchar    ; CpReadPortUchar(x)</li><li>        test    al, 40h</li><li class="alt">        jnz <span class="keyword">short</span> loc_80010920</li><li></li><li class="alt">loc_8001091E:               ; CODE XREF: CpDoesPortExist(x)+36j</li><li>        xor bl, bl</li><li class="alt"></li><li>loc_80010920:               ; CODE XREF: CpDoesPortExist(x)+4Aj</li><li class="alt">        push    [ebp+arg_0]</li><li>        push    esi</li><li class="alt">        call    _KdWriteUchar   ; CpWritePortUchar(x,x)</li><li>        pop edi</li><li class="alt">        pop esi</li><li>        mov al, bl</li><li class="alt">        pop ebx</li><li>        pop ebp</li><li class="alt">        retn    4</li><li>CpDoesPortExist endp</li><li class="alt"></li><li>; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt">        align 4</li><li></li><li class="alt">;------------------------------------------------------------------------ </li><li></li><li class="alt">; _stdcall CpWritePortUchar(x,  x)</li><li>CpWritePortUchar proc near      ; CODE XREF: CpSetBaud(x,x)+2Dp</li><li class="alt">                    ; CpSetBaud(x,x)+3Ep ...</li><li>        jmp  ds:WRITE_PORT_UCHAR ; WRITE_PORT_UCHAR(x,x)</li><li class="alt">CpWritePortUchar endp</li><li></li><li class="alt">; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li>        align 2</li><li class="alt"></li><li>;------------------------------------------------------------------------ </li><li class="alt"></li><li>; _stdcall CpReadPortUchar(x)</li><li class="alt">CpReadPortUchar proc    near        ; CODE XREF: CpSetBaud(x,x)+1Ep</li><li>                    ; CpSendModemString(x,x)+A4p ...</li><li class="alt">        jmp  ds:READ_PORT_UCHAR ; READ_PORT_UCHAR(x)</li><li>CpReadPortUchar endp</li><li class="alt"></li><li>; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt">        align 10h</li><li></li><li class="alt">;------------------------------------------------------------------------ </li><li></li><li class="alt">; _stdcall CpWriteRegisterUchar(x, x)</li><li>CpWriteRegisterUchar    proc near   ; DATA XREF: KdCompInitialize(x,x)+246o</li><li class="alt">        jmp  ds:WRITE_REGISTER_UCHAR ; WRITE_REGISTER_UCHAR(x,x)</li><li>CpWriteRegisterUchar    endp</li><li class="alt"></li><li></li><li class="alt">;------------------------------------------------------------------------ </li><li></li><li class="alt">; _stdcall CpReadRegisterUchar(x)</li><li>CpReadRegisterUchar proc near   ; DATA XREF: KdCompInitialize(x,x)+250o</li><li class="alt">        jmp  ds:READ_REGISTER_UCHAR ; READ_REGISTER_UCHAR(x)</li><li>CpReadRegisterUchar endp</li><li class="alt"></li><li></li><li class="alt">;------------------------------------------------------------------------ </li><li></li><li class="alt">; _stdcall CpInitialize(x, x, x)</li><li>CpInitialize proc near      ; CODE XREF: KdCompInitialize(x,x)+266p</li><li class="alt"></li><li>arg_0       = dword ptr  4</li><li class="alt">arg_4       = dword ptr  8</li><li>arg_8       = dword ptr  0Ch</li><li class="alt">        </li><li>    </li><li class="alt">        </li><li>        mov eax, [esp+arg_4]</li><li class="alt">        push    esi</li><li>        mov esi, [esp+4+arg_0]</li><li class="alt">        push    [esp+4+arg_8]</li><li>        and dword ptr [esi+4], 0</li><li class="alt">        push    esi</li><li>        mov [esi], eax</li><li class="alt">        call    CpSetBaud   ; CpSetBaud(x,x)</li><li>        </li><li class="alt">        mov eax, [esi]</li><li>        push    3</li><li class="alt">        add eax, 4</li><li>        push    eax</li><li class="alt">        call    _KdWriteUchar   ; CpWritePortUchar(x,x)</li><li>        mov eax, [esi]</li><li class="alt">        push    0</li><li>        inc eax</li><li class="alt">        push    eax</li><li>        call    _KdWriteUchar   ; CpWritePortUchar(x,x)</li><li class="alt">        pop esi</li><li>        retn    0Ch</li><li class="alt">CpInitialize endp</li><li></li><li class="alt">; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li>        align 4</li><li class="alt"></li><li>;------------------------------------------------------------------------ </li><li class="alt"></li><li>; _stdcall KdCompGetByte(x)</li><li class="alt">KdCompGetByte proc near  pucdata:PUCHAR     ; CODE XREF: KdCompReceivePacketLeader(x,x,x)+11p</li><li>                    ; KdpReceiveString(x,x)+11p ...</li><li class="alt">        push    1</li><li>        push    pucdata</li><li class="alt">        push    offset _Port</li><li>        call    CpGetByte   ; CpGetByte(x,x,x)</li><li class="alt">        movzx   eax, ax</li><li>        ret</li><li class="alt">KdCompGetByte endp</li><li></li><li class="alt"></li><li>;------------------------------------------------------------------------ </li><li class="alt"></li><li>; _stdcall KdCompPollByte(x)</li><li class="alt">KdCompPollByte proc near  pucdata:PUCHAR        ; CODE XREF: KdReceivePacket(x,x,x,x,x)+10p</li><li>        push    0</li><li class="alt">        push    pucdata</li><li>        push    offset _Port</li><li class="alt">        call    CpGetByte   ; CpGetByte(x,x,x)</li><li>        movzx   eax, ax</li><li class="alt">        ret</li><li>KdCompPollByte endp</li><li class="alt"></li><li></li><li class="alt">;------------------------------------------------------------------------ </li><li></li><li class="alt">; _stdcall KdCompPutByte(x)</li><li>KdCompPutByte proc near ucdata:DWORD        ; CODE XREF: KdpSendString(x,x)+18p</li><li class="alt">                                                    ; KdSendPacket(x,x,x,x)+C9p</li><li>        push    ucdata</li><li class="alt">        push    offset _Port</li><li>        call    CpPutByte   ; CpPutByte(x,x)</li><li class="alt">        ret</li><li>KdCompPutByte endp</li><li class="alt"></li><li>; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt">        align 2</li><li></li><li class="alt">;------------------------------------------------------------------------ </li><li></li><li class="alt">; _stdcall KdCompRestore()</li><li>KdCompRestore proc near     ; CODE XREF: KdRestore(x):loc_80010470p</li><li class="alt">        and _com_status_flag, 0FBh</li><li>        retn</li><li class="alt">KdCompRestore endp</li><li></li><li class="alt"></li><li>;------------------------------------------------------------------------ </li><li class="alt"></li><li>; _stdcall KdCompSave()</li><li class="alt">KdCompSave  proc near       ; CODE XREF: KdSave(x)p</li><li>        or  _com_status_flag, 4</li><li class="alt">        retn</li><li>KdCompSave  endp</li><li class="alt"></li><li></li><li class="alt">;------------------------------------------------------------------------ </li><li></li><li class="alt">; _stdcall KdCompInitialize1()</li><li>KdCompInitialize1 proc near     ; CODE XREF: KdDebuggerInitialize1(x)p</li><li class="alt">        cmp _KdComAddressID, 0</li><li>        jnz <span class="keyword">short</span> locret_800109FE</li><li class="alt">        push    0       ; CacheType</li><li>        push    8       ; NumberOfBytes</li><li class="alt">        push    dword ptr _DbgpKdComPhysicalAddress4</li><li>        push    dword ptr _DbgpKdComPhysicalAddress0 ; PhysicalAddress</li><li class="alt">        call     MmMapIoSpace ; MmMapIoSpace(x,x,x,x)</li><li>        mov ecx, dword ptr ds:[KdComPortInUse]</li><li class="alt">        mov _Port, eax</li><li>        mov [ecx], eax</li><li class="alt"></li><li>locret_800109FE:            ; CODE XREF: KdCompInitialize1()+7j</li><li class="alt">        retn</li><li>KdCompInitialize1 endp</li><li class="alt"></li><li>; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt">        align 10h</li><li></li><li class="alt">;------------------------------------------------------------------------ </li><li></li><li class="alt">; _stdcall KdCompGetDebugTblBaudRate(x)</li><li>KdCompGetDebugTblBaudRate proc near ; CODE XREF: KdCompInitialize(x,x)+C6p</li><li class="alt"></li><li>arg_0       = <span class="keyword">byte</span> ptr  4</li><li class="alt"></li><li>        movzx   ecx, [esp+arg_0]</li><li class="alt">        sub ecx, 3</li><li>        mov eax, 0E100h</li><li class="alt">        jz  <span class="keyword">short</span> loc_80010A25</li><li>        dec ecx</li><li class="alt">        jz  <span class="keyword">short</span> loc_80010A1E</li><li>        sub ecx, 3</li><li class="alt">        jnz <span class="keyword">short</span> locret_80010A2A</li><li>        mov eax, 1C200h</li><li class="alt">        jmp <span class="keyword">short</span> locret_80010A2A</li><li>; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li class="alt"></li><li>loc_80010A1E:               ; CODE XREF: KdCompGetDebugTblBaudRate(x)+10j</li><li class="alt">        mov eax, 4B00h</li><li>        jmp <span class="keyword">short</span> locret_80010A2A</li><li class="alt">; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li></li><li class="alt">loc_80010A25:               ; CODE XREF: KdCompGetDebugTblBaudRate(x)+Dj</li><li>        mov eax, 2580h</li><li class="alt"></li><li>locret_80010A2A:            ; CODE XREF: KdCompGetDebugTblBaudRate(x)+15j</li><li class="alt">                    ; KdCompGetDebugTblBaudRate(x)+1Cj ...</li><li>        retn    4</li><li class="alt">KdCompGetDebugTblBaudRate endp</li><li></li><li class="alt">; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</li><li>        align 2</li><li class="alt"></li><li>;------------------------------------------------------------------------ </li><li class="alt">; Attributes: bp-based frame</li><li></li><li class="alt">; _stdcall KdCompInitialize(_kdParams,  pctx)</li><li>KdCompInitialize proc near      ; CODE XREF: KdDebuggerInitialize0(x)+84p</li><li class="alt"></li><li>var_8       = dword ptr -8</li><li class="alt">var_4       = dword ptr -4</li><li>arg_0       = dword ptr  8</li><li class="alt">arg_4       = dword ptr  0Ch</li><li>    </li><li class="alt">    </li><li>        </li><li class="alt">        push    ebp</li><li>        mov ebp, esp</li><li class="alt">        push    ecx</li><li>        push    ecx</li><li class="alt">        and [ebp+var_4], 0</li><li>        push    ebx</li><li class="alt">        mov ebx, [ebp+arg_4] ;pctx</li><li>        test    ebx, ebx</li><li class="alt">        push    esi</li><li>        push    edi</li><li class="alt">        mov [ebp+var_8], 4B00h</li><li>        </li><li class="alt">        </li><li>        </li><li class="alt">        jz  <span class="keyword">short</span> loc_GetSavedDbgp</li><li>        </li><li class="alt">        </li><li>        mov eax, dword ptr ds:[HalPrivateDispatchTable] </li><li class="alt">        mov eax, [eax+38h] </li><li>        test    eax, eax</li><li class="alt">        jz  <span class="keyword">short</span> loc_GetSavedDbgp</li><li>            </li><li class="alt">        </li><li>        </li><li class="alt">        push    50474244h ;<span class="string">'DBGP'</span></li><li>        push    ebx ;pctx</li><li class="alt">        call    eax  ; 取得 _HalpDebugPortTable </li><li>        </li><li class="alt">        </li><li>        mov _HalpDebugPortTable , eax</li><li class="alt">        jmp <span class="keyword">short</span> loc_DbgPortGot</li><li>; ---------------------------------------------------------------------------------C--</li><li class="alt"></li><li>loc_GetSavedDbgp:               ; CODE XREF: KdCompInitialize(x,x)+18j</li><li class="alt">                    ; KdCompInitialize(x,x)+24j</li><li>        mov eax, _HalpDebugPortTable</li><li class="alt"></li><li>loc_DbgPortGot:             ; CODE XREF: KdCompInitialize(x,x)+33j</li><li class="alt">        </li><li>        </li><li class="alt">        test    eax, eax</li><li>        mov esi, [ebp+arg_0]</li><li class="alt">        </li><li>        jz  loc_checkDbgPortInfo ;无法取得_HalpDebugPortTable,则跳转</li><li class="alt">        </li><li>        mov dl, [eax+28h]</li><li class="alt">        test    dl, dl</li><li>        mov _KdComAddressID, dl</li><li class="alt">        jz  <span class="keyword">short</span> loc_getPhiscalAddr ;如果_KdComAddressID为零,跳</li><li>        cmp dl, 1</li><li class="alt">        jnz loc_checkDbgPortInfo; 如果_KdComAddressID是1,跳转</li><li></li><li class="alt">loc_getPhiscalAddr:             ; CODE XREF: KdCompInitialize(x,x)+50j</li><li>        ;</li><li class="alt">        ;实际调试发现睟B嶂葱械秸饫?</li><li>        ;</li><li class="alt">        test    dl, dl</li><li>        mov ecx, [eax+2Ch]</li><li class="alt">        mov dword ptr _DbgpKdComPhysicalAddress0, ecx</li><li>        mov edi, [eax+30h]</li><li class="alt">        mov dword ptr _DbgpKdComPhysicalAddress4, edi</li><li>        </li><li class="alt">        jnz <span class="keyword">short</span> loc_GetSavedPortInfo</li><li>        </li><li class="alt">        mov ecx, dword ptr ds:[HalPrivateDispatchTable]</li><li>        mov ecx, [ecx+44h]</li><li class="alt">        test    ecx, ecx</li><li>        jz  <span class="keyword">short</span> loc_GotPortInfo</li><li class="alt">        </li><li>        push    1</li><li class="alt">        push    dword ptr [eax+30h] ;B厦嫒〉玫C物理地址</li><li>        push    dword ptr [eax+2Ch] ;</li><li class="alt">        call    ecx         ;B袢PortInformation.</li><li>        mov _PortInformation, eax</li><li class="alt">        mov eax, _HalpDebugPortTable</li><li>        jmp <span class="keyword">short</span> loc_GotPortInfo</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_GetSavedPortInfo:               ; CODE XREF: KdCompInitialize(x,x)+6Fj</li><li>        mov _PortInformation, ecx</li><li class="alt"></li><li>loc_GotPortInfo:                ; CODE XREF: KdCompInitialize(x,x)+7Cj</li><li class="alt">                        ; KdCompInitialize(x,x)+92j</li><li>        and _com_status_flag, 0FCh</li><li class="alt">        mov _HalpGetInfoFromACPI, 1</li><li>        cmp <span class="keyword">byte</span> ptr [eax+24h], 0   </li><li class="alt">        </li><li>        jnz <span class="keyword">short</span> loc_setDefaultBaudrate</li><li class="alt">        </li><li>        mov ecx, [esi+4]</li><li class="alt">        test    ecx, ecx</li><li>        jz  <span class="keyword">short</span> loc_usrNotSetBaudrate</li><li class="alt">        mov _ComBaudratePara,   ecx</li><li>        jmp <span class="keyword">short</span> loc_checkDbgPortInfo</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_usrNotSetBaudrate:              ; CODE XREF: KdCompInitialize(x,x)+B3j</li><li>        movzx   eax, <span class="keyword">byte</span> ptr [eax+3Ah]     ;如果用BB有指定速度,则从刚才取读礐信息中B袢?</li><li class="alt">        test    al, al              </li><li>        </li><li class="alt">        jz  <span class="keyword">short</span> loc_setDefaultBaudrate  ;如果速度礐tableIndex为零,B柚萌≡ざǖC0E100h</li><li>        </li><li class="alt">        push    eax         </li><li>        call    KdCompGetDebugTblBaudRate ; KdCompGetDebugTblBaudRate(x)</li><li class="alt">        mov _ComBaudratePara,   eax</li><li>        </li><li class="alt">        jmp <span class="keyword">short</span> loc_checkDbgPortInfo</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_setDefaultBaudrate:             ; CODE XREF: KdCompInitialize(x,x)+ACj</li><li class="alt">                    ; KdCompInitialize(x,x)+C3j</li><li>        mov _ComBaudratePara,   0E100h</li><li class="alt"></li><li>loc_checkDbgPortInfo:               ; CODE XREF: KdCompInitialize(x,x)+3Fj</li><li class="alt">                    ; KdCompInitialize(x,x)+55j ...</li><li>    </li><li class="alt">        mov eax, _PortInformation</li><li>        test    eax, eax</li><li class="alt">        jnz loc_PortInformationNonZero</li><li>        </li><li class="alt">        cmp _HalpGetInfoFromACPI, al</li><li>        jnz loc_PortInformationNonZero</li><li class="alt">        mov eax, [esi+4]</li><li>        test    eax, eax</li><li class="alt">        jz  <span class="keyword">short</span> loc_passInBaudrateIsZero</li><li>        and _com_status_flag, 0FEh</li><li class="alt">        mov [ebp+var_8], eax</li><li></li><li class="alt">loc_passInBaudrateIsZero:               ; CODE XREF: KdCompInitialize(x,x)+FAj</li><li>        mov eax, [esi]</li><li class="alt">        test    eax, eax</li><li>        jz  <span class="keyword">short</span> loc_portidIsZero</li><li class="alt">        </li><li>        test    ebx, ebx</li><li class="alt">        mov edi, eax</li><li>        lea eax, [edi-1]</li><li class="alt">        mov [ebp+arg_4], eax</li><li>        jz  <span class="keyword">short</span> loc_80010B5E ;如果pCtx为空则跳转</li><li class="alt">        </li><li>        lea eax, [ebp+arg_4]</li><li class="alt">        push    eax</li><li>        push    11h</li><li class="alt">        push    4</li><li>        push    dword ptr [ebx+30h]</li><li class="alt">        call     ds:KeFindConfigurationEntry ;  KeFindConfigurationEntry(x,x,x,x)</li><li>        mov esi, eax</li><li class="alt">        jmp loc_80010BFC</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_80010B5E:               ; CODE XREF: KdCompInitialize(x,x)+116j</li><li class="alt">        xor esi, esi</li><li>        jmp loc_80010BFC</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_portidIsZero:               ; CODE XREF: KdCompInitialize(x,x)+10Aj</li><li>        test    ebx, ebx</li><li class="alt">        mov edi, ds:KeFindConfigurationEntry ; KeFindConfigurationEntry(x,x,x,x)</li><li>        mov [ebp+arg_4], 1</li><li class="alt">        jz  <span class="keyword">short</span> loc_80010B87</li><li>        </li><li class="alt">        lea eax, [ebp+arg_4]</li><li>        push    eax</li><li class="alt">        push    11h</li><li>        push    4</li><li class="alt">        push    dword ptr [ebx+30h]</li><li>        call    edi ; KeFindConfigurationEntry(x,x,x,x) ; KeFindConfigurationEntry(x,x,x,x)</li><li class="alt">        mov esi, eax</li><li>        jmp <span class="keyword">short</span> loc_FoundConfigEntry</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_80010B87:               ; CODE XREF: KdCompInitialize(x,x)+146j</li><li>        xor esi, esi</li><li class="alt"></li><li>loc_FoundConfigEntry:               ; CODE XREF: KdCompInitialize(x,x)+157j</li><li class="alt">        test    esi, esi</li><li>        jz  <span class="keyword">short</span> loc_80010BA0</li><li class="alt">        mov eax, [esi+4]</li><li>        test    eax, eax</li><li class="alt">        jz  <span class="keyword">short</span> loc_80010B9C</li><li>        cmp dword ptr [eax+10h], 1Fh</li><li class="alt">        jnz <span class="keyword">short</span> loc_80010B9C</li><li>        xor esi, esi</li><li class="alt"></li><li>loc_80010B9C:               ; CODE XREF: KdCompInitialize(x,x)+164j</li><li class="alt">                    ; KdCompInitialize(x,x)+16Aj</li><li>        test    esi, esi</li><li class="alt">        jnz <span class="keyword">short</span> loc_80010BF9</li><li></li><li class="alt">loc_80010BA0:               ; CODE XREF: KdCompInitialize(x,x)+15Dj</li><li>        and [ebp+arg_4], 0</li><li class="alt">        test    ebx, ebx</li><li>        jz  <span class="keyword">short</span> loc_80010BB9</li><li class="alt">        lea eax, [ebp+arg_4]</li><li>        push    eax</li><li class="alt">        push    11h</li><li>        push    4</li><li class="alt">        push    dword ptr [ebx+30h]</li><li>        call    edi ; KeFindConfigurationEntry(x,x,x,x) ; KeFindConfigurationEntry(x,x,x,x)</li><li class="alt">        mov esi, eax</li><li>        jmp <span class="keyword">short</span> loc_80010BBB</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_80010BB9:               ; CODE XREF: KdCompInitialize(x,x)+178j</li><li>        xor esi, esi</li><li class="alt"></li><li>loc_80010BBB:               ; CODE XREF: KdCompInitialize(x,x)+189j</li><li class="alt">        test    esi, esi</li><li>        jz  <span class="keyword">short</span> loc_TestPortIdBrute</li><li class="alt"></li><li>loc_port3f8Ok:              ; CODE XREF: KdCompInitialize(x,x)+1BFj</li><li class="alt">        xor edi, edi</li><li>        inc edi</li><li class="alt">        jmp <span class="keyword">short</span> loc_80010BFC</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_TestPortIdBrute:                ; CODE XREF: KdCompInitialize(x,x)+18Fj</li><li class="alt">        mov edi, 2F8h</li><li>        push    edi</li><li class="alt">        call    CpDoesPortExist ; CpDoesPortExist(x)</li><li>        test    al, al</li><li class="alt">        jz  <span class="keyword">short</span> loc_TestPortIdBrute_3f8</li><li>        push    2</li><li class="alt">        mov [ebp+var_4], edi</li><li>        pop edi</li><li class="alt">        jmp <span class="keyword">short</span> loc_SaveComPortId</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_TestPortIdBrute_3f8:                ; CODE XREF: KdCompInitialize(x,x)+1A3j</li><li class="alt">        mov edi, 3F8h       </li><li>        push    edi</li><li class="alt">        call    CpDoesPortExist ; CpDoesPortExist(x)</li><li>        test    al, al</li><li class="alt">        jz  <span class="keyword">short</span> loc_Brutefailed</li><li>        mov [ebp+var_4], edi ;var_4 = tempport</li><li class="alt">        jmp <span class="keyword">short</span> loc_port3f8Ok</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_Brutefailed:                ; CODE XREF: KdCompInitialize(x,x)+1BAj</li><li class="alt">        mov eax, 0C0000225h</li><li>        jmp loc_80010CC7</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_80010BF9:               ; CODE XREF: KdCompInitialize(x,x)+170j</li><li>        push    2</li><li class="alt">        pop edi</li><li></li><li class="alt">loc_80010BFC:               ; CODE XREF: KdCompInitialize(x,x)+12Bj</li><li>                    ; KdCompInitialize(x,x)+132j ...</li><li class="alt">        test    esi, esi</li><li>        jz  <span class="keyword">short</span> loc_getPortIdByIndex</li><li class="alt">        mov esi, [esi+30h]</li><li>        mov ecx, [esi+4]</li><li class="alt">        test    ecx, ecx</li><li>        jbe <span class="keyword">short</span> loc_getPortIdByIndex</li><li class="alt">        lea eax, [esi+8]</li><li></li><li class="alt">loc_80010C0D:               ; CODE XREF: KdCompInitialize(x,x)+1EEj</li><li>        cmp <span class="keyword">byte</span> ptr [eax], 1</li><li class="alt">        jnz <span class="keyword">short</span> loc_80010C18</li><li>        mov edx, [eax+4]</li><li class="alt">        mov [ebp+var_4], edx</li><li></li><li class="alt">loc_80010C18:               ; CODE XREF: KdCompInitialize(x,x)+1E2j</li><li>        add eax, 10h</li><li class="alt">        dec ecx</li><li>        jnz <span class="keyword">short</span> loc_80010C0D</li><li class="alt"></li><li>loc_getPortIdByIndex:               ; CODE XREF: KdCompInitialize(x,x)+1D0j</li><li class="alt">                    ; KdCompInitialize(x,x)+1DAj</li><li>        cmp [ebp+var_4], 0  ;TEMP PORT</li><li class="alt">        jnz <span class="keyword">short</span> loc_SaveComPortId</li><li>        mov eax, edi</li><li class="alt">        dec eax</li><li>        jz  <span class="keyword">short</span> loc_80010C4D</li><li class="alt">        dec eax</li><li>        jz  <span class="keyword">short</span> loc_80010C44</li><li class="alt">        dec eax</li><li>        jz  <span class="keyword">short</span> loc_80010C3B</li><li class="alt">        dec eax</li><li>        jnz <span class="keyword">short</span> loc_SaveComPortId</li><li class="alt">        mov [ebp+var_4], 2E8h</li><li>        jmp <span class="keyword">short</span> loc_SaveComPortId</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_80010C3B:               ; CODE XREF: KdCompInitialize(x,x)+1FFj</li><li>        mov [ebp+var_4], 3E8h</li><li class="alt">        jmp <span class="keyword">short</span> loc_SaveComPortId</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_80010C44:               ; CODE XREF: KdCompInitialize(x,x)+1FCj</li><li class="alt">        mov [ebp+var_4], 2F8h</li><li>        jmp <span class="keyword">short</span> loc_SaveComPortId</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_80010C4D:               ; CODE XREF: KdCompInitialize(x,x)+1F9j</li><li>        mov [ebp+var_4], 3F8h</li><li class="alt"></li><li>loc_SaveComPortId:              ; CODE XREF: KdCompInitialize(x,x)+1ABj</li><li class="alt">                    ; KdCompInitialize(x,x)+1F4j ...</li><li>        mov eax, [ebp+var_4]</li><li class="alt">        mov ecx, [ebp+var_8]</li><li>        mov _ComPort, edi</li><li class="alt">        mov _PortInformation,   eax</li><li>        mov _ComBaudratePara,   ecx</li><li class="alt"></li><li>loc_PortInformationNonZero:             ; CODE XREF: KdCompInitialize(x,x)+E3j</li><li class="alt">                    ; KdCompInitialize(x,x)+EFj</li><li>        cmp _KdComAddressID, 0</li><li class="alt">        jnz <span class="keyword">short</span> loc_comAddrIdNonZero</li><li>        </li><li class="alt">        mov _KdWriteUchar, offset CpWriteRegisterUchar ;    CpWriteRegisterUchar(x,x)</li><li>        mov _KdReadUchar, offset CpReadRegisterUchar ; CpReadRegisterUchar(x)</li><li class="alt"></li><li>loc_comAddrIdNonZero:               ; CODE XREF: KdCompInitialize(x,x)+244j</li><li class="alt">        push    _ComBaudratePara</li><li>        push    eax</li><li class="alt">        push    offset _Port</li><li>        call    CpInitialize ; CpInitialize(x,x,x)</li><li class="alt">        cmp _HalpDebugPortTable, 0</li><li>        jz  <span class="keyword">short</span> loc_80010CB8</li><li class="alt">        cmp _KdComAddressID, 0</li><li>        jnz <span class="keyword">short</span> loc_80010CB8</li><li class="alt">        mov eax, dword ptr ds:[KdComPortInUse]</li><li>        and dword ptr [eax], 0FFFh</li><li class="alt">        jmp <span class="keyword">short</span> loc_80010CC5</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_80010CB8:               ; CODE XREF: KdCompInitialize(x,x)+272j</li><li class="alt">                    ; KdCompInitialize(x,x)+27Bj</li><li>        mov eax, _PortInformation</li><li class="alt">        mov ecx,dword ptr ds:[KdComPortInUse]</li><li>        mov [ecx], eax</li><li class="alt"></li><li>loc_80010CC5:               ; CODE XREF: KdCompInitialize(x,x)+288j</li><li class="alt">        xor eax, eax</li><li></li><li class="alt">loc_80010CC7:               ; CODE XREF: KdCompInitialize(x,x)+1C6j</li><li>        pop edi</li><li class="alt">        pop esi</li><li>        pop ebx</li><li class="alt">        leave</li><li>        retn    8</li><li class="alt">KdCompInitialize endp</li><li></li><li class="alt">                 <span class="keyword">public</span> DllEntryPoint</li><li>DllEntryPoint   proc near</li><li class="alt">             </li><li>                 jmp      HalInitSystem; HalInitSystem(x,x)</li><li class="alt">       </li><li>                 xor eax,eax</li><li class="alt">         retn 8;                 </li><li>DllEntryPoint   endp</li><li class="alt"></li><li></li><li class="alt">        align 10h</li><li>_text       ends</li><li class="alt"></li><li></li><li class="alt"></li><li>; Section 3. (<span class="keyword">virtual</span> address 00000E00)</li><li class="alt">; Virtual size          : 000004DF (   1247.)</li><li>; Section size <span class="keyword">in</span> file      : 00000500 (   1280.)</li><li class="alt">; Offset to raw data <span class="keyword">for</span> section: 00000E00</li><li>; Flags 60000020: Text Executable Readable</li><li class="alt">; Alignment : <span class="keyword">default</span></li><li>; BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</li><li class="alt"></li><li>; Segment type: Pure code</li><li class="alt">; Segment permissions: Read/Execute</li><li>;PAGEKD     segment para <span class="keyword">public</span> <span class="string">'CODE'</span> use32</li><li class="alt">;       assume cs:PAGEKD</li><li>;       ;org 80010E00h</li><li class="alt">;       assume es:nothing, ss:nothing, _data, fs:nothing, gs:nothing</li><li>.code PAGEKD </li><li class="alt"></li><li>;------------------------------------------------------------------------ </li><li class="alt"></li><li>; _stdcall KdpComputeChecksum(x, x)</li><li class="alt">KdpComputeChecksum proc near Buffer:PUCHAR,Len:ULONG</li><li>                    ; CODE XREF: KdReceivePacket(x,x,x,x,x)+1F0p</li><li class="alt">                    ; KdReceivePacket(x,x,x,x,x)+1FEp ...</li><li></li><li class="alt">        mov     edx, Len</li><li>        xor     eax, eax</li><li class="alt">        test    edx, edx</li><li>        jbe     <span class="keyword">short</span> locret_80010E19</li><li class="alt">        mov     ecx, Buffer</li><li>        push    esi</li><li class="alt"></li><li>loc_80010E0F:               ; CODE XREF: KdpComputeChecksum(x,x)+16j</li><li class="alt">        movzx   esi, <span class="keyword">byte</span> ptr [ecx]</li><li>        add     eax, esi</li><li class="alt">        inc     ecx</li><li>        dec     edx</li><li class="alt">        jnz     <span class="keyword">short</span> loc_80010E0F</li><li>        pop     esi</li><li class="alt"></li><li>locret_80010E19:            ; CODE XREF: KdpComputeChecksum(x,x)+8j</li><li class="alt">        ret</li><li>KdpComputeChecksum endp</li><li class="alt"></li><li></li><li class="alt">;------------------------------------------------------------------------ </li><li>; Attributes: bp-based frame</li><li class="alt"></li><li>; _stdcall KdCompReceivePacketLeader(x, x, x)</li><li class="alt">KdCompReceivePacketLeader proc near ; CODE XREF: KdReceivePacket(x,x,x,x,x)+3Ep</li><li>   var_2           = dword ptr -2</li><li class="alt">   arg_4           = dword ptr  0Ch</li><li>   arg_8           = dword ptr  10h</li><li class="alt">                  </li><li>                  push    ebp</li><li class="alt">                mov     ebp, esp</li><li>                push    ecx</li><li class="alt">                push    ebx</li><li>                xor     bl, bl</li><li class="alt">                and     <span class="keyword">byte</span> ptr [ebp+var_2+1], bl</li><li>                push    esi</li><li class="alt"></li><li>loc_80010E27:                           ; CODE XREF: KdCompReceivePacketLeader(x,x,x)+20j</li><li class="alt">                                        ; KdCompReceivePacketLeader(x,x,x)+33j</li><li>                xor     esi, esi</li><li class="alt"></li><li>loc_80010E29:                           ; CODE XREF: KdCompReceivePacketLeader(x,x,x)+3Dj</li><li class="alt">                                        ; KdCompReceivePacketLeader(x,x,x)+4Dj</li><li>                lea     eax, [ebp+var_2]</li><li class="alt">                push    eax</li><li>                call    KdCompGetByte ; KdCompGetByte(x)</li><li class="alt">                xor     ecx, ecx</li><li>                inc     ecx</li><li class="alt">                cmp     eax, ecx</li><li>                jz      <span class="keyword">short</span> loc_80010EA9</li><li class="alt">                cmp     eax, 2</li><li>                jz      <span class="keyword">short</span> loc_80010E27</li><li class="alt">                mov     al, <span class="keyword">byte</span> ptr [ebp+var_2]</li><li>                cmp     al, 30h</li><li class="alt">                jz      <span class="keyword">short</span> loc_80010E51</li><li>                cmp     al, 69h</li><li class="alt">                jz      <span class="keyword">short</span> loc_80010E51</li><li>                cmp     al, 62h</li><li class="alt">                setz    <span class="keyword">byte</span> ptr [ebp+var_2+1]</li><li>                jmp     <span class="keyword">short</span> loc_80010E27</li><li class="alt">;-------------------------------------------------------------------------</li><li>                                                                          </li><li class="alt">loc_80010E51:                           ; CODE XREF: KdCompReceivePacketLeader(x,x,x)+27j</li><li>                                        ; KdCompReceivePacketLeader(x,x,x)+2Bj</li><li class="alt">                test    esi, esi</li><li>                jnz     <span class="keyword">short</span> loc_80010E5B</li><li class="alt">                mov     bl, al</li><li>                mov     esi, ecx</li><li class="alt">                jmp     <span class="keyword">short</span> loc_80010E29</li><li>;-------------------------------------------------------------------------</li><li class="alt">                                                                          </li><li>loc_80010E5B:                           ; CODE XREF: KdCompReceivePacketLeader(x,x,x)+37j</li><li class="alt">                cmp     al, bl</li><li>                jnz     <span class="keyword">short</span> loc_80010E62</li><li class="alt">                inc     esi</li><li>                jmp     <span class="keyword">short</span> loc_80010E66</li><li class="alt">;-------------------------------------------------------------------------</li><li>                                                                          </li><li class="alt">loc_80010E62:                           ; CODE XREF: KdCompReceivePacketLeader(x,x,x)+41j</li><li>                mov     bl, al</li><li class="alt">                mov     esi, ecx</li><li></li><li class="alt">loc_80010E66:                           ; CODE XREF: KdCompReceivePacketLeader(x,x,x)+44j</li><li>                cmp     esi, 4</li><li class="alt">                jb      <span class="keyword">short</span> loc_80010E29</li><li>                cmp     <span class="keyword">byte</span> ptr [ebp+var_2+1], 0</li><li class="alt">                jz      <span class="keyword">short</span> loc_80010E78</li><li>                mov     ecx, [ebp+arg_8]</li><li class="alt">                mov     <span class="keyword">byte</span> ptr [ecx+4], 1</li><li></li><li class="alt">loc_80010E78:                           ; CODE XREF: KdCompReceivePacketLeader(x,x,x)+53j</li><li>                xor     ecx, ecx</li><li class="alt">                cmp     al, 30h</li><li>                mov     eax, [ebp+arg_4]</li><li class="alt">                setnz   cl</li><li>                dec     ecx</li><li class="alt">                and     ecx, 0C6C6C6C7h</li><li>                add     ecx, 69696969h</li><li class="alt">                mov     [eax], ecx</li><li>                mov     eax, dword ptr ds:[KdDebuggerNotPresent]</li><li class="alt">                and     <span class="keyword">byte</span> ptr [eax], 0</li><li>                or      <span class="keyword">byte</span> ptr ds:[0FFDF02D4h], 2</li><li class="alt">                xor     ax, ax</li><li></li><li class="alt">loc_80010EA3:                           ; CODE XREF: KdCompReceivePacketLeader(x,x,x)+9Ej</li><li>                                        ; KdCompReceivePacketLeader(x,x,x)+A3j</li><li class="alt">                pop     esi</li><li>                pop     ebx</li><li class="alt">                pop         ecx</li><li>                leave</li><li class="alt">                retn    0Ch</li><li>;-------------------------------------------------------------------------</li><li class="alt">                                                                          </li><li>loc_80010EA9:                           ; CODE XREF: KdCompReceivePacketLeader(x,x,x)+1Bj</li><li class="alt">                cmp     <span class="keyword">byte</span> ptr [ebp+var_2+1], 0</li><li>                jz      <span class="keyword">short</span> loc_80010EBC</li><li class="alt">                mov     eax, [ebp+arg_8]</li><li>                mov     <span class="keyword">byte</span> ptr [eax+4], 1</li><li class="alt">                mov     ax, 2</li><li>                jmp     <span class="keyword">short</span> loc_80010EA3</li><li class="alt">;-------------------------------------------------------------------------</li><li></li><li class="alt">loc_80010EBC:                           ; CODE XREF: KdCompReceivePacketLeader(x,x,x)+91j</li><li>                mov     ax, cx</li><li class="alt">                jmp     <span class="keyword">short</span> loc_80010EA3</li><li>KdCompReceivePacketLeader endp</li><li class="alt"></li><li>; -----------------------------------------------------------------------------------C</li><li class="alt">        align 2</li><li></li><li class="alt">;------------------------------------------------------------------------ </li><li>; Attributes: bp-based frame</li><li class="alt"></li><li>; _stdcall KdpReceiveString(x,  x)</li><li class="alt">KdpReceiveString proc near      ; CODE XREF: KdReceivePacket(x,x,x,x,x)+67p</li><li>                    ; KdReceivePacket(x,x,x,x,x)+92p ...</li><li class="alt"></li><li>arg_0       = dword ptr  8</li><li class="alt">arg_4       = dword ptr  0Ch</li><li></li><li class="alt">        push    ebp</li><li>        mov ebp, esp</li><li class="alt">        cmp [ebp+arg_4], 0</li><li>        push    esi</li><li class="alt">        jbe <span class="keyword">short</span> loc_80010EE7</li><li>        mov esi, [ebp+arg_0]</li><li class="alt"></li><li>loc_80010ECF:               ; CODE XREF: KdpReceiveString(x,x)+23j</li><li class="alt">        lea eax, [ebp+arg_0+3]</li><li>        push    eax</li><li class="alt">        call     KdCompGetByte ; KdCompGetByte(x)</li><li>        test    eax, eax</li><li class="alt">        jnz <span class="keyword">short</span> loc_80010EE9</li><li>        mov al, <span class="keyword">byte</span> ptr [ebp+arg_0+3]</li><li class="alt">        mov [esi], al</li><li>        inc esi</li><li class="alt">        dec [ebp+arg_4]</li><li>        jnz <span class="keyword">short</span> loc_80010ECF</li><li class="alt"></li><li>loc_80010EE7:               ; CODE XREF: KdpReceiveString(x,x)+8j</li><li class="alt">        xor eax, eax</li><li></li><li class="alt">loc_80010EE9:               ; CODE XREF: KdpReceiveString(x,x)+18j</li><li>        pop esi</li><li class="alt">        pop ebp</li><li>        retn    8</li><li class="alt">KdpReceiveString endp</li><li></li><li class="alt"></li><li>;------------------------------------------------------------------------ </li><li class="alt">; Attributes: bp-based frame</li><li></li><li class="alt">; _stdcall KdpSendString(x, x)</li><li>KdpSendString proc near     ; CODE XREF: KdpSendControlPacket(x,x)+2Ep</li><li class="alt">                    ; KdSendPacket(x,x,x,x)+A0p ...</li><li></li><li class="alt">arg_0       = dword ptr  8</li><li>arg_4       = dword ptr  0Ch</li><li class="alt"></li><li>        push    ebp</li><li class="alt">        mov ebp, esp</li><li>        push    edi</li><li class="alt">        mov edi, [ebp+arg_4]</li><li>        test    edi, edi</li><li class="alt">        jbe <span class="keyword">short</span> loc_80010F0F</li><li>        push    esi</li><li class="alt">        mov esi, [ebp+arg_0]</li><li></li><li class="alt">loc_80010EFD:               ; CODE XREF: KdpSendString(x,x)+1Ej</li><li>        mov al, [esi]</li><li class="alt">        mov <span class="keyword">byte</span> ptr [ebp+arg_4], al</li><li>        push    [ebp+arg_4]</li><li class="alt">        inc esi</li><li>        call     KdCompPutByte ; KdCompPutByte(x)</li><li class="alt">        dec edi</li><li>        jnz <span class="keyword">short</span> loc_80010EFD</li><li class="alt">        pop esi</li><li></li><li class="alt">loc_80010F0F:               ; CODE XREF: KdpSendString(x,x)+9j</li><li>        pop edi</li><li class="alt">        pop ebp</li><li>        retn    8</li><li class="alt">KdpSendString endp</li><li></li><li class="alt"></li><li>;------------------------------------------------------------------------ </li><li class="alt">; Attributes: bp-based frame</li><li></li><li class="alt">; _stdcall KdpSendControlPacket(x, x)</li><li>KdpSendControlPacket    proc near   ; CODE XREF: KdReceivePacket(x,x,x,x,x):loc_sendControlPacketAndWaitAgainp</li><li class="alt">                    ; KdReceivePacket(x,x,x,x,x)+232p ...</li><li></li><li class="alt">var_10      = dword ptr -10h</li><li>var_C       = word ptr -0Ch</li><li class="alt">var_A       = word ptr -0Ah</li><li>var_8       = dword ptr -8</li><li class="alt">var_4       = dword ptr -4</li><li>arg_0       = word ptr  8</li><li class="alt">arg_4       = dword ptr  0Ch</li><li></li><li class="alt">        push    ebp</li><li>        mov ebp, esp</li><li class="alt">        sub esp, 10h</li><li>        mov eax, [ebp+arg_4]</li><li class="alt">        test    eax, eax</li><li>        mov [ebp+var_10], 69696969h</li><li class="alt">        jz  <span class="keyword">short</span> loc_80010F2B</li><li>        mov [ebp+var_8], eax</li><li class="alt"></li><li>loc_80010F2B:               ; CODE XREF: KdpSendControlPacket(x,x)+12j</li><li class="alt">        mov ax, [ebp+arg_0]</li><li>        and [ebp+var_A], 0</li><li class="alt">        and [ebp+var_4], 0</li><li>        mov [ebp+var_C], ax</li><li class="alt">        push    10h</li><li>        lea eax, [ebp+var_10]</li><li class="alt">        push    eax</li><li>        call    KdpSendString ; KdpSendString(x,x)</li><li class="alt">        leave</li><li>        retn    8</li><li class="alt">KdpSendControlPacket    endp</li><li></li><li class="alt">; -----------------------------------------------------------------------------------C</li><li>        align 4</li><li class="alt">; Exported entry   5. KdReceivePacket</li><li></li><li class="alt">;------------------------------------------------------------------------ </li><li>; Attributes: bp-based frame</li><li class="alt"></li><li>; _stdcall KdReceivePacket(x, x, x, x,  x)</li><li class="alt">        <span class="keyword">public</span> KdReceivePacket</li><li>KdReceivePacket proc near       ; CODE XREF: KdSendPacket(x,x,x,x)+D8p</li><li class="alt"></li><li>PacketLeader        = dword ptr -10h</li><li class="alt">vPacketType         = dword ptr -0Ch</li><li>vByteCount          = dword ptr -0Ah</li><li class="alt">vPacketId       = dword ptr -8</li><li>varCheckSum     = dword ptr -4</li><li class="alt">argPacketType       = dword ptr  8</li><li>arg_7       = dword ptr  0Fh</li><li class="alt">arg_C       = dword ptr  14h</li><li>lpKdContext     = dword ptr  18h</li><li class="alt">        </li><li>        push    ebp</li><li class="alt">        mov ebp, esp</li><li>        sub esp, 10h</li><li class="alt">        cmp [ebp+argPacketType], 8  ;PACKET_TYPE_KD_POLL_BREAKIN</li><li>        jnz <span class="keyword">short</span> loc_NormalPacketType</li><li class="alt">        </li><li>        ;</li><li class="alt">        ;PACKET_TYPE_KD_POLL_BREAKIN</li><li>        ;</li><li class="alt">        lea eax, [ebp+arg_7]</li><li>        push    eax</li><li class="alt">        call     KdCompPollByte ; KdCompPollByte(x)</li><li>        test    eax, eax</li><li class="alt">        jnz <span class="keyword">short</span> loc_recvPacketTimeOut</li><li>        cmp <span class="keyword">byte</span> ptr [ebp+arg_7], 62h</li><li class="alt">        jz  loc_return</li><li></li><li class="alt">loc_recvPacketTimeOut:              ; CODE XREF: KdReceivePacket(x,x,x,x,x)+17j</li><li>        xor eax, eax</li><li class="alt">        inc eax             ;KDP_PACKET_TIMEOUT</li><li>        jmp loc_return</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_NormalPacketType:               ; CODE XREF: KdReceivePacket(x,x,x,x,x)+Aj</li><li>        push    ebx</li><li class="alt">        mov ebx, [ebp+arg_C]</li><li>        push    esi</li><li class="alt">        push    edi</li><li>        mov edi, [ebp+0Ch]</li><li class="alt"></li><li>loc_WaitForPacketLeader:                ; CODE XREF: KdReceivePacket(x,x,x,x,x)+DEj</li><li class="alt">                    ; KdReceivePacket(x,x,x,x,x)+105j ...</li><li>        push    [ebp+lpKdContext]</li><li class="alt">        lea eax, [ebp+PacketLeader]</li><li>        push    eax</li><li class="alt">        push    [ebp+argPacketType]</li><li>        </li><li class="alt">        call    KdCompReceivePacketLeader ; KdCompReceivePacketLeader(x,x,x)</li><li></li><li class="alt">        </li><li>        movzx   eax, ax</li><li class="alt">        cmp eax, 1</li><li>        jz  <span class="keyword">short</span> loc_RecvTimeout</li><li class="alt">        </li><li>        mov ecx, _KdCompRetryCount</li><li class="alt">        mov _KdCompNumberRetries, ecx</li><li></li><li class="alt">loc_RecvTimeout:                ; CODE XREF: KdReceivePacket(x,x,x,x,x)+49j</li><li>        test    eax, eax</li><li class="alt">        jnz     loc_return0</li><li>        </li><li class="alt">        ;</li><li>        ;Read packet type.</li><li class="alt">        ;</li><li>        </li><li class="alt">        push    2</li><li>        pop     esi</li><li class="alt">        push    esi</li><li>        lea     eax, [ebp+vPacketType]</li><li class="alt">        push    eax</li><li>        call    KdpReceiveString ; KdpReceiveString(x,x)</li><li class="alt">        cmp     eax, 1      ;CP_GET_NODATA</li><li>        jz      loc_GetNoData</li><li class="alt">        </li><li>        cmp eax, esi    ;CP_GET_ERROR</li><li class="alt">        jz  <span class="keyword">short</span> loc_GetStrError</li><li>        </li><li class="alt">        cmp [ebp+PacketLeader], 69696969h ;CONTROL_PACKET_LEADER</li><li>        jnz <span class="keyword">short</span> loc_NotControlPacketLeader</li><li class="alt">        </li><li>        cmp word ptr [ebp+vPacketType], 5</li><li class="alt">        jz  loc_returnReSend</li><li></li><li class="alt">loc_NotControlPacketLeader:             ; CODE XREF: KdReceivePacket(x,x,x,x,x)+80j</li><li>        ;</li><li class="alt">        ; Read data length.</li><li>        ;</li><li class="alt">        push    esi</li><li>        lea eax, [ebp+vByteCount]</li><li class="alt">        push    eax</li><li>        call    KdpReceiveString ; KdpReceiveString(x,x)</li><li class="alt">        cmp eax, 1</li><li>        jz  loc_GetNoData</li><li class="alt">        cmp eax, esi</li><li>        jz  <span class="keyword">short</span> loc_GetStrError</li><li class="alt">        </li><li>        ;</li><li class="alt">        ;Read Packet Id.</li><li>        ;</li><li class="alt">        push    4</li><li>        pop esi</li><li class="alt">        push    esi</li><li>        lea eax, [ebp+vPacketId]</li><li class="alt">        push    eax</li><li>        call    KdpReceiveString ; KdpReceiveString(x,x)</li><li class="alt">        cmp eax, 1</li><li>        jz  loc_GetNoData</li><li class="alt">        cmp eax, 2</li><li>        jz  <span class="keyword">short</span> loc_GetStrError</li><li class="alt">        </li><li>        ;</li><li class="alt">        ; Read packet checksum.</li><li>        ;</li><li class="alt">        push    esi</li><li>        lea eax, [ebp+varCheckSum]</li><li class="alt">        push    eax</li><li>        call    KdpReceiveString ; KdpReceiveString(x,x)</li><li class="alt">        cmp eax, 1</li><li>        jz  loc_GetNoData</li><li class="alt">        </li><li>        cmp eax, 2</li><li class="alt">        jnz <span class="keyword">short</span> loc_cpGetDataOk</li><li></li><li class="alt">loc_GetStrError:                ; CODE XREF: KdReceivePacket(x,x,x,x,x)+77j</li><li>                    ; KdReceivePacket(x,x,x,x,x)+A2j ...</li><li class="alt">        cmp [ebp+PacketLeader], 69696969h</li><li>        jz  loc_WaitForPacketLeader</li><li class="alt">        jmp loc_SendControlPacketResend</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_cpGetDataOk:                ; CODE XREF: KdReceivePacket(x,x,x,x,x)+D5j</li><li class="alt">        cmp [ebp+PacketLeader], 69696969h</li><li>        jnz <span class="keyword">short</span> loc_NotControlPacketLeader2</li><li class="alt">        </li><li>        cmp word ptr [ebp+vPacketType], si</li><li class="alt">        jnz <span class="keyword">short</span> loc_notPacketTypeAcknowlodge</li><li>        </li><li class="alt">        mov eax, _KdCompNextPacketIdToSend</li><li>        and eax, 0FFFFF7FFh</li><li class="alt">        cmp [ebp+vPacketId], eax</li><li>        jnz loc_WaitForPacketLeader</li><li class="alt">        cmp [ebp+argPacketType], 4</li><li>        jnz loc_WaitForPacketLeader</li><li class="alt">        jmp loc_PacketTypeAcknowlege</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_notPacketTypeAcknowlodge:               ; CODE XREF: KdReceivePacket(x,x,x,x,x)+F6j</li><li class="alt">        cmp word ptr [ebp+vPacketType], 6</li><li>        jz  loc_vPacketTypeReset</li><li class="alt">        cmp word ptr [ebp+vPacketType], 5</li><li>        jnz loc_WaitForPacketLeader</li><li class="alt">        jmp loc_vPacketTypeResend</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_NotControlPacketLeader2:                ; CODE XREF: KdReceivePacket(x,x,x,x,x)+F0j</li><li class="alt">        cmp [ebp+argPacketType], esi</li><li>        jnz <span class="keyword">short</span> loc_receivedvByteCountOk</li><li class="alt">        mov eax, [ebp+vPacketId]</li><li>        cmp eax, _KdCompPacketIdExpected</li><li class="alt">        jz  loc_SendResendControlPacket</li><li>        </li><li class="alt">        push    eax</li><li>        push    esi</li><li class="alt"></li><li>loc_sendControlPacketAndWaitAgain:              ; CODE XREF: KdReceivePacket(x,x,x,x,x)+1E1j</li><li class="alt">                                    ; KdReceivePacket(x,x,x,x,x)+211j</li><li>        call    KdpSendControlPacket    ; KdpSendControlPacket(x,x)</li><li class="alt">        jmp loc_WaitForPacketLeader</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_receivedvByteCountOk:               ; CODE XREF: KdReceivePacket(x,x,x,x,x)+138j</li><li class="alt">        cmp word ptr [ebp+vByteCount],  0FA0h</li><li>        movzx   esi, word ptr [edi+2]</li><li class="alt">        ja  loc_SendControlPacketResend</li><li>        </li><li class="alt">        cmp word ptr [ebp+vByteCount],  si</li><li>        jb  loc_SendControlPacketResend</li><li class="alt">        </li><li>        ;</li><li class="alt">        ;***Read the message header.</li><li>        ;</li><li class="alt">        movzx   eax, word ptr [ebp+vByteCount]</li><li>        sub eax, esi</li><li class="alt">        push    esi</li><li>        mov [ebx], eax</li><li class="alt">        push    dword ptr [edi+4]</li><li>        call    KdpReceiveString ; KdpReceiveString(x,x)</li><li class="alt">        test    eax, eax</li><li>        jnz loc_SendControlPacketResend</li><li class="alt">        </li><li>        ;</li><li class="alt">        ; ***Read the message data.</li><li>        ;</li><li class="alt">        mov [edi], si</li><li>        push    dword ptr [ebx]</li><li class="alt">        mov esi, [ebp+arg_7+1]</li><li>        push    dword ptr [esi+4]</li><li class="alt">        call    KdpReceiveString ; KdpReceiveString(x,x)</li><li>        test    eax, eax</li><li class="alt">        jnz <span class="keyword">short</span> loc_SendControlPacketResend</li><li>        </li><li class="alt">        ;</li><li>        ;****Get Tailing Byte</li><li class="alt">        ;</li><li>        mov ax, [ebx]</li><li class="alt">        mov [esi], ax</li><li>        lea eax, [ebp+arg_7]</li><li class="alt">        push    eax</li><li>        call     KdCompGetByte ; KdCompGetByte(x)</li><li class="alt">        test    eax, eax</li><li>        jnz <span class="keyword">short</span> loc_SendControlPacketResend</li><li class="alt">        </li><li>        cmp <span class="keyword">byte</span> ptr [ebp+arg_7], 0AAh</li><li class="alt">        jnz <span class="keyword">short</span> loc_SendControlPacketResend</li><li>        </li><li class="alt">        movzx   eax, word ptr [ebp+vPacketType]</li><li>        cmp [ebp+argPacketType], eax</li><li class="alt">        jz  <span class="keyword">short</span> loc_ReceivedPacketIdOk</li><li>        </li><li class="alt">        push    [ebp+vPacketId]</li><li>        jmp <span class="keyword">short</span> loc_AcknowledgeAndWait</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_ReceivedPacketIdOk:             ; CODE XREF: KdReceivePacket(x,x,x,x,x)+1BCj</li><li>        mov esi, [ebp+vPacketId]</li><li class="alt">        cmp esi, 80800000h      ;INITIAL_PACKET_ID</li><li>        jz  <span class="keyword">short</span> loc_InitPacketId</li><li class="alt">        cmp esi, 80800001h      ;   INITIAL_PACKET_ID_1</li><li>        jnz <span class="keyword">short</span> loc_SendControlPacketResend</li><li class="alt"></li><li>loc_InitPacketId:               ; CODE XREF: KdReceivePacket(x,x,x,x,x)+1CCj</li><li class="alt">        cmp esi, _KdCompPacketIdExpected</li><li>        jz  <span class="keyword">short</span> loc_ComputeCheckSum</li><li class="alt">        </li><li>        push    esi</li><li class="alt"></li><li>loc_AcknowledgeAndWait:             ; CODE XREF: KdReceivePacket(x,x,x,x,x)+1C1j</li><li class="alt">        push    4</li><li>        jmp    loc_sendControlPacketAndWaitAgain</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_ComputeCheckSum:                ; CODE XREF: KdReceivePacket(x,x,x,x,x)+1DCj</li><li>        mov eax, [ebp+arg_7+1]</li><li class="alt">        movzx   ecx, word ptr [eax]</li><li>        push    ecx</li><li class="alt">        push    dword ptr [eax+4]</li><li>        call    KdpComputeChecksum ;    KdpComputeChecksum(x,x)</li><li class="alt">        mov ebx, eax</li><li>        movzx   eax, word ptr [edi]</li><li class="alt">        push    eax</li><li>        push    dword ptr [edi+4]</li><li class="alt">        call    KdpComputeChecksum ;    KdpComputeChecksum(x,x)</li><li>        add ebx, eax</li><li class="alt">        cmp ebx, [ebp+varCheckSum]</li><li>        jz  <span class="keyword">short</span> loc_SendAcknowledgePacket</li><li class="alt">        </li><li>        mov ebx, [ebp+arg_C]</li><li class="alt"></li><li>loc_SendControlPacketResend:                ; CODE XREF: KdReceivePacket(x,x,x,x,x)+E4j</li><li class="alt">                    ; KdReceivePacket(x,x,x,x,x)+15Fj ...</li><li>        push    0</li><li class="alt">        push    5   ;PACKET_TYPE_KD_RESEND</li><li>        jmp loc_sendControlPacketAndWaitAgain</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_GetNoData:              ; CODE XREF: KdReceivePacket(x,x,x,x,x)+6Fj</li><li>                    ; KdReceivePacket(x,x,x,x,x)+9Aj ...</li><li class="alt">        xor eax, eax</li><li>        inc eax</li><li class="alt">        jmp <span class="keyword">short</span> loc_return0</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_returnReSend:               ; CODE XREF: KdReceivePacket(x,x,x,x,x)+87j</li><li class="alt">        mov eax, esi</li><li>        jmp <span class="keyword">short</span> loc_return0</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_vPacketTypeReset:               ; CODE XREF: KdReceivePacket(x,x,x,x,x)+11Fj</li><li>        mov eax, 80800000h</li><li class="alt">        push    0</li><li>        push    6</li><li class="alt">        mov _KdCompNextPacketIdToSend, eax</li><li>        mov _KdCompPacketIdExpected, eax</li><li class="alt">        call    KdpSendControlPacket    ; KdpSendControlPacket(x,x)</li><li></li><li class="alt">loc_vPacketTypeResend:              ; CODE XREF: KdReceivePacket(x,x,x,x,x)+130j</li><li>        push    2</li><li class="alt">        pop eax</li><li>        jmp <span class="keyword">short</span> loc_return0</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_SendResendControlPacket:                ; CODE XREF: KdReceivePacket(x,x,x,x,x)+143j</li><li>        push    0</li><li class="alt">        push    5</li><li>        call    KdpSendControlPacket    ; KdpSendControlPacket(x,x)</li><li class="alt"></li><li>loc_PacketTypeAcknowlege:               ; CODE XREF: KdReceivePacket(x,x,x,x,x)+115j</li><li class="alt">        xor _KdCompNextPacketIdToSend, 1</li><li>        jmp <span class="keyword">short</span> loc_returnOk</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_SendAcknowledgePacket:              ; CODE XREF: KdReceivePacket(x,x,x,x,x)+208j</li><li>        push    esi</li><li class="alt">        push    4           ;PACKET_TYPE_KD_ACKNOWLEDGE</li><li>        call    KdpSendControlPacket    ; KdpSendControlPacket(x,x)</li><li class="alt">        xor _KdCompPacketIdExpected, 1</li><li></li><li class="alt">loc_returnOk:               ; CODE XREF: KdReceivePacket(x,x,x,x,x)+24Cj</li><li>        xor eax, eax</li><li class="alt"></li><li>loc_return0:                ; CODE XREF: KdReceivePacket(x,x,x,x,x)+59j</li><li class="alt">                    ; KdReceivePacket(x,x,x,x,x)+219j ...</li><li>        pop edi</li><li class="alt">        pop esi</li><li>        pop ebx</li><li class="alt"></li><li>loc_return:         ; CODE XREF: KdReceivePacket(x,x,x,x,x)+1Dj</li><li class="alt">                    ; KdReceivePacket(x,x,x,x,x)+26j</li><li>        leave</li><li class="alt">        retn    14h</li><li>KdReceivePacket endp</li><li class="alt"></li><li>; Exported entry   8. KdSendPacket</li><li class="alt"></li><li>;------------------------------------------------------------------------ </li><li class="alt">; Attributes: bp-based frame</li><li></li><li class="alt">; _stdcall KdSendPacket(x, x, x, x)</li><li>        <span class="keyword">public</span> KdSendPacket</li><li class="alt">KdSendPacket proc near</li><li></li><li class="alt">vPacketLeader   = dword ptr -10h</li><li>vPacketType     = word ptr -0Ch</li><li class="alt">vByteCount      = word ptr -0Ah</li><li>vPacketId       = dword ptr -8</li><li class="alt">vCheckSum       = dword ptr -4</li><li>ArgPacketType   = dword ptr  8</li><li class="alt">MessageHeader   = dword ptr  0Ch</li><li>MessageData     = dword ptr  10h</li><li class="alt">KdContext       = dword ptr  14h</li><li>        </li><li class="alt">    </li><li>        push    ebp</li><li class="alt">        mov ebp, esp</li><li>        sub esp, 10h</li><li class="alt">        mov eax, [ebp+MessageData]</li><li>        push    ebx</li><li class="alt">        xor ebx, ebx</li><li>        cmp eax, ebx</li><li class="alt">        push    esi</li><li>        push    edi</li><li class="alt">        jz  <span class="keyword">short</span> loc_noMessageData</li><li>        </li><li class="alt">        movzx   ebx, word ptr [eax]</li><li>        push    ebx</li><li class="alt">        push    dword ptr [eax+4]</li><li>        call    KdpComputeChecksum ;    KdpComputeChecksum(x,x)</li><li class="alt">        </li><li>        mov [ebp+vCheckSum], eax</li><li class="alt">        jmp <span class="keyword">short</span> loc_computeHeaderCheckSum</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_noMessageData:              ; CODE XREF: KdSendPacket(x,x,x,x)+10j</li><li class="alt">        mov [ebp+vCheckSum], ebx</li><li></li><li class="alt">loc_computeHeaderCheckSum:              ; CODE XREF: KdSendPacket(x,x,x,x)+21j</li><li>        mov esi, [ebp+MessageHeader]</li><li class="alt">        mov di, [esi]</li><li>        movzx   eax, di</li><li class="alt">        push    eax</li><li>        push    dword ptr [esi+4]</li><li class="alt">        call    KdpComputeChecksum ;    KdpComputeChecksum(x,x)</li><li>        add [ebp+vCheckSum], eax</li><li class="alt">        mov eax, _KdCompRetryCount</li><li>        add edi, ebx</li><li class="alt">        mov [ebp+var_A], di</li><li>        mov edi, [ebp+ArgPacketType]</li><li class="alt">        mov [ebp+vPacketLeader], 30303030h</li><li>        mov [ebp+vPacketType], di</li><li class="alt">        mov _KdCompNumberRetries, eax</li><li></li><li class="alt">loc_loopSendData:               ; CODE XREF: KdSendPacket(x,x,x,x)+EAj</li><li>        cmp _KdCompNumberRetries, 0</li><li class="alt">        jnz <span class="keyword">short</span> loc_normalSendString</li><li>        ;</li><li class="alt">        ; If the packet <span class="keyword">is</span> not <span class="keyword">for</span> reporting exception, we give up</li><li>        ; and declare debugger not present.</li><li class="alt">        ;</li><li>        </li><li class="alt">        cmp edi, 3          ;cmp edi, PACKET_TYPE_KD_DEBUG_IO</li><li>        jnz <span class="keyword">short</span> loc_notPacketTypeDebugIo</li><li class="alt">    </li><li>        mov eax, [esi+4]            ;DebugIo-&gt;ApiNumber </li><li class="alt">        cmp dword ptr [eax], 3230h  ;#define DbgKdPrintStringApi                 0x00003230</li><li>        jmp <span class="keyword">short</span> loc_checkApiNumber</li><li class="alt">; -----------------------------------------------------------------------------------C</li><li></li><li class="alt">loc_notPacketTypeDebugIo:               ; CODE XREF: KdSendPacket(x,x,x,x)+65j</li><li>        cmp edi, 7                  ;PACKET_TYPE_KD_STATE_CHANGE64 </li><li class="alt">        jnz <span class="keyword">short</span> loc_notKdstateChange64</li><li>        </li><li class="alt">        mov eax, [esi+4]</li><li>        cmp dword ptr [eax], 3031h  ;#define DbgKdLoadSymbolsStateChange         0x00003031</li><li class="alt">        jmp <span class="keyword">short</span> loc_checkApiNumber</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_notKdstateChange64:             ; CODE XREF: KdSendPacket(x,x,x,x)+75j</li><li class="alt">        cmp edi, 0Bh                ; PACKET_TYPE_KD_FILE_IO              11</li><li>        jnz <span class="keyword">short</span> loc_normalSendString</li><li class="alt">        mov eax, [esi+4]</li><li>        cmp dword ptr [eax], 3430h  ;DbgKdCreateFileApi</li><li class="alt"></li><li>loc_checkApiNumber:             ; CODE XREF: KdSendPacket(x,x,x,x)+70j</li><li class="alt">                    ; KdSendPacket(x,x,x,x)+80j</li><li>        jz  <span class="keyword">short</span> loc_MarkDisableDuggerAndReturn</li><li class="alt"></li><li>loc_normalSendString:               ; CODE XREF: KdSendPacket(x,x,x,x)+60j</li><li class="alt">                    ; KdSendPacket(x,x,x,x)+85j</li><li>        mov eax, _KdCompNextPacketIdToSend</li><li class="alt">        mov [ebp+vPacketId], eax</li><li>        </li><li class="alt">        push    10h</li><li>        lea eax, [ebp+vPacketLeader]</li><li class="alt">        push    eax</li><li>        call    KdpSendString ; KdpSendString(x,x)</li><li class="alt">        </li><li>        movzx   eax, word ptr [esi]</li><li class="alt">        push    eax</li><li>        push    dword ptr [esi+4]</li><li class="alt">        call    KdpSendString ; KdpSendString(x,x)</li><li>        </li><li class="alt">        test    ebx, ebx</li><li>        jz  <span class="keyword">short</span> loc_sendTailingByte</li><li class="alt">        mov eax, [ebp+MessageData]</li><li>        movzx   ecx, word ptr [eax]</li><li class="alt">        push    ecx</li><li>        push    dword ptr [eax+4]</li><li class="alt">        call    KdpSendString ; KdpSendString(x,x)</li><li></li><li class="alt">loc_sendTailingByte:                ; CODE XREF: KdSendPacket(x,x,x,x)+B3j</li><li>        push    0AAh</li><li class="alt">        call     KdCompPutByte ; KdCompPutByte(x)</li><li>        push    [ebp+KdContext]</li><li class="alt">        xor eax, eax</li><li>        push    eax</li><li class="alt">        push    eax</li><li>        push    eax</li><li class="alt">        push    4</li><li>        call    KdReceivePacket ; KdReceivePacket(x,x,x,x,x)</li><li class="alt">        cmp eax, 1</li><li>        jnz <span class="keyword">short</span> loc_receiveNotTimeOut</li><li class="alt">        </li><li>        dec _KdCompNumberRetries</li><li class="alt"></li><li>loc_receiveNotTimeOut:              ; CODE XREF: KdSendPacket(x,x,x,x)+E0j</li><li class="alt">        test    eax, eax</li><li>        jnz loc_loopSendData            ;jump upon looOOOOOOp....</li><li class="alt">        </li><li>        ;Send Ok</li><li class="alt">        ;</li><li>        mov eax, [ebp+KdContext]</li><li class="alt">        </li><li>        ;</li><li class="alt">        ; Reset Sync bit <span class="keyword">in</span> packet id.  The packet we sent may have Sync bit <span class="keyword">set</span></li><li>        ;</li><li class="alt">        ;</li><li>        and byte_MsrLastValue, 0F7h ; KdpNextPacketIdToSend &amp;= ~SYNC_PACKET_ID;</li><li class="alt">        mov eax, [eax]</li><li>        mov _KdCompRetryCount, eax</li><li class="alt"></li><li>loc_return:             ; CODE XREF: KdSendPacket(x,x,x,x)+12Bj</li><li class="alt">        pop edi</li><li>        pop esi</li><li class="alt">        pop ebx</li><li>        leave</li><li class="alt">        retn    10h</li><li>; -----------------------------------------------------------------------------------C</li><li class="alt"></li><li>loc_MarkDisableDuggerAndReturn:             ; CODE XREF: KdSendPacket(x,x,x,x):loc_80011242j</li><li class="alt">        mov eax, dword ptr ds:[KdDebuggerNotPresent]</li><li>        mov <span class="keyword">byte</span> ptr [eax], 1</li><li class="alt">        </li><li>        </li><li class="alt">        and <span class="keyword">byte</span> ptr ds:[0FFDF02D4h],   0FDh</li><li>        mov _KdCompNextPacketIdToSend,  80800800h</li><li class="alt">        mov _KdCompPacketIdExpected,    80800000h</li><li>        jmp <span class="keyword">short</span> loc_return</li><li class="alt">KdSendPacket endp</li><li></li><li class="alt">; -----------------------------------------------------------------------------------C</li><li>PAGEKD      ends</li><li class="alt"></li><li></li><li class="alt">end DllEntryPoint</li></ol></div>
<p>另外我结合了win2k的源代和reactos的代码,编译了部分成C语言,下面顺合给出这个文件kdcomio.c以供研究.<br/>你可以使用将C言语实现过的函数从上面的asm代码中出除,然后使用以下命令混合编译ASM和C语言生成一个可用的kdcom.dll,<br/>这个我也已经测试成的.假设你安装了RadAsm和VS或DDK,生成的命令如下:<br/></p>
<p><br/></p>
<div class="highlighter">
<ol class="highlighter-c"><li>@rem build.bat</li><li class="alt"></li><li>E:/WINDDK/2600/bin/x86/ML.EXE /nologo /c /Gz /coff /I<span class="string">"C:/RadASM/Masm32/Include"</span> <span class="string">"kdcom.asm"</span></li><li class="alt">E:/WINDDK/2600/bin/x86/CL.EXE /c /Od /W3 /TC /Gz  <span class="string">"kdcomio.c"</span></li><li></li><li class="alt">E:/WINDDK/2600/bin/x86/LINK.EXE /nologo /driver /<span class="keyword">base</span>:0x80010000 /subsystem:native /NODEFAULTLIB:LIBC.lib /NODEFAULTLIB:OLDNAMES.lib  /align:128 /libpath:C:/RadASM/masm32/lib/w2k /entry:DllEntryPoint /DEF:kdcom.Def /<span class="keyword">out</span>:<span class="string">"kdcom.dll"</span> <span class="string">"kdcom.obj"</span> <span class="string">"kdcomio.obj"</span></li><li></li><li class="alt">pause</li></ol></div>
<p><font color="#a31515"></font> </p>
<p> </p>
<p> </p>
<p> </p>
<div class="highlighter">
<ol class="highlighter-cpp"><li><span class="comment">/**</span></li><li class="alt"><span class="comment">    kdcomio.c </span></li><li><span class="comment">    Create by Aerror</span></li><li class="alt"><span class="comment">*/</span></li><li></li><li class="alt"><span class="preprocessor">#define IN  </span></li><li><span class="preprocessor">#define OUT </span></li><li class="alt"><span class="preprocessor">#define IN_OUT  </span></li><li><span class="preprocessor">#define OPTIONAL </span></li><li class="alt"></li><li><span class="preprocessor">#define FALSE  0   </span></li><li class="alt"><span class="preprocessor">#define TRUE   1   </span></li><li><span class="preprocessor">#define NULL 0 </span></li><li class="alt"></li><li><span class="preprocessor">#define PACKET_MAX_SIZE           0x0FA0 </span></li><li class="alt"><span class="preprocessor">#define DBGKD_MAXSTREAM                     16 </span></li><li><span class="preprocessor">#define EXCEPTION_MAXIMUM_PARAMETERS 15 // maximum number of exception parameters </span></li><li class="alt"></li><li><span class="preprocessor">#define CP_GET_SUCCESS  0 </span></li><li class="alt"><span class="preprocessor">#define CP_GET_NODATA   1 </span></li><li><span class="preprocessor">#define CP_GET_ERROR    2 </span></li><li class="alt"></li><li></li><li class="alt"></li><li><span class="preprocessor">#define KDP_PACKET_RECEIVED 0 </span></li><li class="alt"><span class="preprocessor">#define KDP_PACKET_TIMEOUT 1 </span></li><li><span class="preprocessor">#define KDP_PACKET_RESEND  2 </span></li><li class="alt"></li><li></li><li class="alt"><span class="preprocessor">#define PACKET_LEADER_BYTE     0x30 </span></li><li><span class="preprocessor">#define PACKET_LEADER        0x30303030 </span></li><li class="alt"><span class="preprocessor">#define CONTROL_PACKET_LEADER_BYTE 0x69 </span></li><li><span class="preprocessor">#define CONTROL_PACKET_LEADER      0x69696969 </span></li><li class="alt"><span class="preprocessor">#define BREAKIN_PACKET_BYTE     0x62 </span></li><li><span class="preprocessor">#define BREAKIN_PACKET             0x62626262 </span></li><li class="alt"><span class="preprocessor">#define PACKET_TRAILING_BYTE    0xAA </span></li><li></li><li class="alt"><span class="preprocessor">#define DbgKdPrintStringApi                 0x00003230 </span></li><li><span class="preprocessor">#define DbgKdGetStringApi                   0x00003231 </span></li><li class="alt"><span class="comment">// </span></li><li><span class="comment">// Wait State Change Types </span></li><li class="alt"><span class="comment">// </span></li><li><span class="preprocessor">#define DbgKdMinimumStateChange             0x00003030 </span></li><li class="alt"><span class="preprocessor">#define DbgKdExceptionStateChange           0x00003030 </span></li><li><span class="preprocessor">#define DbgKdLoadSymbolsStateChange         0x00003031 </span></li><li class="alt"><span class="preprocessor">#define DbgKdCommandStringStateChange       0x00003032 </span></li><li><span class="preprocessor">#define DbgKdMaximumStateChange             0x00003033 </span></li><li class="alt"></li><li><span class="comment">// </span></li><li class="alt"><span class="comment">// Manipulate Types </span></li><li><span class="comment">// </span></li><li class="alt"><span class="preprocessor">#define DbgKdMinimumManipulate              0x00003130 </span></li><li><span class="preprocessor">#define DbgKdReadVirtualMemoryApi           0x00003130 </span></li><li class="alt"><span class="preprocessor">#define DbgKdWriteVirtualMemoryApi          0x00003131 </span></li><li><span class="preprocessor">#define DbgKdGetContextApi                  0x00003132 </span></li><li class="alt"><span class="preprocessor">#define DbgKdSetContextApi                  0x00003133 </span></li><li><span class="preprocessor">#define DbgKdWriteBreakPointApi             0x00003134 </span></li><li class="alt"><span class="preprocessor">#define DbgKdRestoreBreakPointApi           0x00003135 </span></li><li><span class="preprocessor">#define DbgKdContinueApi                    0x00003136 </span></li><li class="alt"><span class="preprocessor">#define DbgKdReadControlSpaceApi            0x00003137 </span></li><li><span class="preprocessor">#define DbgKdWriteControlSpaceApi           0x00003138 </span></li><li class="alt"><span class="preprocessor">#define DbgKdReadIoSpaceApi                 0x00003139 </span></li><li><span class="preprocessor">#define DbgKdWriteIoSpaceApi                0x0000313A </span></li><li class="alt"><span class="preprocessor">#define DbgKdRebootApi                      0x0000313B </span></li><li><span class="preprocessor">#define DbgKdContinueApi2                   0x0000313C </span></li><li class="alt"><span class="preprocessor">#define DbgKdReadPhysicalMemoryApi          0x0000313D </span></li><li><span class="preprocessor">#define DbgKdWritePhysicalMemoryApi         0x0000313E </span></li><li class="alt"><span class="preprocessor">#define DbgKdQuerySpecialCallsApi           0x0000313F </span></li><li><span class="preprocessor">#define DbgKdSetSpecialCallApi              0x00003140 </span></li><li class="alt"><span class="preprocessor">#define DbgKdClearSpecialCallsApi           0x00003141 </span></li><li><span class="preprocessor">#define DbgKdSetInternalBreakPointApi       0x00003142 </span></li><li class="alt"><span class="preprocessor">#define DbgKdGetInternalBreakPointApi       0x00003143 </span></li><li><span class="preprocessor">#define DbgKdReadIoSpaceExtendedApi         0x00003144 </span></li><li class="alt"><span class="preprocessor">#define DbgKdWriteIoSpaceExtendedApi        0x00003145 </span></li><li><span class="preprocessor">#define DbgKdGetVersionApi                  0x00003146 </span></li><li class="alt"><span class="preprocessor">#define DbgKdWriteBreakPointExApi           0x00003147 </span></li><li><span class="preprocessor">#define DbgKdRestoreBreakPointExApi         0x00003148 </span></li><li class="alt"><span class="preprocessor">#define DbgKdCauseBugCheckApi               0x00003149 </span></li><li><span class="preprocessor">#define DbgKdSwitchProcessor                0x00003150 </span></li><li class="alt"><span class="preprocessor">#define DbgKdPageInApi                      0x00003151 </span></li><li><span class="preprocessor">#define DbgKdReadMachineSpecificRegister    0x00003152 </span></li><li class="alt"><span class="preprocessor">#define DbgKdWriteMachineSpecificRegister   0x00003153 </span></li><li><span class="preprocessor">#define OldVlm1                             0x00003154 </span></li><li class="alt"><span class="preprocessor">#define OldVlm2                             0x00003155 </span></li><li><span class="preprocessor">#define DbgKdSearchMemoryApi                0x00003156 </span></li><li class="alt"><span class="preprocessor">#define DbgKdGetBusDataApi                  0x00003157 </span></li><li><span class="preprocessor">#define DbgKdSetBusDataApi                  0x00003158 </span></li><li class="alt"><span class="preprocessor">#define DbgKdCheckLowMemoryApi              0x00003159 </span></li><li><span class="preprocessor">#define DbgKdClearAllInternalBreakpointsApi 0x0000315A </span></li><li class="alt"><span class="preprocessor">#define DbgKdFillMemoryApi                  0x0000315B </span></li><li><span class="preprocessor">#define DbgKdQueryMemoryApi                 0x0000315C </span></li><li class="alt"><span class="preprocessor">#define DbgKdSwitchPartition                0x0000315D </span></li><li><span class="preprocessor">#define DbgKdMaximumManipulate              0x0000315E </span></li><li class="alt"></li><li><span class="comment">// </span></li><li class="alt"><span class="comment">// Debug I/O Types </span></li><li><span class="comment">// </span></li><li class="alt"><span class="preprocessor">#define DbgKdPrintStringApi                 0x00003230 </span></li><li><span class="preprocessor">#define DbgKdGetStringApi                   0x00003231 </span></li><li class="alt"></li><li><span class="comment">// </span></li><li class="alt"><span class="comment">// Control Report Flags </span></li><li><span class="comment">// </span></li><li class="alt"><span class="preprocessor">#define REPORT_INCLUDES_SEGS                0x0001 </span></li><li><span class="preprocessor">#define REPORT_INCLUDES_CS                  0x0002 </span></li><li class="alt"></li><li></li><li class="alt"><span class="preprocessor">#define INITIAL_PACKET_ID      0x80800000 </span></li><li><span class="preprocessor">#define INITIAL_PACKET_ID_1     0x80800001 </span></li><li class="alt"><span class="preprocessor">#define SYNC_PACKET_ID      0x0800 </span></li><li></li><li class="alt"></li><li><span class="preprocessor">#define PACKET_TYPE_UNUSED                  0 </span></li><li class="alt"><span class="preprocessor">#define PACKET_TYPE_KD_STATE_CHANGE32       1 </span></li><li><span class="preprocessor">#define PACKET_TYPE_KD_STATE_MANIPULATE     2 </span></li><li class="alt"><span class="preprocessor">#define PACKET_TYPE_KD_DEBUG_IO             3 </span></li><li><span class="preprocessor">#define PACKET_TYPE_KD_ACKNOWLEDGE          4 </span></li><li class="alt"><span class="preprocessor">#define PACKET_TYPE_KD_RESEND               5 </span></li><li><span class="preprocessor">#define PACKET_TYPE_KD_RESET                6 </span></li><li class="alt"><span class="preprocessor">#define PACKET_TYPE_KD_STATE_CHANGE64       7 </span></li><li><span class="preprocessor">#define PACKET_TYPE_KD_POLL_BREAKIN         8 </span></li><li class="alt"><span class="preprocessor">#define PACKET_TYPE_KD_TRACE_IO             9 </span></li><li><span class="preprocessor">#define PACKET_TYPE_KD_CONTROL_REQUEST      10 </span></li><li class="alt"><span class="preprocessor">#define PACKET_TYPE_KD_FILE_IO              11 </span></li><li><span class="preprocessor">#define PACKET_TYPE_MAX                     12 </span></li><li class="alt"></li><li></li><li class="alt"><span class="preprocessor">#define ARGUMENT_PRESENT(ArgumentPointer)    (/ </span></li><li>    (<span class="datatypes">CHAR</span> *)(ArgumentPointer) != (<span class="datatypes">CHAR</span> *)(NULL) )</li><li class="alt">    </li><li>                        </li><li class="alt"><span class="keyword">typedef</span>   unsigned <span class="datatypes">int</span>   <span class="datatypes">ULONG</span> ;</li><li><span class="keyword">typedef</span>   <span class="datatypes">ULONG</span>*     <span class="datatypes">PULONG</span>;</li><li class="alt"><span class="keyword">typedef</span>   unsigned <span class="datatypes">char</span>  <span class="datatypes">UCHAR</span>;</li><li><span class="keyword">typedef</span>   <span class="datatypes">UCHAR</span>*     <span class="datatypes">PUCHAR</span>;</li><li class="alt"><span class="keyword">typedef</span>   unsigned <span class="datatypes">short</span>  <span class="datatypes">USHORT</span>;</li><li><span class="keyword">typedef</span>   unsigned <span class="datatypes">short</span>* <span class="datatypes">PUSHORT</span>;</li><li class="alt"><span class="keyword">typedef</span>  <span class="datatypes">char</span>*      <span class="datatypes">PCHAR</span>;</li><li><span class="keyword">typedef</span>  <span class="datatypes">char</span>      <span class="datatypes">CHAR</span>;</li><li class="alt"><span class="keyword">typedef</span>   <span class="keyword">void</span>      <span class="datatypes">VOID</span>;</li><li><span class="keyword">typedef</span>   <span class="keyword">void</span>*      <span class="datatypes">PVOID</span>;</li><li class="alt"><span class="keyword">typedef</span>  unsigned <span class="datatypes">char</span>  <span class="datatypes">BOOLEAN</span>;</li><li><span class="keyword">typedef</span>   <span class="datatypes">long</span> <span class="datatypes">LONG_PTR</span>, *<span class="datatypes">PLONG_PTR</span>;</li><li class="alt"><span class="keyword">typedef</span>   <span class="datatypes">long</span> <span class="datatypes">ULONG_PTR</span>, *<span class="datatypes">PULONG_PTR</span>;</li><li><span class="keyword">typedef</span>  unsigned _int64 <span class="datatypes">ULONGLONG</span>;</li><li class="alt"><span class="keyword">typedef</span>  <span class="datatypes">ULONGLONG</span>    <span class="datatypes">ULONG64</span>;</li><li></li><li class="alt"><span class="keyword">typedef</span> <span class="keyword">struct</span> _STRING {<!-- --></li><li>    <span class="datatypes">USHORT</span> Length;</li><li class="alt">    <span class="datatypes">USHORT</span> MaximumLength;</li><li>    <span class="datatypes">PCHAR</span> Buffer;</li><li class="alt">} STRING;</li><li><span class="keyword">typedef</span> STRING *PSTRING;</li><li class="alt"></li><li><span class="keyword">typedef</span> <span class="keyword">struct</span> _KD_CONTEXT</li><li class="alt">{<!-- --></li><li> <span class="datatypes">ULONG</span>   RetryCount;</li><li class="alt"> <span class="datatypes">BOOLEAN</span> BreakInRequested;</li><li>} KD_CONTEXT, * PKD_CONTEXT;</li><li class="alt"></li><li><span class="keyword">typedef</span> <span class="keyword">struct</span> _KSYSTEM_TIME{<!-- --></li><li class="alt"> <span class="datatypes">ULONG</span> LowPart           ; <span class="comment">//+0x000 </span></li><li> <span class="datatypes">ULONG</span> High1Time ;<span class="comment">//       : Int4B </span></li><li class="alt"> <span class="datatypes">ULONG</span> High2Time ;<span class="comment">//       : Int4B </span></li><li>}KSYSTEM_TIME;</li><li class="alt"></li><li><span class="keyword">typedef</span> <span class="keyword">enum</span> _ALTERNATIVE_ARCHITECTURE_TYPE</li><li class="alt">{<!-- --></li><li></li><li class="alt">   StandardDesign = 0,</li><li>   NEC98x86 = 1,</li><li class="alt">   EndAlternatives = 2</li><li>}ALTERNATIVE_ARCHITECTURE_TYPE;</li><li class="alt">  </li><li></li><li class="alt"><span class="keyword">typedef</span> <span class="keyword">enum</span> _NT_PRODUCT_TYPE{<!-- --></li><li>   NtProductWinNt = 1,</li><li class="alt">   NtProductLanManNt = 2,</li><li>   NtProductServer = 3,</li><li class="alt">}NT_PRODUCT_TYPE;</li><li></li><li class="alt"><span class="keyword">typedef</span> <span class="keyword">struct</span> _LARGE_INTEGER{<!-- --></li><li>  <span class="datatypes">ULONG</span> LowPart          ;<span class="comment">// Uint4B </span></li><li class="alt">  <span class="datatypes">ULONG</span>  HighPart         ;<span class="comment">// Int4B </span></li><li>}LARGE_INTEGER;</li><li class="alt">    </li><li>    </li><li class="alt"></li><li><span class="preprocessor">#define MAXIMUM_SUPPORTED_EXTENSION     512 </span></li><li class="alt"><span class="preprocessor">#define SIZE_OF_80387_REGISTERS      80 </span></li><li></li><li class="alt"><span class="keyword">typedef</span> <span class="keyword">struct</span> _FLOATING_SAVE_AREA {<!-- --></li><li>    <span class="datatypes">ULONG</span>   ControlWord;</li><li class="alt">    <span class="datatypes">ULONG</span>   StatusWord;</li><li>    <span class="datatypes">ULONG</span>   TagWord;</li><li class="alt">    <span class="datatypes">ULONG</span>   ErrorOffset;</li><li>    <span class="datatypes">ULONG</span>   ErrorSelector;</li><li class="alt">    <span class="datatypes">ULONG</span>   DataOffset;</li><li>    <span class="datatypes">ULONG</span>   DataSelector;</li><li class="alt">    <span class="datatypes">UCHAR</span>    RegisterArea[SIZE_OF_80387_REGISTERS];</li><li>    <span class="datatypes">ULONG</span>   Cr0NpxState;</li><li class="alt">} FLOATING_SAVE_AREA;</li><li></li><li class="alt"><span class="keyword">typedef</span> FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;</li><li></li><li class="alt"><span class="keyword">typedef</span> <span class="keyword">struct</span> _CONTEXT {<!-- --></li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// The flags values within this flag control the contents of </span></li><li class="alt">    <span class="comment">// a CONTEXT record. </span></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">// If the context record is used as an input parameter, then </span></li><li>    <span class="comment">// for each portion of the context record controlled by a flag </span></li><li class="alt">    <span class="comment">// whose value is set, it is assumed that that portion of the </span></li><li>    <span class="comment">// context record contains valid context. If the context record </span></li><li class="alt">    <span class="comment">// is being used to modify a threads context, then only that </span></li><li>    <span class="comment">// portion of the threads context will be modified. </span></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// If the context record is used as an IN OUT parameter to capture </span></li><li class="alt">    <span class="comment">// the context of a thread, then only those portions of the thread's </span></li><li>    <span class="comment">// context corresponding to set flags will be returned. </span></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// The context record is never used as an OUT only parameter. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    <span class="datatypes">ULONG</span> ContextFlags;</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// This section is specified/returned if CONTEXT_DEBUG_REGISTERS is </span></li><li class="alt">    <span class="comment">// set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT </span></li><li>    <span class="comment">// included in CONTEXT_FULL. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    <span class="datatypes">ULONG</span>   Dr0;</li><li>    <span class="datatypes">ULONG</span>   Dr1;</li><li class="alt">    <span class="datatypes">ULONG</span>   Dr2;</li><li>    <span class="datatypes">ULONG</span>   Dr3;</li><li class="alt">    <span class="datatypes">ULONG</span>   Dr6;</li><li>    <span class="datatypes">ULONG</span>   Dr7;</li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">// This section is specified/returned if the </span></li><li>    <span class="comment">// ContextFlags word contians the flag CONTEXT_FLOATING_POINT. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    FLOATING_SAVE_AREA FloatSave;</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// This section is specified/returned if the </span></li><li class="alt">    <span class="comment">// ContextFlags word contians the flag CONTEXT_SEGMENTS. </span></li><li>    <span class="comment">// </span></li><li class="alt"></li><li>    <span class="datatypes">ULONG</span>   SegGs;</li><li class="alt">    <span class="datatypes">ULONG</span>   SegFs;</li><li>    <span class="datatypes">ULONG</span>   SegEs;</li><li class="alt">    <span class="datatypes">ULONG</span>   SegDs;</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// This section is specified/returned if the </span></li><li class="alt">    <span class="comment">// ContextFlags word contians the flag CONTEXT_INTEGER. </span></li><li>    <span class="comment">// </span></li><li class="alt"></li><li>    <span class="datatypes">ULONG</span>   Edi;</li><li class="alt">    <span class="datatypes">ULONG</span>   Esi;</li><li>    <span class="datatypes">ULONG</span>   Ebx;</li><li class="alt">    <span class="datatypes">ULONG</span>   Edx;</li><li>    <span class="datatypes">ULONG</span>   Ecx;</li><li class="alt">    <span class="datatypes">ULONG</span>   Eax;</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// This section is specified/returned if the </span></li><li class="alt">    <span class="comment">// ContextFlags word contians the flag CONTEXT_CONTROL. </span></li><li>    <span class="comment">// </span></li><li class="alt"></li><li>    <span class="datatypes">ULONG</span>   Ebp;</li><li class="alt">    <span class="datatypes">ULONG</span>   Eip;</li><li>    <span class="datatypes">ULONG</span>   SegCs;              <span class="comment">// MUST BE SANITIZED </span></li><li class="alt">    <span class="datatypes">ULONG</span>   EFlags;             <span class="comment">// MUST BE SANITIZED </span></li><li>    <span class="datatypes">ULONG</span>   Esp;</li><li class="alt">    <span class="datatypes">ULONG</span>   SegSs;</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// This section is specified/returned if the ContextFlags word </span></li><li class="alt">    <span class="comment">// contains the flag CONTEXT_EXTENDED_REGISTERS. </span></li><li>    <span class="comment">// The format and contexts are processor specific </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    <span class="datatypes">UCHAR</span>    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</li><li></li><li class="alt">} CONTEXT;</li><li></li><li class="alt">   </li><li></li><li class="alt"><span class="keyword">typedef</span> <span class="keyword">struct</span> _EXCEPTION_RECORD64 {<!-- --></li><li>    <span class="datatypes">ULONG</span>    ExceptionCode;</li><li class="alt">    <span class="datatypes">ULONG</span> ExceptionFlags;</li><li>    <span class="datatypes">ULONG64</span> ExceptionRecord;</li><li class="alt">    <span class="datatypes">ULONG64</span> ExceptionAddress;</li><li>    <span class="datatypes">ULONG</span> NumberParameters;</li><li class="alt">    <span class="datatypes">ULONG</span> __unusedAlignment;</li><li>    <span class="datatypes">ULONG64</span> ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</li><li class="alt">} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;</li><li></li><li class="alt"><span class="comment">// </span></li><li><span class="comment">// DBGKM Structure for Exceptions </span></li><li class="alt"><span class="comment">// </span></li><li><span class="keyword">typedef</span> <span class="keyword">struct</span> _DBGKM_EXCEPTION64</li><li class="alt">{<!-- --></li><li>    EXCEPTION_RECORD64 ExceptionRecord;</li><li class="alt">    <span class="datatypes">ULONG</span> FirstChance;</li><li>} DBGKM_EXCEPTION64, *PDBGKM_EXCEPTION64;</li><li class="alt"></li><li><span class="comment">// </span></li><li class="alt"><span class="comment">// DBGKD Structure for State Change </span></li><li><span class="comment">// </span></li><li class="alt"><span class="keyword">typedef</span> <span class="keyword">struct</span> _DBGKD_CONTROL_REPORT</li><li>{<!-- --></li><li class="alt">    <span class="datatypes">ULONG</span> Dr6;</li><li>    <span class="datatypes">ULONG</span> Dr7;</li><li class="alt">    <span class="datatypes">USHORT</span> InstructionCount;</li><li>    <span class="datatypes">USHORT</span> ReportFlags;</li><li class="alt">    <span class="datatypes">UCHAR</span> InstructionStream[DBGKD_MAXSTREAM];</li><li>    <span class="datatypes">USHORT</span> SegCs;</li><li class="alt">    <span class="datatypes">USHORT</span> SegDs;</li><li>    <span class="datatypes">USHORT</span> SegEs;</li><li class="alt">    <span class="datatypes">USHORT</span> SegFs;</li><li>    <span class="datatypes">ULONG</span> EFlags;</li><li class="alt">} DBGKD_CONTROL_REPORT, *PDBGKD_CONTROL_REPORT;</li><li></li><li class="alt"><span class="comment">// </span></li><li><span class="comment">// DBGKD Structure for Debug I/O Type Print String </span></li><li class="alt"><span class="comment">// </span></li><li><span class="keyword">typedef</span> <span class="keyword">struct</span> _DBGKD_PRINT_STRING</li><li class="alt">{<!-- --></li><li>    <span class="datatypes">ULONG</span> LengthOfString;</li><li class="alt">} DBGKD_PRINT_STRING, *PDBGKD_PRINT_STRING;</li><li></li><li class="alt"><span class="comment">// </span></li><li><span class="comment">// DBGKD Structure for Debug I/O Type Get String </span></li><li class="alt"><span class="comment">// </span></li><li><span class="keyword">typedef</span> <span class="keyword">struct</span> _DBGKD_GET_STRING</li><li class="alt">{<!-- --></li><li>    <span class="datatypes">ULONG</span> LengthOfPromptString;</li><li class="alt">    <span class="datatypes">ULONG</span> LengthOfStringRead;</li><li>} DBGKD_GET_STRING, *PDBGKD_GET_STRING;</li><li class="alt"></li><li></li><li class="alt"></li><li><span class="comment">// </span></li><li class="alt"><span class="comment">// DBGKD Structure for Load Symbols </span></li><li><span class="comment">// </span></li><li class="alt"><span class="keyword">typedef</span> <span class="keyword">struct</span> _DBGKD_LOAD_SYMBOLS64</li><li>{<!-- --></li><li class="alt">    <span class="datatypes">ULONG</span> PathNameLength;</li><li>    <span class="datatypes">ULONG64</span> BaseOfDll;</li><li class="alt">    <span class="datatypes">ULONG64</span> ProcessId;</li><li>    <span class="datatypes">ULONG</span> CheckSum;</li><li class="alt">    <span class="datatypes">ULONG</span> SizeOfImage;</li><li>    <span class="datatypes">BOOLEAN</span> UnloadSymbols;</li><li class="alt">} DBGKD_LOAD_SYMBOLS64, *PDBGKD_LOAD_SYMBOLS64;</li><li></li><li class="alt"></li><li></li><li class="alt"><span class="keyword">typedef</span> <span class="keyword">struct</span> _KUSER_SHARED_DATA</li><li>{<!-- --></li><li class="alt"><span class="datatypes">ULONG</span> TickCountLow      ; <span class="comment">//+0x000 </span></li><li><span class="datatypes">ULONG</span> TickCountMultiplier  ; <span class="comment">//+0x004 </span></li><li class="alt">KSYSTEM_TIME InterruptTime     ; <span class="comment">//+0x008 </span></li><li>KSYSTEM_TIME SystemTime        ; <span class="comment">//+0x014 </span></li><li class="alt">KSYSTEM_TIME TimeZoneBias      ; <span class="comment">//+0x020 </span></li><li><span class="datatypes">USHORT</span> ImageNumberLow    ; <span class="comment">//+0x02c </span></li><li class="alt"><span class="datatypes">USHORT</span> ImageNumberHigh   ; <span class="comment">//+0x02e </span></li><li> <span class="datatypes">USHORT</span> NtSystemRoot [260]     ; <span class="comment">//+0x030 </span></li><li class="alt"><span class="datatypes">ULONG</span> MaxStackTraceDepth  ; <span class="comment">//+0x238 </span></li><li><span class="datatypes">ULONG</span> CryptoExponent    ; <span class="comment">//+0x23c </span></li><li class="alt"><span class="datatypes">ULONG</span> TimeZoneId        ; <span class="comment">//+0x240 </span></li><li><span class="datatypes">ULONG</span> Reserved2[8]          ; <span class="comment">//+0x244 </span></li><li class="alt">NT_PRODUCT_TYPE NtProductType     ; <span class="comment">//+0x264 </span></li><li><span class="datatypes">UCHAR</span> ProductTypeIsValid  ; <span class="comment">//+0x268 </span></li><li class="alt"><span class="datatypes">ULONG</span> NtMajorVersion    ; <span class="comment">//+0x26c </span></li><li><span class="datatypes">ULONG</span> NtMinorVersion    ; <span class="comment">//+0x270 </span></li><li class="alt"><span class="datatypes">UCHAR</span> ProcessorFeatures[64]   ; <span class="comment">//+0x274 </span></li><li><span class="datatypes">ULONG</span> Reserved1         ; <span class="comment">//+0x2b4 </span></li><li class="alt"><span class="datatypes">ULONG</span> Reserved3         ; <span class="comment">//+0x2b8 </span></li><li><span class="datatypes">ULONG</span> TimeSlip          ; <span class="comment">//+0x2bc </span></li><li class="alt">ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture  ; <span class="comment">//+0x2c0 </span></li><li>LARGE_INTEGER SystemExpirationDate  ; <span class="comment">//+0x2c8 </span></li><li class="alt"><span class="datatypes">ULONG</span> SuiteMask         ; <span class="comment">//+0x2d0 </span></li><li><span class="datatypes">UCHAR</span> KdDebuggerEnabled  ; <span class="comment">//+0x2d4 </span></li><li class="alt"><span class="datatypes">UCHAR</span> NXSupportPolicy   ; <span class="comment">//+0x2d5 </span></li><li><span class="datatypes">ULONG</span> ActiveConsoleId   ; <span class="comment">//+0x2d8 </span></li><li class="alt"><span class="datatypes">ULONG</span> DismountCount     ; <span class="comment">//+0x2dc </span></li><li><span class="datatypes">ULONG</span> ComPlusPackage    ; <span class="comment">//+0x2e0 </span></li><li class="alt"><span class="datatypes">ULONG</span> LastSystemRITEventTickCount  ; <span class="comment">//+0x2e4 </span></li><li><span class="datatypes">ULONG</span> NumberOfPhysicalPages  ; <span class="comment">//+0x2e8 </span></li><li class="alt"><span class="datatypes">UCHAR</span> SafeBootMode      ; <span class="comment">//+0x2ec </span></li><li><span class="datatypes">ULONG</span> TraceLogging      ; <span class="comment">//+0x2f0 </span></li><li class="alt"><span class="datatypes">ULONGLONG</span> TestRetInstruction  ; <span class="comment">//+0x2f8 </span></li><li><span class="datatypes">ULONG</span> SystemCall        ; <span class="comment">//+0x300 </span></li><li class="alt"><span class="datatypes">ULONG</span> SystemCallReturn  ; <span class="comment">//+0x304 </span></li><li><span class="datatypes">ULONGLONG</span> SystemCallPad[3]     ; <span class="comment">//+0x308 </span></li><li class="alt">KSYSTEM_TIME TickCount         ; <span class="comment">//+0x320 </span></li><li><span class="datatypes">ULONGLONG</span> TickCountQuad     ; <span class="comment">//+0x320 </span></li><li class="alt"><span class="datatypes">ULONG</span> Cookie            ; <span class="comment">//+0x330 </span></li><li>}KUSER_SHARED_DATA;</li><li class="alt"></li><li><span class="keyword">typedef</span> <span class="keyword">struct</span> _KD_PACKET</li><li class="alt">{<!-- --></li><li>  <span class="datatypes">ULONG</span> PacketLeader ; </li><li class="alt">  <span class="datatypes">USHORT</span>  PacketType ; </li><li>  <span class="datatypes">USHORT</span> byteCount  ;</li><li class="alt">  <span class="datatypes">ULONG</span> PacketId  ;</li><li>  <span class="datatypes">ULONG</span> Checksum  ;</li><li class="alt">}KD_PACKET;</li><li></li><li class="alt"></li><li></li><li class="alt"><span class="keyword">typedef</span> <span class="keyword">struct</span> _DBGKD_DEBUG_IO</li><li>{<!-- --></li><li class="alt">    <span class="datatypes">ULONG</span> ApiNumber;</li><li>    <span class="datatypes">USHORT</span> ProcessorLevel;</li><li class="alt">    <span class="datatypes">USHORT</span> Processor;</li><li>    <span class="keyword">union</span></li><li class="alt">    {<!-- --></li><li>        DBGKD_PRINT_STRING PrintString;</li><li class="alt">        DBGKD_GET_STRING GetString;</li><li>    } u;</li><li class="alt">} DBGKD_DEBUG_IO, *PDBGKD_DEBUG_IO;</li><li></li><li class="alt"><span class="keyword">typedef</span> <span class="keyword">struct</span> _DBGKD_WAIT_STATE_CHANGE64</li><li>{<!-- --></li><li class="alt">    <span class="datatypes">ULONG</span> NewState;</li><li>    <span class="datatypes">USHORT</span> ProcessorLevel;</li><li class="alt">    <span class="datatypes">USHORT</span> Processor;</li><li>    <span class="datatypes">ULONG</span> NumberProcessors;</li><li class="alt">    <span class="datatypes">ULONG64</span> Thread;</li><li>    <span class="datatypes">ULONG64</span> ProgramCounter;</li><li class="alt">    <span class="keyword">union</span></li><li>    {<!-- --></li><li class="alt">        DBGKM_EXCEPTION64 Exception;</li><li>        DBGKD_LOAD_SYMBOLS64 LoadSymbols;</li><li class="alt">    } u;</li><li>    DBGKD_CONTROL_REPORT ControlReport;</li><li class="alt">    CONTEXT Context;</li><li>} DBGKD_WAIT_STATE_CHANGE64, *PDBGKD_WAIT_STATE_CHANGE64;</li><li class="alt"></li><li></li><li class="alt"> <span class="comment">// </span></li><li> <span class="comment">// If the packet type is PACKET_TYPE_KD_FILE_IO, then </span></li><li class="alt"> <span class="comment">// the format of the packet data is as follows: </span></li><li> <span class="comment">// </span></li><li class="alt"><span class="preprocessor"> #define DbgKdCreateFileApi 0x00003430L </span></li><li><span class="preprocessor"> #define DbgKdReadFileApi 0x00003431L </span></li><li class="alt"><span class="preprocessor"> #define DbgKdWriteFileApi 0x00003432L </span></li><li><span class="preprocessor"> #define DbgKdCloseFileApi 0x00003433L </span></li><li class="alt"></li><li> <span class="comment">// Unicode filename follows as additional data. </span></li><li class="alt"> <span class="keyword">typedef</span> <span class="keyword">struct</span> _DBGKD_CREATE_FILE {<!-- --></li><li>  <span class="datatypes">ULONG</span> DesiredAccess;</li><li class="alt">  <span class="datatypes">ULONG</span> FileAttributes;</li><li>  <span class="datatypes">ULONG</span> ShareAccess;</li><li class="alt">  <span class="datatypes">ULONG</span> CreateDisposition;</li><li>  <span class="datatypes">ULONG</span> CreateOptions;</li><li class="alt">  <span class="comment">// Return values. </span></li><li>  <span class="datatypes">ULONG64</span> Handle;</li><li class="alt">  <span class="datatypes">ULONG64</span> Length;</li><li> } DBGKD_CREATE_FILE, *PDBGKD_CREATE_FILE;</li><li class="alt"></li><li> <span class="comment">// Data is returned as additional data in the response. </span></li><li class="alt"> <span class="keyword">typedef</span> <span class="keyword">struct</span> _DBGKD_READ_FILE {<!-- --></li><li>  <span class="datatypes">ULONG64</span> Handle;</li><li class="alt">  <span class="datatypes">ULONG64</span> Offset;</li><li>  <span class="datatypes">ULONG</span> Length;</li><li class="alt"> } DBGKD_READ_FILE, *PDBGKD_READ_FILE;</li><li></li><li class="alt"> <span class="comment">// Data is given as additional data. </span></li><li> <span class="keyword">typedef</span> <span class="keyword">struct</span> _DBGKD_WRITE_FILE {<!-- --></li><li class="alt">  <span class="datatypes">ULONG64</span> Handle;</li><li>  <span class="datatypes">ULONG64</span> Offset;</li><li class="alt">  <span class="datatypes">ULONG</span> Length;</li><li> } DBGKD_WRITE_FILE, *PDBGKD_WRITE_FILE;</li><li class="alt"></li><li> <span class="keyword">typedef</span> <span class="keyword">struct</span> _DBGKD_CLOSE_FILE {<!-- --></li><li class="alt"> <span class="datatypes">ULONG64</span> Handle;</li><li> } DBGKD_CLOSE_FILE, *PDBGKD_CLOSE_FILE;</li><li class="alt"></li><li> <span class="keyword">typedef</span> <span class="keyword">struct</span> _DBGKD_FILE_IO {<!-- --></li><li class="alt">  <span class="datatypes">ULONG</span> ApiNumber;</li><li>  <span class="datatypes">ULONG</span> Status;</li><li class="alt">  <span class="keyword">union</span> {<!-- --></li><li>   <span class="datatypes">ULONG64</span> ReserveSpace[7];</li><li class="alt">   DBGKD_CREATE_FILE CreateFile;</li><li>   DBGKD_READ_FILE ReadFile;</li><li class="alt">   DBGKD_WRITE_FILE WriteFile;</li><li>   DBGKD_CLOSE_FILE CloseFile;</li><li class="alt">  } u;</li><li> } DBGKD_FILE_IO, *PDBGKD_FILE_IO;</li><li class="alt"></li><li></li><li class="alt"></li><li><span class="preprocessor">#define KI_USER_SHARED_DATA         0xffdf0000 </span></li><li class="alt"><span class="preprocessor">#define SharedUserData  ((KUSER_SHARED_DATA * const) KI_USER_SHARED_DATA) </span></li><li></li><li class="alt"><span class="keyword">extern</span> <span class="datatypes">BOOLEAN</span> KdDebuggerNotPresent;</li><li></li><li class="alt"><span class="datatypes">BOOLEAN</span> KdpControlCPending    = FALSE;</li><li><span class="datatypes">BOOLEAN</span> KdpControlCPressed    = FALSE;</li><li class="alt"></li><li><span class="datatypes">ULONG</span> KdpRetryCount      = 5;</li><li class="alt"><span class="datatypes">ULONG</span> KdpNumberRetries     = 5;</li><li><span class="datatypes">ULONG</span> KdpPacketIdExpected   =0;</li><li class="alt"><span class="datatypes">ULONG</span> KdpNextPacketIdToSend =0;</li><li><span class="comment">//ULONG  KdpDefaultRetries   =0; </span></li><li class="alt"><span class="comment">//-------------------------------- </span></li><li></li><li class="alt"></li><li></li><li class="alt"><span class="datatypes">ULONG</span></li><li>KdCompGetByte (</li><li class="alt">    OUT <span class="datatypes">PUCHAR</span> Input </li><li>    );</li><li class="alt"></li><li><span class="datatypes">ULONG</span></li><li class="alt">KdCompPollByte (</li><li>    OUT <span class="datatypes">PUCHAR</span> Input</li><li class="alt">    );</li><li></li><li class="alt"></li><li><span class="datatypes">VOID</span></li><li class="alt">KdCompPutByte (</li><li>    IN <span class="datatypes">UCHAR</span> Output</li><li class="alt">    );</li><li>    </li><li class="alt"></li><li><span class="datatypes">ULONG</span></li><li class="alt">KdpComputeChecksum (</li><li>    IN <span class="datatypes">PUCHAR</span> Buffer,</li><li class="alt">    IN <span class="datatypes">ULONG</span> Length</li><li>    );</li><li class="alt"></li><li><span class="datatypes">ULONG</span></li><li class="alt">KdpReceiveString (</li><li>    OUT <span class="datatypes">PCHAR</span> Destination,</li><li class="alt">    IN <span class="datatypes">ULONG</span> Length</li><li>    );</li><li class="alt"></li><li><span class="datatypes">VOID</span></li><li class="alt">KdpSendString (</li><li>    IN <span class="datatypes">PCHAR</span> Source,</li><li class="alt">    IN <span class="datatypes">ULONG</span> Length</li><li>    );</li><li class="alt"></li><li><span class="datatypes">VOID</span></li><li class="alt">KdpSendControlPacket (</li><li>    IN <span class="datatypes">USHORT</span> PacketType,</li><li class="alt">    IN <span class="datatypes">ULONG</span> PacketId OPTIONAL</li><li>    );</li><li class="alt"></li><li><span class="preprocessor">#ifdef ALLOC_PRAGMA </span></li><li class="alt"><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpComputeChecksum) </span></li><li><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReceivePacketLeader) </span></li><li class="alt"><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReceiveString) </span></li><li><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSendString) </span></li><li class="alt"><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSendControlPacket) </span></li><li><span class="preprocessor">#pragma alloc_text(PAGEKD, KdReceivePacket) </span></li><li class="alt"><span class="preprocessor">#pragma alloc_text(PAGEKD, KdSendPacket) </span></li><li><span class="preprocessor">#endif </span></li><li class="alt"></li><li></li><li class="alt"><span class="datatypes">ULONG</span></li><li>KdpComputeChecksum (</li><li class="alt">    IN <span class="datatypes">PUCHAR</span> Buffer,</li><li>    IN <span class="datatypes">ULONG</span> Length</li><li class="alt">    )</li><li></li><li class="alt"><span class="comment">/*++</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Routine Description:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    This routine computes the checksum for the string passed in.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Arguments:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    Buffer - Supplies a pointer to the string.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    Length - Supplies the length of the string.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Return Value:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    A ULONG is return as the checksum for the input string.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">--*/</span></li><li></li><li class="alt">{<!-- --></li><li></li><li class="alt">    <span class="datatypes">ULONG</span> Checksum = 0;</li><li></li><li class="alt">    <span class="keyword">while</span> (Length &gt; 0) {<!-- --></li><li>        Checksum = Checksum + (<span class="datatypes">ULONG</span>)*Buffer++;</li><li class="alt">        Length--;</li><li>    }</li><li class="alt">    <span class="keyword">return</span> Checksum;</li><li>}</li><li class="alt"></li><li><span class="datatypes">USHORT</span></li><li class="alt">KdpReceivePacketLeader (</li><li>    IN <span class="datatypes">ULONG</span> PacketType,</li><li class="alt">    OUT <span class="datatypes">PULONG</span> PacketLeader,</li><li>    IN_OUT PKD_CONTEXT KdContext OPTIONAL </li><li class="alt">    )</li><li></li><li class="alt"><span class="comment">/*++</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Routine Description:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    This routine waits for a packet header leader.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Arguments:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    PacketType - supplies the type of packet we are expecting.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    PacketLeader - supplies a pointer to a ulong variable to receive</span></li><li><span class="comment">                   packet leader UCHARs.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">Return Value:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    KDP_PACKET_RESEND - if resend is required.</span></li><li class="alt"><span class="comment">    KDP_PAKCET_TIMEOUT - if timeout.</span></li><li><span class="comment">    KDP_PACKET_RECEIVED - if packet received.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">--*/</span></li><li class="alt"></li><li>{<!-- --></li><li class="alt"></li><li>    <span class="datatypes">UCHAR</span> Input, PreviousUCHAR = 0;</li><li class="alt">    <span class="datatypes">ULONG</span> PacketId = 0;</li><li>    <span class="datatypes">ULONG</span> Index;</li><li class="alt">    <span class="datatypes">ULONG</span> ReturnCode;</li><li>    <span class="datatypes">BOOLEAN</span> BreakinDetected = FALSE;</li><li class="alt">    <span class="keyword">if</span>(KdContext)</li><li>    {<!-- --></li><li class="alt">  KdContext-&gt;BreakInRequested = BreakinDetected;</li><li> }</li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// NOTE - With all the interrupts being off, it is very hard </span></li><li class="alt">    <span class="comment">// to implement the actual timeout code. (Maybe, by reading the CMOS.) </span></li><li>    <span class="comment">// Here we use a loop count to wait about 3 seconds.  The CpGetUCHAR </span></li><li class="alt">    <span class="comment">// will return with error code = CP_GET_NODATA if it cannot find data </span></li><li>    <span class="comment">// UCHAR within 1 second. Kernel debugger's timeout period is 5 seconds. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    Index = 0;</li><li>    <span class="keyword">do</span> {<!-- --></li><li class="alt">        ReturnCode = KdCompGetByte(&amp;Input);</li><li>        </li><li class="alt">  <span class="keyword">if</span> (ReturnCode == CP_GET_NODATA) {<!-- --></li><li>            <span class="keyword">if</span> (BreakinDetected) {<!-- --></li><li class="alt">                KdpControlCPending = TRUE;</li><li>                <span class="keyword">if</span>(KdContext)</li><li class="alt">    {<!-- --></li><li>     KdContext-&gt;BreakInRequested = BreakinDetected;</li><li class="alt">    }</li><li>                <span class="keyword">return</span> KDP_PACKET_RESEND;</li><li class="alt">            } <span class="keyword">else</span> {<!-- --></li><li>    <span class="keyword">if</span>(KdContext)</li><li class="alt">    {<!-- --></li><li>     KdContext-&gt;BreakInRequested = BreakinDetected;</li><li class="alt">    }</li><li>                <span class="keyword">return</span> KDP_PACKET_TIMEOUT;</li><li class="alt">            }</li><li>        }</li><li class="alt">  <span class="keyword">else</span> <span class="keyword">if</span> (ReturnCode == CP_GET_ERROR) {<!-- --></li><li>            Index = 0;</li><li class="alt">            <span class="keyword">continue</span>;</li><li>        } </li><li class="alt">  <span class="keyword">else</span> {                    <span class="comment">// if (ReturnCode == CP_GET_SUCCESS) </span></li><li>            <span class="keyword">if</span> ( Input == PACKET_LEADER_BYTE ||</li><li class="alt">                 Input == CONTROL_PACKET_LEADER_BYTE ) {<!-- --></li><li>                <span class="keyword">if</span> ( Index == 0 ) {<!-- --></li><li class="alt">                    PreviousUCHAR = Input;</li><li>                    Index++;</li><li class="alt">                } <span class="keyword">else</span> <span class="keyword">if</span> (Input == PreviousUCHAR ) {<!-- --></li><li>                    Index++;</li><li class="alt">                } <span class="keyword">else</span> {<!-- --></li><li>                    PreviousUCHAR = Input;</li><li class="alt">                    Index = 1;</li><li>                }</li><li class="alt">            } <span class="keyword">else</span> {<!-- --></li><li></li><li class="alt">                <span class="comment">// </span></li><li>                <span class="comment">// If we detect breakin character, we need to verify it </span></li><li class="alt">                <span class="comment">// validity.  (It is possible that we missed a packet leader </span></li><li>                <span class="comment">// and the breakin character is simply a data UCHAR in the </span></li><li class="alt">                <span class="comment">// packet.) </span></li><li>                <span class="comment">// Since kernel debugger send out breakin character ONLY </span></li><li class="alt">                <span class="comment">// when it is waiting for State Change packet.  The breakin </span></li><li>                <span class="comment">// character should not be followed by any other character </span></li><li class="alt">                <span class="comment">// except packet leader UCHAR. </span></li><li>                <span class="comment">// </span></li><li class="alt"></li><li>                <span class="keyword">if</span> ( Input == BREAKIN_PACKET_BYTE) {<!-- --></li><li class="alt">                    BreakinDetected = TRUE;</li><li>                   </li><li class="alt">                } <span class="keyword">else</span> {<!-- --></li><li></li><li class="alt">                    <span class="comment">// </span></li><li>                    <span class="comment">// The following statement is ABSOLUTELY necessary. </span></li><li class="alt">                    <span class="comment">// </span></li><li></li><li class="alt">                    BreakinDetected = FALSE;</li><li>                  </li><li class="alt">                }</li><li>                Index = 0;</li><li class="alt">            }</li><li>        }</li><li class="alt">    } <span class="keyword">while</span> ( Index &lt; 4 );</li><li></li><li class="alt">    <span class="keyword">if</span> (BreakinDetected) {<!-- --></li><li>        KdpControlCPending = TRUE;</li><li class="alt">    }</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// return the packet leader and FALSE to indicate no resend is needed. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    <span class="keyword">if</span> ( Input == PACKET_LEADER_BYTE ) {<!-- --></li><li>        *PacketLeader = PACKET_LEADER;</li><li class="alt">    } <span class="keyword">else</span> {<!-- --></li><li>        *PacketLeader = CONTROL_PACKET_LEADER;</li><li class="alt">    }</li><li></li><li class="alt">   <span class="keyword">if</span>(KdContext)</li><li>   {<!-- --></li><li class="alt">     KdContext-&gt;BreakInRequested = BreakinDetected;</li><li>  }</li><li class="alt">  </li><li>    KdDebuggerNotPresent = FALSE;</li><li class="alt">    SharedUserData-&gt;KdDebuggerEnabled |= 0x00000002;</li><li>    <span class="keyword">return</span> KDP_PACKET_RECEIVED;</li><li class="alt">}</li><li></li><li class="alt"><span class="datatypes">ULONG</span></li><li>KdpReceiveString (</li><li class="alt">    OUT <span class="datatypes">PCHAR</span> Destination,</li><li>    IN <span class="datatypes">ULONG</span> Length</li><li class="alt">    )</li><li></li><li class="alt"><span class="comment">/*++</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Routine Description:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    This routine reads a string from the kernel debugger port.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Arguments:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    Destination - Supplies a pointer to the input string.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    Length - Supplies the length of the string to be read.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Return Value:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    CP_GET_SUCCESS is returned if string is successfully read from the</span></li><li><span class="comment">        kernel debugger line.</span></li><li class="alt"><span class="comment">    CP_GET_ERROR is returned if error encountered during reading.</span></li><li><span class="comment">    CP_GET_NODATA is returned if timeout.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">--*/</span></li><li class="alt"></li><li>{<!-- --></li><li class="alt"></li><li>    <span class="datatypes">UCHAR</span> Input;</li><li class="alt">    <span class="datatypes">ULONG</span> ReturnCode;</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// Read UCHARs until either a error is encountered or the entire string </span></li><li class="alt">    <span class="comment">// has been read. </span></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="keyword">while</span> (Length &gt; 0) {<!-- --></li><li>        ReturnCode = KdCompGetByte(&amp;Input);</li><li class="alt">        <span class="keyword">if</span> (ReturnCode != CP_GET_SUCCESS) {<!-- --></li><li>            <span class="keyword">return</span> ReturnCode;</li><li class="alt">        } <span class="keyword">else</span> {<!-- --></li><li>            *Destination++ = Input;</li><li class="alt">            Length -= 1;</li><li>        }</li><li class="alt">    }</li><li>    <span class="keyword">return</span> CP_GET_SUCCESS;</li><li class="alt">}</li><li></li><li class="alt"><span class="datatypes">VOID</span></li><li>KdpSendString (</li><li class="alt">    IN <span class="datatypes">PCHAR</span> Source,</li><li>    IN <span class="datatypes">ULONG</span> Length</li><li class="alt">    )</li><li></li><li class="alt"><span class="comment">/*++</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Routine Description:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    This routine writes a string to the kernel debugger port.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Arguments:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    Source - Supplies a pointer to the output string.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    Length - Supplies the length of the string to be written.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Return Value:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    None.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">--*/</span></li><li></li><li class="alt">{<!-- --></li><li></li><li class="alt">    <span class="datatypes">UCHAR</span> Output;</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// Write UCHARs to the kernel debugger port. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    <span class="keyword">while</span> (Length &gt; 0) {<!-- --></li><li>        Output = *Source++;</li><li class="alt">        KdCompPutByte(Output);</li><li>        Length -= 1;</li><li class="alt">    }</li><li>    <span class="keyword">return</span>;</li><li class="alt">}</li><li></li><li class="alt"><span class="datatypes">VOID</span></li><li>KdpSendControlPacket (</li><li class="alt">    IN <span class="datatypes">USHORT</span> PacketType,</li><li>    IN <span class="datatypes">ULONG</span> PacketId OPTIONAL</li><li class="alt">    )</li><li></li><li class="alt"><span class="comment">/*++</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Routine Description:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    This routine sends a control packet to the host machine that is running the</span></li><li><span class="comment">    kernel debugger and waits for an ACK.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">Arguments:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    PacketType - Supplies the type of packet to send.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    PacketId - Supplies packet id, optionally.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">Return Value:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    None.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">--*/</span></li><li class="alt"></li><li>{<!-- --></li><li class="alt"></li><li>    KD_PACKET PacketHeader;</li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">// Initialize and send the packet header. </span></li><li>    <span class="comment">// </span></li><li class="alt"></li><li>    PacketHeader.PacketLeader = CONTROL_PACKET_LEADER;</li><li class="alt">    <span class="keyword">if</span> (ARGUMENT_PRESENT( (<span class="datatypes">PVOID</span>)(<span class="datatypes">ULONG_PTR</span>) PacketId )) {<!-- --></li><li>        PacketHeader.PacketId = PacketId;</li><li class="alt">    }</li><li>    PacketHeader.byteCount = 0;</li><li class="alt">    PacketHeader.Checksum = 0;</li><li>    PacketHeader.PacketType = PacketType;</li><li class="alt">    KdpSendString((<span class="datatypes">PCHAR</span>)&amp;PacketHeader, <span class="keyword">sizeof</span>(KD_PACKET));</li><li></li><li class="alt">    <span class="keyword">return</span>;</li><li>}</li><li class="alt"></li><li><span class="datatypes">ULONG</span></li><li class="alt">KdReceivePacket (</li><li>    IN <span class="datatypes">ULONG</span> PacketType,</li><li class="alt">    OUT PSTRING MessageHeader,</li><li>    OUT PSTRING MessageData,</li><li class="alt">    OUT <span class="datatypes">PULONG</span> DataLength,</li><li>    IN_OUT PKD_CONTEXT KdContext OPTIONAL</li><li class="alt"></li><li>    )</li><li class="alt"></li><li><span class="comment">/*++</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">Routine Description:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    This routine receives a packet from the host machine that is running</span></li><li class="alt"><span class="comment">    the kernel debugger UI.  This routine is ALWAYS called after packet being</span></li><li><span class="comment">    sent by caller.  It first waits for ACK packet for the packet sent and</span></li><li class="alt"><span class="comment">    then waits for the packet desired.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    N.B. If caller is KdPrintString, the parameter PacketType is</span></li><li><span class="comment">       PACKET_TYPE_KD_ACKNOWLEDGE.  In this case, this routine will return</span></li><li class="alt"><span class="comment">       right after the ack packet is received.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Arguments:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    PacketType - Supplies the type of packet that is excepted.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    MessageHeader - Supplies a pointer to a string descriptor for the input</span></li><li><span class="comment">        message.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    MessageData - Supplies a pointer to a string descriptor for the input data.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    DataLength - Supplies pointer to ULONG to receive length of recv. data.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">Return Value:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    KDP_PACKET_RESEND - if resend is required.</span></li><li class="alt"><span class="comment">    KDP_PAKCET_TIMEOUT - if timeout.</span></li><li><span class="comment">    KDP_PACKET_RECEIVED - if packet received.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">--*/</span></li><li class="alt"></li><li>{<!-- --></li><li class="alt"></li><li>    <span class="datatypes">UCHAR</span> Input;</li><li class="alt">    <span class="datatypes">ULONG</span> MessageLength;</li><li>    KD_PACKET PacketHeader;</li><li class="alt">    <span class="datatypes">ULONG</span> ReturnCode;</li><li>    <span class="datatypes">ULONG</span> Checksum;</li><li class="alt"></li><li> <span class="keyword">if</span>(PacketType==PACKET_TYPE_KD_POLL_BREAKIN)</li><li class="alt"> {<!-- --></li><li>  ReturnCode= KdCompPollByte(&amp;Input);</li><li class="alt">  <span class="keyword">if</span>(ReturnCode==CP_GET_SUCCESS &amp;&amp; BREAKIN_PACKET_BYTE==Input)</li><li>  {<!-- --></li><li class="alt">   <span class="keyword">return</span> KDP_PACKET_RECEIVED;</li><li>  }</li><li class="alt">  <span class="keyword">else</span></li><li>  {<!-- --></li><li class="alt">   <span class="keyword">return</span> KDP_PACKET_TIMEOUT;</li><li>  }</li><li class="alt"> }</li><li></li><li class="alt">WaitForPacketLeader:</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// Read Packet Leader </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    ReturnCode = KdpReceivePacketLeader(PacketType, &amp;PacketHeader.PacketLeader,KdContext);</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// If we can successfully read packet leader, it has high possibility that </span></li><li class="alt">    <span class="comment">// kernel debugger is alive.  So reset count. </span></li><li>    <span class="comment">// </span></li><li class="alt"></li><li>    <span class="keyword">if</span> (ReturnCode != KDP_PACKET_TIMEOUT) {<!-- --></li><li class="alt">        KdpNumberRetries = KdpRetryCount;</li><li>    }</li><li class="alt">    <span class="keyword">if</span> (ReturnCode != KDP_PACKET_RECEIVED) {<!-- --></li><li>        <span class="keyword">return</span> ReturnCode;</li><li class="alt">    }</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// Read packet type. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    ReturnCode = KdpReceiveString((<span class="datatypes">PCHAR</span>)&amp;PacketHeader.PacketType,</li><li>                                  <span class="keyword">sizeof</span>(PacketHeader.PacketType));</li><li class="alt">    <span class="keyword">if</span> (ReturnCode == CP_GET_NODATA) {<!-- --></li><li>        <span class="keyword">return</span> KDP_PACKET_TIMEOUT;</li><li class="alt">    } <span class="keyword">else</span> <span class="keyword">if</span> (ReturnCode == CP_GET_ERROR) {<!-- --></li><li>        <span class="keyword">if</span> (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {<!-- --></li><li class="alt"></li><li>            <span class="comment">// </span></li><li class="alt">            <span class="comment">// If read error and it is for a control packet, simply </span></li><li>            <span class="comment">// preptend that we have not seen this packet.  Hopefully </span></li><li class="alt">            <span class="comment">// we will receive the packet we desire which automatically acks </span></li><li>            <span class="comment">// the packet we just sent. </span></li><li class="alt">            <span class="comment">// </span></li><li></li><li class="alt">            <span class="keyword">goto</span> WaitForPacketLeader;</li><li>        } <span class="keyword">else</span> {<!-- --></li><li class="alt"></li><li>            <span class="comment">// </span></li><li class="alt">            <span class="comment">// if read error while reading data packet, we have to ask </span></li><li>            <span class="comment">// kernel debugger to resend us the packet. </span></li><li class="alt">            <span class="comment">// </span></li><li></li><li class="alt">            <span class="keyword">goto</span> SendResendPacket;</li><li>        }</li><li class="alt">    }</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// if the packet we received is a resend request, we return true and </span></li><li class="alt">    <span class="comment">// let caller resend the packet. </span></li><li>    <span class="comment">// </span></li><li class="alt"></li><li>    <span class="keyword">if</span> ( PacketHeader.PacketLeader == CONTROL_PACKET_LEADER &amp;</li><li class="alt">         PacketHeader.PacketType == PACKET_TYPE_KD_RESEND ) {<!-- --></li><li>        <span class="keyword">return</span> KDP_PACKET_RESEND;</li><li class="alt">    }</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// Read data length. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    ReturnCode = KdpReceiveString((<span class="datatypes">PCHAR</span>)&amp;PacketHeader.byteCount,</li><li>                                  <span class="keyword">sizeof</span>(PacketHeader.byteCount));</li><li class="alt">    <span class="keyword">if</span> (ReturnCode == CP_GET_NODATA) {<!-- --></li><li>        <span class="keyword">return</span> KDP_PACKET_TIMEOUT;</li><li class="alt">    } <span class="keyword">else</span> <span class="keyword">if</span> (ReturnCode == CP_GET_ERROR) {<!-- --></li><li>        <span class="keyword">if</span> (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {<!-- --></li><li class="alt">            <span class="keyword">goto</span> WaitForPacketLeader;</li><li>        } <span class="keyword">else</span> {<!-- --></li><li class="alt">            <span class="keyword">goto</span> SendResendPacket;</li><li>        }</li><li class="alt">    }</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// Read Packet Id. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    ReturnCode = KdpReceiveString((<span class="datatypes">PCHAR</span>)&amp;PacketHeader.PacketId,</li><li>                                  <span class="keyword">sizeof</span>(PacketHeader.PacketId));</li><li class="alt"></li><li>    <span class="keyword">if</span> (ReturnCode == CP_GET_NODATA) {<!-- --></li><li class="alt">        <span class="keyword">return</span> KDP_PACKET_TIMEOUT;</li><li>    } <span class="keyword">else</span> <span class="keyword">if</span> (ReturnCode == CP_GET_ERROR) {<!-- --></li><li class="alt">        <span class="keyword">if</span> (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {<!-- --></li><li>            <span class="keyword">goto</span> WaitForPacketLeader;</li><li class="alt">        } <span class="keyword">else</span> {<!-- --></li><li>            <span class="keyword">goto</span> SendResendPacket;</li><li class="alt">        }</li><li>    }</li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">// Read packet checksum. </span></li><li>    <span class="comment">// </span></li><li class="alt"></li><li>    ReturnCode = KdpReceiveString((<span class="datatypes">PCHAR</span>)&amp;PacketHeader.Checksum,</li><li class="alt">                                  <span class="keyword">sizeof</span>(PacketHeader.Checksum));</li><li>    <span class="keyword">if</span> (ReturnCode == CP_GET_NODATA) {<!-- --></li><li class="alt">        <span class="keyword">return</span> KDP_PACKET_TIMEOUT;</li><li>    } <span class="keyword">else</span> <span class="keyword">if</span> (ReturnCode == CP_GET_ERROR) {<!-- --></li><li class="alt">        <span class="keyword">if</span> (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {<!-- --></li><li>            <span class="keyword">goto</span> WaitForPacketLeader;</li><li class="alt">        } <span class="keyword">else</span> {<!-- --></li><li>            <span class="keyword">goto</span> SendResendPacket;</li><li class="alt">        }</li><li>    }</li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">// A complete packet header is received.  Check its validity and </span></li><li>    <span class="comment">// perform appropriate action depending on packet type. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    <span class="keyword">if</span> (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER ) {<!-- --></li><li>        <span class="keyword">if</span> (PacketHeader.PacketType == PACKET_TYPE_KD_ACKNOWLEDGE <span class="comment">/*4*/</span>) {<!-- --></li><li class="alt"></li><li>            <span class="comment">// </span></li><li class="alt">            <span class="comment">// If we received an expected ACK packet and we are not </span></li><li>            <span class="comment">// waiting for any new packet, update outgoing packet id </span></li><li class="alt">            <span class="comment">// and return.  If we are NOT waiting for ACK packet </span></li><li>            <span class="comment">// we will keep on waiting.  If the ACK packet </span></li><li class="alt">            <span class="comment">// is not for the packet we send, ignore it and keep on waiting. </span></li><li>            <span class="comment">// </span></li><li class="alt"></li><li>            <span class="keyword">if</span> (PacketHeader.PacketId !=</li><li class="alt">                (KdpNextPacketIdToSend &amp; ~SYNC_PACKET_ID))  {<!-- --></li><li>                <span class="keyword">goto</span> WaitForPacketLeader;</li><li class="alt">            } <span class="keyword">else</span> <span class="keyword">if</span> (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {<!-- --></li><li>                KdpNextPacketIdToSend ^= 1;</li><li class="alt">                <span class="keyword">return</span> KDP_PACKET_RECEIVED;</li><li>            } <span class="keyword">else</span> {<!-- --></li><li class="alt">                <span class="keyword">goto</span> WaitForPacketLeader;</li><li>            }</li><li class="alt">        } <span class="keyword">else</span> <span class="keyword">if</span> (PacketHeader.PacketType == PACKET_TYPE_KD_RESET<span class="comment">/*6*/</span>) {<!-- --></li><li></li><li class="alt">            <span class="comment">// </span></li><li>            <span class="comment">// if we received Reset packet, reset the packet control variables </span></li><li class="alt">            <span class="comment">// and resend earlier packet. </span></li><li>            <span class="comment">// </span></li><li class="alt"></li><li>            KdpNextPacketIdToSend = INITIAL_PACKET_ID;</li><li class="alt">            KdpPacketIdExpected = INITIAL_PACKET_ID;</li><li>            KdpSendControlPacket(PACKET_TYPE_KD_RESET, 0L);</li><li class="alt">            <span class="keyword">return</span> KDP_PACKET_RESEND;</li><li>        } <span class="keyword">else</span> <span class="keyword">if</span> (PacketHeader.PacketType == PACKET_TYPE_KD_RESEND<span class="comment">/*5*/</span>) {<!-- --></li><li class="alt">            <span class="keyword">return</span> KDP_PACKET_RESEND;</li><li>        } <span class="keyword">else</span> {<!-- --></li><li class="alt"></li><li>            <span class="comment">// </span></li><li class="alt">            <span class="comment">// Invalid packet header, ignore it. </span></li><li>            <span class="comment">// </span></li><li class="alt"></li><li>            <span class="keyword">goto</span> WaitForPacketLeader;</li><li class="alt">        }</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// The packet header is for data packet (not control packet). </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    } <span class="keyword">else</span> <span class="keyword">if</span> (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {<!-- --></li><li></li><li class="alt">        <span class="comment">// </span></li><li>        <span class="comment">// if we are waiting for ACK packet ONLY </span></li><li class="alt">        <span class="comment">// and we receive a data packet header, check if the packet id </span></li><li>        <span class="comment">// is what we expected.  If yes, assume the acknowledge is lost (but </span></li><li class="alt">        <span class="comment">// sent), ask sender to resend and return with PACKET_RECEIVED. </span></li><li>        <span class="comment">// </span></li><li class="alt"></li><li>        <span class="keyword">if</span> (PacketHeader.PacketId == KdpPacketIdExpected) {<!-- --></li><li class="alt">            KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);</li><li>            KdpNextPacketIdToSend ^= 1;</li><li class="alt">            <span class="keyword">return</span> KDP_PACKET_RECEIVED;</li><li>        } <span class="keyword">else</span> {<!-- --></li><li class="alt">            KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,</li><li>                                 PacketHeader.PacketId</li><li class="alt">                                 );</li><li>            <span class="keyword">goto</span> WaitForPacketLeader;</li><li class="alt">        }</li><li>    }</li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">// we are waiting for data packet and we received the packet header </span></li><li>    <span class="comment">// for data packet. Perform the following checkings to make sure </span></li><li class="alt">    <span class="comment">// it is the packet we are waiting for. </span></li><li>    <span class="comment">// </span></li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">// Check byteCount received is valid </span></li><li>    <span class="comment">// </span></li><li class="alt"></li><li>    MessageLength = MessageHeader-&gt;MaximumLength;</li><li class="alt">    <span class="keyword">if</span> ((PacketHeader.byteCount &gt; (<span class="datatypes">USHORT</span>)PACKET_MAX_SIZE) ||</li><li>        (PacketHeader.byteCount &lt; (<span class="datatypes">USHORT</span>)MessageLength)) {<!-- --></li><li class="alt">        <span class="keyword">goto</span> SendResendPacket;</li><li>    }</li><li class="alt">    *DataLength = PacketHeader.byteCount - MessageLength;</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// Read the message header. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    ReturnCode = KdpReceiveString(MessageHeader-&gt;Buffer, MessageLength);</li><li>    <span class="keyword">if</span> (ReturnCode != CP_GET_SUCCESS) {<!-- --></li><li class="alt">        <span class="keyword">goto</span> SendResendPacket;</li><li>    }</li><li class="alt">    MessageHeader-&gt;Length = (<span class="datatypes">USHORT</span>)MessageLength;</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// Read the message data. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    ReturnCode = KdpReceiveString(MessageData-&gt;Buffer, *DataLength);</li><li>    <span class="keyword">if</span> (ReturnCode != CP_GET_SUCCESS) {<!-- --></li><li class="alt">        <span class="keyword">goto</span> SendResendPacket;</li><li>    }</li><li class="alt">    MessageData-&gt;Length = (<span class="datatypes">USHORT</span>)*DataLength;</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// Read packet trailing byte </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    ReturnCode = KdCompGetByte(&amp;Input);</li><li>    <span class="keyword">if</span> (ReturnCode != CP_GET_SUCCESS || Input != PACKET_TRAILING_BYTE<span class="comment">/*0AAh*/</span>) {<!-- --></li><li class="alt">        <span class="keyword">goto</span> SendResendPacket;</li><li>    }</li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">// Check PacketType is what we are waiting for. </span></li><li>    <span class="comment">// </span></li><li class="alt"></li><li>    <span class="keyword">if</span> (PacketType != PacketHeader.PacketType) {<!-- --></li><li class="alt">        KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,</li><li>                             PacketHeader.PacketId</li><li class="alt">                             );</li><li>        <span class="keyword">goto</span> WaitForPacketLeader;</li><li class="alt">    }</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// Check PacketId is valid. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    <span class="keyword">if</span> (PacketHeader.PacketId == INITIAL_PACKET_ID ||</li><li>        PacketHeader.PacketId == (INITIAL_PACKET_ID ^ 1)) {<!-- --></li><li class="alt">        <span class="keyword">if</span> (PacketHeader.PacketId != KdpPacketIdExpected) {<!-- --></li><li>            KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,</li><li class="alt">                                 PacketHeader.PacketId</li><li>                                 );</li><li class="alt">            <span class="keyword">goto</span> WaitForPacketLeader;</li><li>        }</li><li class="alt">    } <span class="keyword">else</span> {<!-- --></li><li>        <span class="keyword">goto</span> SendResendPacket;</li><li class="alt">    }</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// Check checksum is valid. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    Checksum = KdpComputeChecksum(</li><li>                            MessageHeader-&gt;Buffer,</li><li class="alt">                            MessageHeader-&gt;Length</li><li>                            );</li><li class="alt"></li><li>    Checksum += KdpComputeChecksum(</li><li class="alt">                            MessageData-&gt;Buffer,</li><li>                            MessageData-&gt;Length</li><li class="alt">                            );</li><li>    <span class="keyword">if</span> (Checksum != PacketHeader.Checksum) {<!-- --></li><li class="alt">        <span class="keyword">goto</span> SendResendPacket;</li><li>    }</li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">// Send Acknowledge UCHAR and the Id of the packet received. </span></li><li>    <span class="comment">// Then, update the ExpectId for next incoming packet. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,</li><li>                         PacketHeader.PacketId</li><li class="alt">                         );</li><li></li><li class="alt">    <span class="comment">// </span></li><li>    <span class="comment">// We have successfully received the packet so update the </span></li><li class="alt">    <span class="comment">// packet control variables and return sucess. </span></li><li>    <span class="comment">// </span></li><li class="alt"></li><li>    KdpPacketIdExpected ^= 1;</li><li class="alt">    <span class="keyword">return</span> KDP_PACKET_RECEIVED;</li><li></li><li class="alt">SendResendPacket:</li><li>    KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);</li><li class="alt">    <span class="keyword">goto</span> WaitForPacketLeader;</li><li>}</li><li class="alt"></li><li><span class="keyword">void</span></li><li class="alt">KdSendPacket (</li><li>    IN <span class="datatypes">ULONG</span> PacketType,</li><li class="alt">    IN PSTRING MessageHeader,</li><li>    IN PSTRING MessageData OPTIONAL,</li><li class="alt">    IN_OUT PKD_CONTEXT KdContext OPTIONAL</li><li>    )</li><li class="alt"></li><li></li><li class="alt"></li><li><span class="comment">/*++</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">Routine Description:</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    This routine sends a packet to the host machine that is running the</span></li><li class="alt"><span class="comment">    kernel debugger and waits for an ACK.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Arguments:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    PacketType - Supplies the type of packet to send.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    MessageHeader - Supplies a pointer to a string descriptor that describes</span></li><li><span class="comment">        the message information.</span></li><li class="alt"><span class="comment"></span></li><li><span class="comment">    MessageData - Supplies a pointer to a string descriptor that describes</span></li><li class="alt"><span class="comment">        the optional message data.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">Return Value:</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">    None.</span></li><li><span class="comment"></span></li><li class="alt"><span class="comment">--*/</span></li><li></li><li class="alt">{<!-- --></li><li></li><li class="alt">    KD_PACKET PacketHeader;</li><li>    <span class="datatypes">ULONG</span> MessageDataLength;</li><li class="alt">    <span class="datatypes">ULONG</span> ReturnCode;</li><li>    PDBGKD_DEBUG_IO DebugIo;</li><li class="alt"> PDBGKD_FILE_IO  FileIo;</li><li>    PDBGKD_WAIT_STATE_CHANGE64 StateChange;</li><li class="alt"></li><li></li><li class="alt"></li><li>    <span class="keyword">if</span> ( ARGUMENT_PRESENT(MessageData) ) {<!-- --></li><li class="alt">        MessageDataLength = MessageData-&gt;Length;</li><li>        PacketHeader.Checksum = KdpComputeChecksum(</li><li class="alt">                                        MessageData-&gt;Buffer,</li><li>                                        MessageData-&gt;Length</li><li class="alt">                                        );</li><li>    } <span class="keyword">else</span> {<!-- --></li><li class="alt">        MessageDataLength = 0;</li><li>        PacketHeader.Checksum = 0;</li><li class="alt">    }</li><li></li><li class="alt">    PacketHeader.Checksum += KdpComputeChecksum (</li><li>                                    MessageHeader-&gt;Buffer,</li><li class="alt">                                    MessageHeader-&gt;Length</li><li>                                    );</li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">// Initialize and send the packet header. </span></li><li>    <span class="comment">// </span></li><li class="alt"></li><li>    PacketHeader.PacketLeader = PACKET_LEADER;</li><li class="alt">    PacketHeader.byteCount = (<span class="datatypes">USHORT</span>)(MessageHeader-&gt;Length + MessageDataLength);</li><li>    PacketHeader.PacketType = (<span class="datatypes">USHORT</span>)PacketType;</li><li class="alt">    KdpNumberRetries = KdpRetryCount;</li><li>    <span class="keyword">do</span> {<!-- --></li><li class="alt">        <span class="keyword">if</span> (KdpNumberRetries == 0) {<!-- --></li><li></li><li class="alt">            <span class="comment">// </span></li><li>            <span class="comment">// If the packet is not for reporting exception, we give up </span></li><li class="alt">            <span class="comment">// and declare debugger not present. </span></li><li>            <span class="comment">// </span></li><li class="alt"></li><li>            <span class="keyword">if</span> (PacketType == PACKET_TYPE_KD_DEBUG_IO) {<!-- --></li><li class="alt">                DebugIo = (PDBGKD_DEBUG_IO)MessageHeader-&gt;Buffer;</li><li>                <span class="keyword">if</span> (DebugIo-&gt;ApiNumber == DbgKdPrintStringApi) {<!-- --></li><li class="alt">                    KdDebuggerNotPresent = TRUE;</li><li>                    SharedUserData-&gt;KdDebuggerEnabled &amp;= ~0x00000002;</li><li class="alt">                    KdpNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;<span class="comment">//80800000|0800h </span></li><li>                    KdpPacketIdExpected = INITIAL_PACKET_ID; <span class="comment">//80800000h </span></li><li class="alt">                    <span class="keyword">return</span>;</li><li>                }</li><li class="alt">            } <span class="keyword">else</span> <span class="keyword">if</span> (PacketType == PACKET_TYPE_KD_STATE_CHANGE64) {<!-- --></li><li>                StateChange = (PDBGKD_WAIT_STATE_CHANGE64)MessageHeader-&gt;Buffer;</li><li class="alt">                <span class="keyword">if</span> (StateChange-&gt;NewState == DbgKdLoadSymbolsStateChange) {<!-- --></li><li>                    KdDebuggerNotPresent = TRUE;</li><li class="alt">                    SharedUserData-&gt;KdDebuggerEnabled &amp;= ~0x00000002;</li><li>                    KdpNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;</li><li class="alt">                    KdpPacketIdExpected = INITIAL_PACKET_ID;</li><li>                    <span class="keyword">return</span>;</li><li class="alt">                }</li><li>            }</li><li class="alt">   <span class="keyword">else</span> <span class="keyword">if</span> (PacketType == PACKET_TYPE_KD_FILE_IO)</li><li>   {<!-- --></li><li class="alt">    FileIo = (PDBGKD_FILE_IO)MessageHeader-&gt;Buffer;</li><li>    <span class="keyword">if</span> (FileIo-&gt;ApiNumber== DbgKdCreateFileApi) {<!-- --></li><li class="alt">                    KdDebuggerNotPresent = TRUE;</li><li>                    SharedUserData-&gt;KdDebuggerEnabled &amp;= ~0x00000002;</li><li class="alt">                    KdpNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;</li><li>                    KdpPacketIdExpected = INITIAL_PACKET_ID;</li><li class="alt">                    <span class="keyword">return</span>;</li><li>                }</li><li class="alt">   }</li><li>        }</li><li class="alt"></li><li>        <span class="comment">// </span></li><li class="alt">        <span class="comment">// Setting PacketId has to be in the do loop in case Packet Id was </span></li><li>        <span class="comment">// reset. </span></li><li class="alt">        <span class="comment">// </span></li><li></li><li class="alt">        PacketHeader.PacketId = KdpNextPacketIdToSend;</li><li>        KdpSendString((<span class="datatypes">PCHAR</span>)&amp;PacketHeader, <span class="keyword">sizeof</span>(KD_PACKET));</li><li class="alt"></li><li>        <span class="comment">// </span></li><li class="alt">        <span class="comment">// Output message header. </span></li><li>        <span class="comment">// </span></li><li class="alt"></li><li>        KdpSendString(MessageHeader-&gt;Buffer, MessageHeader-&gt;Length);</li><li class="alt"></li><li>        <span class="comment">// </span></li><li class="alt">        <span class="comment">// Output message data. </span></li><li>        <span class="comment">// </span></li><li class="alt"></li><li>        <span class="keyword">if</span> ( MessageDataLength ) {<!-- --></li><li class="alt">            KdpSendString(MessageData-&gt;Buffer, MessageData-&gt;Length);</li><li>        }</li><li class="alt"></li><li>        <span class="comment">// </span></li><li class="alt">        <span class="comment">// Output a packet trailing UCHAR </span></li><li>        <span class="comment">// </span></li><li class="alt"></li><li>        KdCompPutByte(PACKET_TRAILING_BYTE);</li><li class="alt"></li><li>        <span class="comment">// </span></li><li class="alt">        <span class="comment">// Wait for the Ack Packet </span></li><li>        <span class="comment">// </span></li><li class="alt"></li><li>        ReturnCode = KdReceivePacket(</li><li class="alt">                         PACKET_TYPE_KD_ACKNOWLEDGE,</li><li>                         NULL,</li><li class="alt">                         NULL,</li><li>                         NULL,</li><li class="alt">                         KdContext</li><li>                         );</li><li class="alt">        <span class="keyword">if</span> (ReturnCode == KDP_PACKET_TIMEOUT) {<!-- --></li><li>            KdpNumberRetries--;</li><li class="alt">        }</li><li>    } <span class="keyword">while</span> (ReturnCode != KDP_PACKET_RECEIVED);</li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">// Reset Sync bit in packet id.  The packet we sent may have Sync bit set </span></li><li>    <span class="comment">// </span></li><li class="alt"></li><li>    KdpNextPacketIdToSend &amp;= ~SYNC_PACKET_ID;</li><li class="alt"></li><li>    <span class="comment">// </span></li><li class="alt">    <span class="comment">// Since we are able to talk to debugger, the retrycount is set to </span></li><li>    <span class="comment">// maximum value. </span></li><li class="alt">    <span class="comment">// </span></li><li></li><li class="alt">    KdpRetryCount = KdContext-&gt;RetryCount;</li><li>}</li><li class="alt"></li><li></li></ol></div>
<p>另给出我在网上找到的关于串口通信的资料:</p>
<p><br/> </p>
<div class="highlighter">
<ol class="highlighter-cpp"><li>Serial I/O  </li><li class="alt"></li><li>Table of Registers</li><li class="alt">--------------------------------------------------------------------------------</li><li>Base Address DLAB Read/Write  Abr.   Register Name  </li><li class="alt">+ 0   =0 Write  -   Transmitter Holding Buffer  </li><li>  =0 Read  -   Receiver Buffer  </li><li class="alt">  =1 Read/Write  -   Divisor Latch Low Byte  </li><li>+ 1   =0 Read/Write  IER   Interrupt Enable Register  </li><li class="alt">  =1 Read/Write  -   Divisor Latch High Byte  </li><li>+ 2   - Read   IIR   Interrupt Identification Register </li><li class="alt">  - Write  FCR   FIFO Control Register  </li><li>+ 3   - Read/Write  LCR   Line Control Register  </li><li class="alt">+ 4   - Read/Write  MCR   Modem Control Register  </li><li>+ 5   - Read   LSR   Line Status Register  </li><li class="alt">+ 6   - Read   MSR   Modem Status Register  </li><li>+ 7   - Read/Write  -   Scratch Register  </li><li class="alt">-------------------------------------------------------------------------------</li><li>Table 5 : Table of Registers</li><li class="alt"></li><li>DLAB ?</li><li class="alt">--------------------------------------------------------------------------------</li><li></li><li class="alt"></li><li>You will have noticed in the table of registers that there is a DLAB column. When DLAB is set to <span class="string">'0'</span> or <span class="string">'1'</span> some of the </li><li class="alt">registers change. This is how the UART is able to have 12 registers (including the scratch <span class="keyword">register</span>) through only 8 port</li><li> addresses. DLAB stands <span class="keyword">for</span> Divisor Latch Access Bit. When DLAB is set to <span class="string">'1'</span> via the line control <span class="keyword">register</span>, two registers </li><li class="alt">become available from which you can set your speed of communications measured in bits per second.</li><li></li><li class="alt">The UART will have a crystal which should oscillate around 1.8432 MHZ. The UART incorporates a divide by 16 counter</li><li> which simply divides the incoming clock signal by 16. Assuming we had the 1.8432 MHZ clock signal, that would leave us</li><li class="alt"> with a maximum, 115,200 hertz signal making the UART capable of transmitting and receiving at 115,200 Bits Per Second (BPS).</li><li> That would be fine <span class="keyword">for</span> some of the faster modems and devices which can handle that speed, but others just wouldn't communicate </li><li class="alt">at all. Therefore the UART is fitted with a Programmable Baud Rate Generator which is controlled by two registers.</li><li></li><li class="alt">Lets say <span class="keyword">for</span> example we only wanted to communicate at 2400 BPS. We worked out that we would have to divide 115,200 by 48 to </li><li>get a workable 2400 Hertz Clock. The <span class="string">"Divisor"</span>, in <span class="keyword">this</span> <span class="keyword">case</span> 48, is stored in the two registers controlled by the </li><li class="alt"><span class="string">"Divisor Latch Access Bit"</span>. This divisor can be any number which can be stored in 16 bits (ie 0 to 65535). The UART only </li><li>has a 8 bit data bus, thus <span class="keyword">this</span> is where the two registers are used. The first <span class="keyword">register</span> (Base + 0) when DLAB = 1 stores</li><li class="alt"> the <span class="string">"Divisor latch low byte"</span> where as the second <span class="keyword">register</span> (base + 1 when DLAB = 1) stores the <span class="string">"Divisor latch high byte."</span></li><li></li><li class="alt">Below is a table of some more common speeds and their divisor latch high bytes &amp; low bytes. Note that all the divisors are </li><li>shown in Hexadecimal.</li><li class="alt"></li><li>-------------------------------------------------------------------------------</li><li class="alt">Speed (BPS)  Divisor (Dec)  Divisor Latch High Byte  Divisor Latch Low Byte  </li><li>50    2304     09h     00h  </li><li class="alt">300    384     01h     80h  </li><li>600    192     00h     C0h  </li><li class="alt">2400      48     00h     30h  </li><li>4800      24     00h     18h  </li><li class="alt">9600    12     00h     0Ch  </li><li>19200     6     00h    06h  </li><li class="alt">38400     3     00h     03h  </li><li>57600     2     00h     02h  </li><li class="alt">115200     1     00h     01h</li><li>-------------------------------------------------------------------------------  </li><li class="alt">Table 6 : Table of Commonly Used Baudrate Divisors </li><li></li><li class="alt">Interrupt Enable Register (IER)</li><li></li><li class="alt"></li><li></li><li class="alt">--------------------------------------------------------------------------------</li><li></li><li class="alt"></li><li>-------------------------------------------------------------------------------</li><li class="alt">Bit   Notes </li><li>Bit 7 Reserved </li><li class="alt">Bit 6 Reserved </li><li>Bit 5 Enables Low Power Mode (16750) </li><li class="alt">Bit 4 Enables Sleep Mode (16750) </li><li>Bit 3 Enable Modem Status Interrupt </li><li class="alt">Bit 2 Enable Receiver Line Status Interrupt </li><li>Bit 1 Enable Transmitter Holding Register Empty Interrupt </li><li class="alt">Bit 0 Enable Received Data Available Interrupt </li><li>-------------------------------------------------------------------------------</li><li class="alt">Table 7 : Interrupt Enable Register</li><li></li><li class="alt">The Interrupt Enable Register could possibly be one of the easiest registers on a UART to understand. Setting Bit 0 high enables</li><li> the Received Data Available Interrupt which generates an interrupt when the receiving <span class="keyword">register</span>/FIFO contains data to be read by </li><li class="alt">the CPU. </li><li></li><li class="alt">Bit 1 enables Transmit Holding Register Empty Interrupt. This interrupts the CPU when the transmitter buffer is empty. Bit 2 </li><li>enables the receiver line status interrupt. The UART will interrupt when the receiver line status changes. Likewise <span class="keyword">for</span> bit 3 </li><li class="alt">which enables the modem status interrupt. Bits 4 to 7 are the easy ones. They are simply reserved. (If only everything was that</li><li> easy!) </li><li class="alt"></li><li>Interrupt Identification Register (IIR)</li><li class="alt"></li><li></li><li class="alt"></li><li>-------------------------------------------------------------------------------</li><li class="alt">Bit   Notes </li><li>Bits 6 and 7  Bit 6  Bit 7   </li><li class="alt">  0  0  No FIFO  </li><li>  0  1  FIFO Enabled but Unusable  </li><li class="alt">  1  1  FIFO Enabled  </li><li>Bit 5   64 Byte Fifo Enabled (16750 only) </li><li class="alt">Bit 4   Reserved </li><li>Bit 3   0 Reserved on 8250, 16450 </li><li class="alt">  1 16550 Time-out Interrupt Pending </li><li>Bits 1 and 2  Bit 2 Bit 1    </li><li class="alt">  0  0 Modem Status Interrupt  </li><li>  0  1 Transmitter Holding Register Empty Interrupt </li><li class="alt">  1  0 Received Data Available Interrupt </li><li>  1  1 Receiver Line Status Interrupt </li><li class="alt">Bit0   0 Interrupt Pending </li><li>  1 No Interrupt Pending </li><li class="alt"></li><li>Table 8 : Interrupt Identification Register </li><li class="alt">The interrupt identification <span class="keyword">register</span> is a read only <span class="keyword">register</span>. Bits 6 and 7 give status on the FIFO Buffer. When both bits are <span class="string">'0'</span></li><li> no FIFO buffers are active. This should be the only result you will get from a 8250 or 16450. If bit 7 is active but bit 6 is not </li><li class="alt">active then the UART has it's buffers enabled but are unusable. This occurs on the 16550 UART where a bug in the FIFO buffer made </li><li>the FIFO<span class="string">'s unusable. If both bits are '</span>1' then the FIFO buffers are enabled and fully operational. </li><li class="alt"></li><li>Bits 4 and 5 are reserved. Bit 3 shows the status of the time-out interrupt on a 16550 or higher. </li><li class="alt"></li><li>Lets jump to Bit 0 which shows whether an interrupt has occurred. If an interrupt has occurred it's status will shown by bits 1 </li><li class="alt">and 2. These interrupts work on a priority status. The Line Status Interrupt has the highest Priority, followed by the Data </li><li>Available Interrupt, then the Transmit Register Empty Interrupt and then the Modem Status Interrupt which has the lowest priority. </li><li class="alt"></li><li></li><li class="alt">First In / First Out Control Register (FCR)</li><li></li><li class="alt">-------------------------------------------------------------------------------</li><li>Bit   Notes </li><li class="alt">Bits 6 and 7 Bit 7  Bit 6  Interrupt Trigger Level  </li><li>  0  0  1 Byte  </li><li class="alt">  0  1  4 Bytes  </li><li>  1  0  8 Bytes  </li><li class="alt">  1 1  14 Bytes </li><li>Bit 5   Enable 64 Byte FIFO (16750 only) </li><li class="alt">Bit 4   Reserved </li><li>Bit 3   DMA Mode Select. Change status of RXRDY &amp; TXRDY pins from mode 1 to mode 2. </li><li class="alt">Bit 2   Clear Transmit FIFO </li><li>Bit 1   Clear Receive FIFO </li><li class="alt">Bit 0   Enable FIFO's </li><li>-------------------------------------------------------------------------------</li><li class="alt">Table 9 : FIFO Control Register </li><li></li><li class="alt">The FIFO <span class="keyword">register</span> is a write only <span class="keyword">register</span>. This <span class="keyword">register</span> is used to control the FIFO (First In / First Out) buffers which are </li><li>found on 16550's and higher. </li><li class="alt"></li><li>Bit 0 enables the operation of the receive and transmit FIFO<span class="string">'s. Writing a '</span>0' to <span class="keyword">this</span> bit will disable the operation of transmit </li><li class="alt">and receive FIFO's, thus you will loose all data stored in these FIFO buffers. </li><li></li><li class="alt">Bit<span class="string">'s 1 and 2 control the clearing of the transmit or receive FIFO'</span>s. Bit 1 is responsible <span class="keyword">for</span> the receive buffer <span class="keyword">while</span> bit 2 is </li><li>responsible <span class="keyword">for</span> the transmit buffer. Setting these bits to 1 will only clear the contents of the FIFO and will not affect the </li><li class="alt">shift registers. These two bits are self resetting, thus you don<span class="string">'t need to set the bits to '</span>0' when finished. </li><li></li><li class="alt">Bit 3 enables the DMA mode select which is found on 16550 UARTs and higher. More on <span class="keyword">this</span> later. Bits 4 and 5 are those easy type </li><li>again, Reserved. </li><li class="alt"></li><li>Bits 6 and 7 are used to set the triggering level on the Receive FIFO. For example <span class="keyword">if</span> bit 7 was set to <span class="string">'1'</span> and bit 6 was set to <span class="string">'0'</span> </li><li class="alt">then the trigger level is set to 8 bytes. When there is 8 bytes of data in the receive FIFO then the Received Data Available </li><li>interrupt is set. See (IIR) </li><li class="alt"></li><li>Line Control Register (LCR)</li><li class="alt"></li><li></li><li class="alt"></li><li>----------------------+---------------------------------------------------------</li><li class="alt">Bit    Notes </li><li>Bit 7    1 Divisor Latch Access Bit </li><li class="alt">   0 Access to Receiver buffer, Transmitter buffer &amp; Interrupt Enable Register </li><li>Bit 6    Set Break Enable </li><li class="alt">Bits 3, 4 And 5  Bit 5  Bit 4  Bit 3  Parity Select </li><li>   X  X  0  No Parity  </li><li class="alt">   0  0  1  Odd Parity  </li><li>   0  1  1  Even Parity  </li><li class="alt">   1  0  1  High Parity (Sticky) </li><li>   1  1  1  Low Parity (Sticky) </li><li class="alt">Bit 2   Length of Stop Bit </li><li>   0 One Stop Bit </li><li class="alt">   1 2 Stop bits <span class="keyword">for</span> words of length 6,7 or 8 bits or 1.5 Stop Bits <span class="keyword">for</span> Word lengths of 5 bits. </li><li>Bits 0 And 1   Bit 1  Bit 0  Word Length </li><li class="alt">   0  0  5 Bits  </li><li>   0  1  6 Bits  </li><li class="alt">   1  0  7 Bits  </li><li>   1  1  8 Bits  </li><li class="alt">----------------------+---------------------------------------------------------</li><li>Table 10 : Line Control Register </li><li class="alt"></li><li>The Line Control <span class="keyword">register</span> sets the basic parameters <span class="keyword">for</span> communication. Bit 7 is the Divisor Latch Access Bit or DLAB <span class="keyword">for</span> <span class="datatypes">short</span>. </li><li class="alt">We have already talked about what it does. (See DLAB?) Bit 6 Sets <span class="keyword">break</span> enable. When active, the TD line goes into <span class="string">"Spacing"</span> </li><li>state which causes a <span class="keyword">break</span> in the receiving UART. Setting <span class="keyword">this</span> bit to <span class="string">'0'</span> Disables the Break.</li><li class="alt"></li><li>Bits 3,4 and 5 select parity. If you study the 3 bits, you will find that bit 3 controls parity. That is, <span class="keyword">if</span> it is</li><li class="alt"> set to <span class="string">'0'</span> then no parity is used, but <span class="keyword">if</span> it is set to <span class="string">'1'</span> then parity is used. Jumping to bit 5, we can see that it</li><li> controls sticky parity. Sticky parity is simply when the parity bit is always transmitted and checked as a <span class="string">'1'</span> or <span class="string">'0'</span>. </li><li class="alt">This has very little success in checking <span class="keyword">for</span> errors as <span class="keyword">if</span> the first 4 bits contain errors but the sticky parity bit contains </li><li>the appropriately set bit, then a parity error will not result. Sticky high parity is the use of a <span class="string">'1'</span> <span class="keyword">for</span> the parity bit, </li><li class="alt"><span class="keyword">while</span> the opposite, sticky low parity is the use of a <span class="string">'0'</span> <span class="keyword">for</span> the parity bit. </li><li></li><li class="alt">If bit 5 controls sticky parity, then turning <span class="keyword">this</span> bit off must produce normal parity provided bit 3 is still set to <span class="string">'1'</span>.</li><li> Odd parity is when the parity bit is transmitted as a <span class="string">'1'</span> or <span class="string">'0'</span> so that there is a odd number of 1's. Even parity must </li><li class="alt">then be the parity bit produces and even number of 1's. This provides better error checking but still is not perfect, </li><li>thus CRC-32 is often used <span class="keyword">for</span> software error correction. If one bit happens to be inverted with even or odd parity set, </li><li class="alt">then a parity error will occur, however <span class="keyword">if</span> two bits are flipped in such a way that it produces the correct parity bit </li><li>then an parity error will no occur. </li><li class="alt"></li><li>Bit 2 sets the length of the stop bits. Setting <span class="keyword">this</span> bit to <span class="string">'0'</span> will produce one stop bit, however setting it to <span class="string">'1'</span> will </li><li class="alt">produce either 1.5 or 2 stop bits depending upon the word length. Note that the receiver only checks the first stop bit. </li><li></li><li class="alt">Bits 0 and 1 set the word length. This should be pretty straight forward. A word length of 8 bits is most commonly used today. </li><li></li><li class="alt">Modem Control Register (MCR)</li><li></li><li class="alt">-----+--------------------------------------------------------------------------</li><li>Bit   Notes </li><li class="alt">Bit 7 Reserved </li><li>Bit 6 Reserved </li><li class="alt">Bit 5 Autoflow Control Enabled (16750 only) </li><li>Bit 4 LoopBack Mode  </li><li class="alt">Bit 3 Aux Output 2 </li><li>Bit 2 Aux Output 1 </li><li class="alt">Bit 1 Force Request to Send </li><li>Bit 0 Force Data Terminal Ready </li><li class="alt">-----+--------------------------------------------------------------------------</li><li>Table 11 : Modem Control Register </li><li class="alt"></li><li>The Modem Control Register is a Read/Write Register. Bits 5,6 and 7 are reserved. Bit 4 activates the loopback mode. In Loopback</li><li class="alt">mode the transmitter serial output is placed into marking state. The receiver serial input is disconnected. The transmitter out </li><li>is looped back to the receiver in. DSR, CTS, RI &amp; DCD are disconnected. DTR, RTS, OUT1 &amp; OUT2 are connected to the modem control </li><li class="alt">inputs. The modem control output pins are then place in an inactive state. In <span class="keyword">this</span> mode any data which is placed in the transmitter </li><li>registers <span class="keyword">for</span> output is received by the receiver circuitry on the same chip and is available at the receiver buffer. This can be </li><li class="alt">used to test the UARTs operation.</li><li></li><li class="alt">Aux Output 2 maybe connected to external circuitry which controls the UART-CPU interrupt process. Aux Output 1 is normally </li><li>disconnected, but on some cards is used to <span class="keyword">switch</span> between a 1.8432MHZ crystal to a 4MHZ crystal which is used <span class="keyword">for</span> MIDI. </li><li class="alt">Bits 0 and 1 simply control their relevant data lines. For example setting bit 1 to <span class="string">'1'</span> makes the request to send line active. </li><li></li><li class="alt">Line Status Register (LSR)</li><li></li><li class="alt"></li><li>-----+--------------------------------------------------------------------------</li><li class="alt">Bit  |Notes </li><li>-----+--------------------------------------------------------------------------</li><li class="alt">Bit 7 Error in Received FIFO </li><li>Bit 6 Empty Data Holding Registers  </li><li class="alt">Bit 5 Empty Transmitter Holding Register </li><li>Bit 4 Break Interrupt  </li><li class="alt">Bit 3 Framing Error </li><li>Bit 2 Parity Error </li><li class="alt">Bit 1 Overrun Error </li><li>Bit 0 Data Ready </li><li class="alt">-----+--------------------------------------------------------------------------</li><li>Table 12 : Line Status Register </li><li class="alt">The line status <span class="keyword">register</span> is a read only <span class="keyword">register</span>. Bit 7 is the error in received FIFO bit. This bit is high when at least one <span class="keyword">break</span>,</li><li> parity or framing error has occurred on a byte which is contained in the FIFO. </li><li class="alt"></li><li>When bit 6 is set, both the transmitter holding <span class="keyword">register</span> and the shift <span class="keyword">register</span> are empty. The UART's holding <span class="keyword">register</span> holds the </li><li class="alt">next byte of data to be sent in parallel fashion. The shift <span class="keyword">register</span> is used to convert the byte to serial, so that it can be </li><li>transmitted over one line. When bit 5 is set, only the transmitter holding <span class="keyword">register</span> is empty. So what's the difference between the </li><li class="alt">two? When bit 6, the transmitter holding and shift registers are empty, no serial conversions are taking place so there should be </li><li>no activity on the transmit data line. When bit 5 is set, the transmitter holding <span class="keyword">register</span> is empty, thus another byte can be sent </li><li class="alt">to the data port, but a serial conversion <span class="keyword">using</span> the shift <span class="keyword">register</span> may be taking place. </li><li></li><li class="alt">The <span class="keyword">break</span> interrupt (Bit 4) occurs when the received data line is held in a logic state <span class="string">'0'</span> (Space) <span class="keyword">for</span> more than the time it takes </li><li>to send a full word. That includes the time <span class="keyword">for</span> the start bit, data bits, parity bits and stop bits. </li><li class="alt"></li><li>A framing error (Bit 3) occurs when the last bit is not a stop bit. This may occur due to a timing error. You will most commonly </li><li class="alt">encounter a framing error when <span class="keyword">using</span> a null modem linking two computers or a protocol analyzer when the speed at which the data </li><li>is being sent is different to that of what you have the UART set to receive it at. </li><li class="alt"></li><li>A overrun error normally occurs when your program can<span class="string">'t read from the port fast enough. If you don'</span>t get an incoming byte out of </li><li class="alt">the <span class="keyword">register</span> fast enough, and another byte just happens to be received, then the last byte will be lost and a overrun error will </li><li>result. </li><li class="alt"></li><li>Bit 0 shows data ready, which means that a byte has been received by the UART and is at the receiver buffer ready to be read. </li><li class="alt"></li><li>Modem Status Register (MSR)</li><li class="alt"></li><li></li><li class="alt">-----+--------------------------------------------------------------------------</li><li>Bit  | Notes </li><li class="alt">-----+--------------------------------------------------------------------------</li><li>Bit 7 Carrier Detect </li><li class="alt">Bit 6 Ring Indicator  </li><li>Bit 5 Data Set Ready </li><li class="alt">Bit 4 Clear To Send  </li><li>Bit 3 Delta Data Carrier Detect </li><li class="alt">Bit 2 Trailing Edge Ring Indicator </li><li>Bit 1 Delta Data Set Ready </li><li class="alt">Bit 0 Delta Clear to Send </li><li>-----+--------------------------------------------------------------------------</li><li class="alt">Table 13 : Modem Status Register </li><li></li><li class="alt">Bit 0 of the modem status <span class="keyword">register</span> shows delta clear to send, delta meaning a change in, thus delta clear to send means that there </li><li>was a change in the clear to send line, since the last read of <span class="keyword">this</span> <span class="keyword">register</span>. This is the same <span class="keyword">for</span> bits 1 and 3. Bit 1 shows a </li><li class="alt">change in the Data Set Ready line where as Bit 3 shows a change in the Data Carrier Detect line. Bit 2 is the Trailing Edge Ring </li><li>Indicator which indicates that there was a transformation from low to high state on the Ring Indicator line. </li><li class="alt"></li><li>Bits 4 to 7 show the current state of the data lines when read. Bit 7 shows Carrier Detect, Bit 6 shows Ring Indicator, Bit 5 shows </li><li class="alt">Data Set Ready &amp; Bit 4 shows the status of the Clear To Send line. </li><li></li><li class="alt">--------------------------------------------------------------------------------</li><li></li><li class="alt">Samples</li><li></li><li class="alt"><span class="comment">/* Name       : Sample Comm's Program - Polled Version - termpoll.c     */</span></li><li></li><li class="alt"><span class="preprocessor">#include &lt;dos.h&gt; </span></li><li><span class="preprocessor">#include &lt;stdio.h&gt; </span></li><li class="alt"><span class="preprocessor">#include &lt;conio.h&gt; </span></li><li></li><li class="alt"><span class="preprocessor">#define PORT1 0x3F8 </span></li><li></li><li class="alt">  <span class="comment">/* Defines Serial Ports Base Address */</span></li><li>  <span class="comment">/* COM1 0x3F8                        */</span></li><li class="alt">  <span class="comment">/* COM2 0x2F8          */</span></li><li>  <span class="comment">/* COM3 0x3E8          */</span></li><li class="alt">  <span class="comment">/* COM4 0x2E8          */</span></li><li></li><li class="alt"><span class="keyword">void</span> main(<span class="keyword">void</span>)</li><li>{<!-- --></li><li class="alt"> <span class="datatypes">int</span> c;</li><li> <span class="datatypes">int</span> ch;</li><li class="alt"> outportb(PORT1 + 1 , 0);   <span class="comment">/* Turn off interrupts - Port1 */</span></li><li></li><li class="alt"> <span class="comment">/*         PORT 1 - Communication Settings         */</span></li><li></li><li class="alt"> outportb(PORT1 + 3 , 0x80);  <span class="comment">/* SET DLAB ON */</span></li><li> outportb(PORT1 + 0 , 0x03);  <span class="comment">/* Set Baud rate - Divisor Latch Low Byte */</span></li><li class="alt">         <span class="comment">/* Default 0x03 =  38,400 BPS */</span></li><li>         <span class="comment">/*         0x01 = 115,200 BPS */</span></li><li class="alt">         <span class="comment">/*         0x02 =  57,600 BPS */</span></li><li>         <span class="comment">/*         0x06 =  19,200 BPS */</span></li><li class="alt">         <span class="comment">/*         0x0C =   9,600 BPS */</span></li><li>         <span class="comment">/*         0x18 =   4,800 BPS */</span></li><li class="alt">         <span class="comment">/*         0x30 =   2,400 BPS */</span></li><li> outportb(PORT1 + 1 , 0x00);  <span class="comment">/* Set Baud rate - Divisor Latch High Byte */</span></li><li class="alt"> outportb(PORT1 + 3 , 0x03);  <span class="comment">/* 8 Bits, No Parity, 1 Stop Bit */</span></li><li> outportb(PORT1 + 2 , 0xC7);  <span class="comment">/* FIFO Control Register */</span></li><li class="alt"> outportb(PORT1 + 4 , 0x0B);  <span class="comment">/* Turn on DTR, RTS, and OUT2 */</span></li><li></li><li class="alt"> printf(<span class="string">"/nSample Comm's Program. Press ESC to quit /n"</span>);</li><li></li><li class="alt"> <span class="keyword">do</span> { c = inportb(PORT1 + 5);          <span class="comment">/* Check to see if char has been */</span></li><li>                                       <span class="comment">/* received.                     */</span></li><li class="alt">      <span class="keyword">if</span> (c &amp; 1) {ch = inportb(PORT1); <span class="comment">/* If so, then get Char          */</span></li><li>                  printf(<span class="string">"%c"</span>,ch);}    <span class="comment">/* Print Char to Screen          */</span></li><li class="alt"></li><li>      <span class="keyword">if</span> (kbhit()){ch = getch();         <span class="comment">/* If key pressed, get Char */</span></li><li class="alt">                   outportb(PORT1, ch);} <span class="comment">/* Send Char to Serial Port */</span></li><li></li><li class="alt">    } <span class="keyword">while</span> (ch !=27); <span class="comment">/* Quit when ESC (ASC 27) is pressed */</span></li><li>}</li><li class="alt">--------------------------------------------------------------------------------</li><li>The End</li><li class="alt"></li></ol></div>
<p> </p>
<p> </p>
</div>
    </div>
    
    <div class="footer">
        <p>发表时间: 2008-09-21 21:08:00</p>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    <script>
        // 处理代码块，添加语言类和复制功能
        document.addEventListener('DOMContentLoaded', function() {            
            // 为没有指定语言的代码块添加默认语言
            document.querySelectorAll('pre code:not([class*="language-"])').forEach(function(block) {
                block.className = 'hljs language-javascript';
            });
            
            // 确保所有代码块都有hljs类
            document.querySelectorAll('pre code[class*="language-"]:not([class*="hljs"])').forEach(function(block) {
                block.className = 'hljs ' + block.className;
            });
            
            // 为所有代码块添加自定义复制按钮
            document.querySelectorAll('pre').forEach(function(pre) {
                // 创建复制按钮
                var copyButton = document.createElement('button');
                copyButton.className = 'copy-button';
                copyButton.textContent = '复制';
                copyButton.style.position = 'absolute';
                copyButton.style.top = '5px';
                copyButton.style.right = '5px';
                copyButton.style.background = 'rgba(0,0,0,0.3)';
                copyButton.style.color = 'white';
                copyButton.style.border = 'none';
                copyButton.style.borderRadius = '3px';
                copyButton.style.padding = '5px 10px';
                copyButton.style.fontSize = '0.8em';
                copyButton.style.cursor = 'pointer';
                copyButton.style.display = 'none';
                
                // 鼠标悬停时显示按钮
                pre.addEventListener('mouseenter', function() {
                    copyButton.style.display = 'block';
                });
                
                pre.addEventListener('mouseleave', function() {
                    copyButton.style.display = 'none';
                });
                
                // 点击复制按钮时复制代码
                copyButton.addEventListener('click', function() {
                    var code = pre.querySelector('code');
                    var text = code.textContent || code.innerText;
                    
                    // 使用现代的 Clipboard API
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(text)
                            .then(function() {
                                copyButton.textContent = '已复制!';
                                setTimeout(function() {
                                    copyButton.textContent = '复制';
                                }, 2000);
                            })
                            .catch(function(err) {
                                console.error('Clipboard API 复制失败:', err);
                                // 如果 Clipboard API 失败，尝试使用传统方法
                                fallbackCopyToClipboard();
                            });
                    } else {
                        // 对于不支持 Clipboard API 的浏览器，使用传统方法
                        fallbackCopyToClipboard();
                    }
                    
                    // 传统复制方法作为后备
                    function fallbackCopyToClipboard() {
                        // 创建临时文本区域
                        var textArea = document.createElement('textarea');
                        textArea.value = text;
                        textArea.style.position = 'fixed';
                        textArea.style.left = '-9999px';
                        textArea.style.top = '0';
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();
                        
                        try {
                            var successful = document.execCommand('copy');
                            if (successful) {
                                copyButton.textContent = '已复制!';
                                setTimeout(function() {
                                    copyButton.textContent = '复制';
                                }, 2000);
                            } else {
                                copyButton.textContent = '复制失败';
                            }
                        } catch (err) {
                            copyButton.textContent = '复制失败';
                            console.error('传统复制方法失败:', err);
                        }
                        
                        document.body.removeChild(textArea);
                    }
                });
                
                // 添加按钮到代码块
                pre.style.position = 'relative';
                pre.appendChild(copyButton);
            });
            
            // 确保Prism重新高亮所有代码块
            if (typeof Prism !== 'undefined') {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>
